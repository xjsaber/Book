# Java 7 并发编程实战手册 #

## 序章 ##

* 线程管理，通过基础的范例来讲解线程的创建、线程的执行以及线程的状态管理；
* 线程同步基础，为读者讲解如何使用低级的Java机制，比如采用Lock锁接口和synchronized关键字来同步代码；
* 线程同步辅助类，讲解如何使用Java的高级工具类来管理Java中的线程同步；
* 线程执行器（Thread Executor），讲解如何将线程管理委托给执行器（Executor）。执行器将为并发任务负责线程的创建、运行、管理并返回任务的结果；
* Fork/Join框架（Fork/Join Framework），讲解Java7新的一种特殊的执行器Fork/Join框架。用来解决通过分治技术（Divide and conquer Technique）将任务拆分成多个子任务的问题；
* 并发集合，使用一些由Java语言提供的并发数据结构，从而避免在程序的实现中采用synchronized代码块；
* 定制并发类（Customizing Concurrency Classe）。
* 测试并发应用（Testing Concurrent Application），讲解如何获取Java7并发API中最有用的结构的状态信息。

## 前言 ##

## 第1章 线程管理 ##

* 线程的创建和运行
* 线程信息的获取和设置
* 线程的中断
* 线程中断的控制
* 线程的休眠和修复
* 等待线程的终止
* 守护线程的创建和运行
* 线程中不可控异常的处理
* 线程局部变量的使用
* 线程的分组
* 线程组中不可控异常的处理
* 使用工厂类创建线程

### 1.1 简介 ###

### 1.2 线程的创建和运行 ###

在Java语言中，线程跟其他所有元素一样，都是对象（Object）。Java提供了两种方式来创建线程：

* 继承Thread类，并且覆盖run()方法
* 创建一个实现Runnable接口的类。使用带参数的Thread构造器来构建Thread对象。这个参数就是实现Runnable接口的类的一个对象。

**工作原理**

每个Java程序都至少有一个执行线程。当运行程序的时候，JVM将启动这个执行线程来调用程序的main()方法。

当调用Thread对象的start()方法时，另一个执行线程将被创建。因而在我们的程序中，每次调用start()时，都会创建一个执行线程。

当一个程序的所有线程都运行完成时，更明确的说，当所有非守护（non-daemon）线程都运行完成的时候，这个Java程序将宣告结束。如果初始线程（执行main()方法的线程）结束了，其余的线程仍将继续执行直到他们运行结束。如果某一个线程调用了System.exit()指令来结束程序的执行，所有的线程都将结束。

对一个实现了Runnable接口的类来说，创建Thread对象并不会创建一个新的执行线程：同样的，调用它的run()方法，也不会创建一个新的执行线程。只有调用它的start()方法，才会创建一个新的执行线程。

**更多信息**

编写一个类并继承Thread类，在这个类里覆盖run()方法，然后创建这个类的对象，并且调用start()方法，也会创建一个执行线程。

### 1.3 线程信息的获取和设置 ###

Thread类有一些保存信息的属性，这些属性可以用来标识线程，显示线程的状态和控制线程的优先级。

ID:保存了线程的唯一标识符。
Name：保存了线程名称。
Priority：保存了线程对象的优先级。线程的优先级是从1到10，其中1是最低优先级；10是最高优先级。
Staus：保存了线程的状态。在Java中，线程的状态有6种：new、runnable、blocked、waiting、time waiting或者terminated。

**工作原理**

Thread类的属性存储了线程的所有信息。JVM使用线程的priority属性来决定某一刻由哪个线程来使用CPU，并且根据线程的情景为它们设置实际状态。

如果没有为线程指定一个名字，JVM将自动给它分配一个名字，格式是Thread-XX，其中XX是一组数字。线程的ID和状态是不允许被修改的，线程类没有提供setId()和setStatus()方法来修改它们。

**更多信息**


### 1.4 线程的中断 ###

所有的非守护线程运行结束时，或者其中一个线程调用了System.exit()方法时，这个Java程序才运行结束。

Java提供了中断机制，使用它来结束一个线程。这种机制要求线程检查它是否被中断了，然后决定是不是响应这个中断请求。

**工作原理**

Thread类有一个表明线程被中断与否的属性，它存放的是布尔值。线程的interrupt()方法被调用时，这个属性就会被设置位true。isInterrupted()方法只是返回这个属性的值。

**更多信息**

Thread类的静态方法interrupted()，用来检查当前执行的线程是否被中断。

isInterrupted()和interrupt()方法有一个很大的区别。isInterrupted()不能改变interrupted属性的值，但是后者能设置interrupted属性位false。因为interrupted()是一个静态方法，梗推荐使用isInterrupted()方法。

### 1.5 线程中断的控制 ###

如果线程实现了复杂的算法并且分布在几个方法中，或者线程里有递归调用的方法，我们就得使用一个更好的机制来控制线程的中断。

InterruptedException异常。当检查到线程中断的时候，就抛出这个异常，然后在run()种捕获并处理这个异常。

**工作原理**

使用Java异常来控制线程的中断，程序将递归调用processDirectory()方法3次。不管递归用了多少次，只要线程检测到它已经被中断，就会立即抛出InterruptedException异常，然后继续执行run()方法。

### 1.6 线程的休眠和恢复 ###

某一个预期的时间中断线程的执行。

sleep()方法的另一种使用方式是通过TimeUnit枚举类元素进行调用。这个方法也使用Thread的sleep()方法来使当前线程休眠，但是它接收的参数单位是秒，最后会被转化成毫秒。

**工作原理**

当调用sleep()方法之后，线程会释放CPU并且不再继续执行任务。在这段时间内，线程不占用CPU时钟，所以CPU可以执行其他的任务。

如果休眠中线程被中断，该方法就会立即抛出InterruptedException异常，而不需要等待到线程休眠时间结束。

**更多信息**

Java并发API还提供了另外一个方法来使线程对象释放CPU，即yield()方法，将通知JVM这个线程对象可以释放CPU了

**参见**

### 1.7 等待线程的终止 ###

Thread类的join()方法。当一个线程对象的join()方法被调用时，调用它的线程将被挂起，直到这个线程对象完成它的任务。

**工作原理**

DataSourcesLoader线程运行结束，NetworkConnectionsLoader线程也运行结束的是偶，主线程对象才会继续并且打印出最终的信息。

**更多信息**

	join(long milliseconds)
	join(long milliseconds, long nanos)

当一个线程调用其他某个线程的join()方法时，如果使用第一种join()方式，那么不必等到被调用线程运行终止，如果参数指定的毫秒时钟已经到达，它将继续运行。

thread1有这样的代码thread2.join(1000)，thread1将挂起运行，直到

* thread2运行已经完成；
* 时钟已经过去1000毫秒。

当两个条件中的任何一条成立时，join()方法将返回。第二中join()方法跟第一种相似，只是需要接受毫秒和纳秒两个参数。

### 1.8 守护线程的创建和运行 ###

守护（Daemon）线程。线程的优先级很低，通常来说，当同一个应用程序里没有其他的线程运行的时候，守护线程才运行。当守护线程是程序中唯一运行的线程时，守护线程执行结束后，JVM也就结束了这个程序。

守护线程通常被用来做为同一程序中普通线程（也称为用户线程）的服务提供者。通常是无限循环的，以等待服务请求或者执行线程的任务。不能做重要的工作，因为不可能知道守护线程什么时候能够获取CPU时钟，并且，在没有其他线程的运行的时候，守护线程随时可能结束。一个典型的守护线程是Java的垃圾回收器（Garbage Collector）。

### 1.9 线程种不可控异常的处理 ###

setDaemon()方法只能在start()方法被调用之前设置。一旦线程开始运行，将不能再修改为守护状态。

* 非运行时异常（CheckedException）：这种异常必须在方法声明的throws语句指定，或者在方法体内捕获。IOException和ClassNotFoundException
* 运行时异常（Unchecked Exception）：这种异常不必再方法声明中指定，也不需要再方法中捕获。NumberFormatException

isDaemon()方法被用来检查一个线程是否是守护线程，返回值true表示这个线程是守护线程，false表示这个线程是用户线程。

run()方法不支持throws语句，所以当线程对象的run()方法抛出非运行异常时，必须捕获并且处理它们。当运行时异常从run()方法中抛出时，默认行为是再控制台输出堆栈记录并且推出程序。

**工作原理**

当一个线程抛出了异常并且没有被捕获时（这种情况只可能是运行时异常），JVM检查这个线程是否被预置了未捕获异常处理器。如果找到，JVM将调用线程对象的这个方法，并将线程对象和异常作为传入参数。

**更多信息**

Thread类还有另一个方法可以处理未捕获到的异常，即静态方法setDefaultUncaughtExceptionHandler()。这个方法再应用程序中为所有的线程对象创建了一个异常处理器。

异常处理器

1. 线程对象的未捕获异常处理器
2. 找不到，JVM继续查找线程对象所在的线程组（ThreadGroup）的未捕获异常处理器
3. 如果还找不到，将继续查找默认的未捕获异常处理器

### 1.10 线程局部变量的使用 ###

共享数据是并发程序最核心的问题之一，对于继承了Thread类或者实现了Runnable接口的对象来说尤其重要。

如果创建的对象是实现了Runnable接口的类的实例，用它作为传入参数创建多个线程对象并启动这些线程，那么所有的线程将共享相同的属性。也就是说，如果在一个线程中改变了一个属性，那么所有线程都将会被这个改变影响。

在某种情况下，这个对象的属性不需要被所有线程共享。Java并发API提供了一个干净的机制，即线程局部变量（Thread-Local Variable），其具有很好的性能。

**工作原理**

线程局部变量分别为每个线程存储了各自的属性值，并提供给每个线程使用。使用get()方法读取这个值，并用set()方法设置这个值。如果线程是第一次访问线程局部变量，线程局部变量可能还没有为它存储值，这个时候initialValue()方法就会被调用，并且返回当前的时间值。

**更多信息**

线程局部变量提供了remove()方法，用来为访问这个变量的线程删除已经存储的值。Java并发API包含了InheritableThreadLocal类，如果一个线程是从其他某个线程中创建的，这个类将提供继承的值。

如果一个线程A在线程局部变量已有值，当它创建其他某个线程B时，线程B的线程局部变量将线程A是一样的。可以覆盖childValue()方法，这个方法用来初始化子线程在线程局部变量中的值。它使用父线程在线程局部变量中的值作为传入参数。

### 1.11 线程的分组 ###

并发API，能够把线程分组。

Java提供ThreadGroup类标识一组线程。线程组可以包含线程对象，也可以包含其他的线程组对象，它是一个树形结构。

**工作原理**

list()方法的输出及每个线程对象的状态。

通过activeCount()方法获取线程组包含的线程数目，通过enumerate()方法获取线程组包含的线程列表。

	Thread[] threads = new Thread[threadGroup.activeCount()];
	threadGroup.enumerate(threads);
	for (int i = 0; i < threadGroup.activeCount(); i++) {
		System.out.printf("Thread %s: %s\n", threads[i].getName(), threads[i].getState());
	}

使用interrupt()方法中断这个组中的其余线程。

	threadGroup.interrupt();

调用waitFinish()方法，将等到线程组的第一个线程运行结束
	
	private static void waitFinish(ThreadGroup threadGroup) {
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch(InterruptedException e) {
			e.printStackTrace();
		}
	}



线程组类存储了线程对象和关联的线程组对象，并可以访问它们的信息（例如状态），将执行的操作应用在所有成员上（例如中断）。

### 1.12 线程组种不可控异常的处理 ###

Java提供了捕获和处理异常的机制，有的异常必须被捕获，或者必须使用方法的throws声明再次抛出，这类异常叫作非运行时异常。还有一类异常叫作运行时异常，它们不需要被捕获或者声明抛出。

**工作原理**

当运行范例的时候，当一个线程对象抛出了异常，其余的线程对象都被中断。

当线程抛出非捕获异常时，JVM将会这个异常寻找3中可能的处理器。

1. 寻找抛出这个异常的线程的非捕获异常处理器
2. JVM继续查找这个线程所在的线程组的非捕获异常处理器

**更多信息**

### 1.13 使用工厂类创建线程 ###

工厂模式是面向对象编程中最常使用的模式之一。

使用工厂类，可以将对象的创建集中化：

1. 更容易修改类，或者改变创建对象的方式；
2. 更容易为有限资源限制创建对象的数目。
3. 更容易为创建的对象生成统计数据。

Java提供了ThreadFactory接口，这个接口实现了线程对象工厂。

**工作原理**

ThreadFactory接口只有一个方法，即newThread，它以Runnable接口对象为传入参数并且范佳慧一个线程对象。当实现ThreadFactory接口时，必须实现覆盖这个方法。大多数基本的线程工具类只有一行。
	
	return new Thread(r);

可以通过增加一些边划来强化实现方法覆盖。

* 创建一个个性化线程，如本范例使用一个特殊的格式作为线程名，或者通过继承Thread类来创建自己的线程类；
* 保存新创建的线程统计数据，如本节的范例那样；
* 限制创建的线程的数量；
* 对生成的线程进行验证；
* 更多你可以想到的。

**更多信息**


# 第2章 线程同步基础 #

* synchronized实现同步方法
* 使用非依赖属性实现同步
* 在同步代码块中使用条件
* 使用锁实现同步
* 使用读写锁同步数据访问
* 修改锁的公平性
* 在锁中使用多条件

## 2.1 简介 ##

* synchronized关键字机制
* Lock接口及其实现机制

## 2.2 使用synchronized实现同步方法 ##

**准备工作**

**范例实现**

**工作原理**

synchronized关键字的使用，保证了在并发程序中对共享数据的正确访问。

**更多信息**

synchronized关键字会降低应用程序的性能。

可以递归调用被synchronized声明的方法。当线程访问一个对象的同步方法时，还可以调用这个对象的其他的同步方法，也包含正在执行的方法，而不必再次去获取这个方法的访问权。

this关键字来引用正在执行的方法所属的对象

	synchronized(this) {
		// Java code
	}

## 2.3 使用非依赖属性实现同步 ##

**准备工作**

**范例实现**

**工作原理**

用synchronized关键字保护代码块时，使用对象作为它的传入参数。JVM保证同一时间只有一个线程能够访问这个对象的代码保护块。

**更多信息**

**参见**

## 2.4 在同步代码中使用条件 ##

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

## 2.5 使用锁实现同步 ##

Java提供了同步代码块的另一种机制，它是一种比synchronized关键字更强大也更灵活的机制。这种机制基于Lock接口及其实现类（例如ReetrantLock），提供了更多的好处。

* 支持更灵活的同步代码块结构，使用synchronized关键字时，只能在同一个synchronized块结构中获取和释放控制。Lock接口允许实现更复杂的临界区结构（即控制的获取和释放不出现在同一个块结构中）。
* 相比synchronized关键字，Lock接口提供了更多的功能。tryLock()方法的实现。这个方法试图获取锁，如果锁已被其他线程获取，它将返回false并继续往下执行代码。使用synchronized关键字时，如果线程A视图执行一个同步代码块，而线程B已在执行这个同步代码块，则线程A就会被挂起直到线程B运行完这个同步代码块。使用锁的tryLock()方法，通过返回值将得知是否有其他线程正在使用这个锁保护的代码块。
* Lock接口允许分离读和写操作，允许多个读线程和只有一个写线程
* 相比synchronized关键字，Lock结构具有更好的性能。

**准备工作**

**范例实现**

**工作原理**

在临界区的开始，必须通过lock()方法获取对锁的控制。当线程A访问这个方法时，如果没有其他线程获取对这个锁的控制，lock()方法将让线程A获得锁并且允许它立刻执行临界区代码。否则，如果其他线程B正在执行这个锁保护的临界区代码，lock()方法将让线程A休眠直到线程B执行完临界区的代码。

当线程离开临界区的时候，必须使用unlock()方法来释放它持有的锁，以让其他的线程来访问临界区。如果在离开临界区的时候没有调用unlock()方法，其他线程将永久地等待，从而导致了死锁（Deadlock）情景。如果在临界区是用了try-catch块，不要忘记将unlock()方法放入finally部分。

**更多信息**

Lock接口（和它的实现类ReentrantLock）提供了另一个方法来获取锁，即tryLock()方法，即lock()方法最大的不同是，不仅能够获取锁，而且会立即返回，不会将线程置入休眠。

ReentrantLock类允许使用递归调用。

**参见**

## 2.6 使用读写锁实现同步数据访问 ##

锁机制的最大的改进之一就是ReadWriteLock接口和它的唯一实现类ReentrantReadWriteLock。读操作锁和写操作锁。使用读操作锁时可以允许多个线程同时访问，但是写操作锁时只允许一个线程进行。在一个线程执行写操作时，其他线程不能够执行读操作。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

ReetranReadWriteLock类有两个锁：一种是都操作锁，另一种是写操作锁。读操作锁是通过ReadWriteLock接口的readLock()方法获取的，这个锁实现了Lock接口，所以可以使用lock()，unlock()和tryLock()方法。写操作锁是通过ReadWriteLock接口的writeLock()方法获取的，这个锁同样也实现了Lock接口，所以可以使用lock()、unlock()和tryLock()方法。

**参见**

## 2.7 修改锁的公平性 ##

ReetrantLock和ReentrantReadWriteLock类的构造器都含有一个布尔参数fair，它允许控制着两个类的行为。默认fair值是false，称为非公平模式（Non-Fair Mode）。在非公平模式下，当有许多线程再等待锁（ReentranLock和ReentranReadWriteLock）时，锁将选择它们中的一个来访问临界区，而且选择的是等待事件最长的。

lock()和unlock()，Lock接口的tryLock()方法没有将线程置于休眠，fair属性并不影响这个方法。

**准备工作**

**范例实现**

**工作原理**

所有线程是按顺序创建的，每个线程都执行两个被锁保护的代码块。然后访问时线程并没有按照创建的先后顺序。锁将选择任一线程并让它访问锁保护的代码。JVM没有对线程的执行顺序提供保障。

**更多信息**

读/写锁的构造器也有一个公平策略的参数

**参见**

## 2.8 在锁中使用多条件（Multiple Condition） ##

一个锁可能关联一个或多个条件，这些条件通过Condition接口声明。目的是允许线程获取锁并且查看等待的某一个条件是否满足，如果不满足就挂起直到某个线程唤醒它们。

Condition接口提供了挂起线程和唤起线程的机制。

并发编程中的一个典型问题是生产者-消费者（Producer-Consumer）问题。使用一个数据缓冲区，一个或者多个数据生产者（Producer）将数据保存到缓冲区，一个货哦这多个数据消费者（Consumer）将数据从缓冲区中取走。

**准备工作**

**范例实现**

**工作原理**

与锁绑定的所有条件对象都是通过Lock接口的声明的newCondition()方法创建的。再使用条件的时候，必须获取这个条件绑定的锁，所以带条件的代码必须再调用Lock对象的lock方法和unlock()方法之间。

当线程调用条件的await()方法时，将自动释放这个条件绑定的锁，其他某个线程才可以获取这个锁并且执行相同的操作，或者执行这个锁保护的另一个临界区代码。

**更多信息**

Condition接口还提供了await()方法的其他形式。

await(long time, TimeUnit unit)，直到发生以下的情况之一之前，线程将一直处于休眠状态。

* 其他某个线程中断当前线程。
* 其他某个线程调用了将当前线程挂起的条件的signal()或signalAll()方法。
* 只当的等待时间已经过去。
* 通过TimeUnit类的常量DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES|ANOSECONDS和SECONDS指定的等待时间已经过去。

awaitUnitnterruptibly():它是不可中断你的。这个线程将休眠直到其他某个线程调用了将它挂起的条件的signal()或signalAll()方法。
awaitUnit(Date date):直到发生以下情况之一之前，线程将一直处于休眠状态。

* 其他某个线程中断当前线程
* 其他某个线程调用了将它挂起的条件的signal()或signalAll()方法
* 指定的最后期限到了
* 也可以将条件与读写锁ReadLock和WriteLock一起使用。

**参见**

# 第3章 线程同步辅助类 #

* 资源的并发访问控制
* 资源的多副本的并发访问控制
* 等待多个并发事件的完成
* 在集合点的同步
* 并发阶段任务的运行
* 并发阶段任务中的阶段切换
* 并发任务间的数据交换

## 3.1 简介 ##

* 信号量（Semaphore）：是一种计数器，用来保护一个或者多个共享资源的访问。
* CoundDownLatch：是Java语言提供的同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许线程一直等待。
* CyclicBarrier：也是Java语言提供的同步辅助类，它允许多个线程在某个集合点（common point）处进行相互等待。
* Phaser：也是Java语言提供的同步辅助类。它把并发任务分成阶段运行，在开始下一阶段之前，当前阶段中的所有阶段必须执行。
* Exchanger：也是Java语言提供的同步辅助类。

## 3.2 资源的并发访问控制 ##

信号量是一种计数器，用来保护一个或者多个共享资源的访问。

如果线程要访问一个共享资源，必须先获得信号量。如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。计数器大于0意味着可以使用的资源，因此线程被允许使用其中一个资源。

**准备工作**

**范例实现**

**工作原理**

使用信号量实现临界区必须遵循的三个步骤，从而保护对共享资源的访问：

1. 必须通过acquire()方法获得信号量
2. 使用共享资源执行必要的操作
3. 必须通过release()方法释放信号量

**更多信息**

* acquireUninterruptibly():其实就是acquire()方法。当信号量的内部计数器变成0的时候，信号量将阻塞线程直到其被释放。线程在被阻塞的这段时间中，可能会被终端，从而导致acquire()方法抛出InterruptedException异常。而acquireUninterruptibly()方法会忽略线程的中断并且不会抛出任何异常。
* tryAcquire()试图获得信号量。如果能获得就返回true；如果不能，就返回false，从而避开线程的阻塞和等待信号量的释放。——>可以根据返回值是true还是false来做恰当的处理。

**参见**

## 3.3 资源的多副本的并发访问控制 ##

基础信号量，保护单一共享资源，或者单一临界区的访问，从而使得保护的资源在同一个时间内只能被一个线程访问。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

acquire()、acquireUninterruptibly()、tryAcquire()和release()方法都有另一种实现方式

**参见**

## 3.4 等待多个并发事件的完成 ##

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

## 3.5 在集合点的同步 ##

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

## 3.6 并发阶段任务的运行 ##

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

## 3.7 并发阶段任务中的阶段切换 ##

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

## 3.8 并发任务间的数据交换 ##

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

# 第4章 线程执行器 #