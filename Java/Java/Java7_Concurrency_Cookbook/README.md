# Java 7 并发编程实战手册 #

## 序章 ##

* 线程管理，通过基础的范例来讲解线程的创建、线程的执行以及线程的状态管理
* 线程同步基础
* 线程同步辅助类
* 线程执行器
* Fork/Join框架（Fork/Join Framework）
* 并发集合
* 定制并发类
* 测试并发应用

## 第1章 线程管理 ##

### 1.1 简介 ###

### 1.2 线程的创建和运行 ###

在Java语言中，线程跟其他所有元素一样，都是对象（Object）。Java提供了两种方式来创建线程：

* 继承Thread类，并且覆盖run()方法
* 创建一个实现Runnable接口的类。使用带参数的Thread构造器来构建Thread对象。这个参数就是实现Runnable接口的类的一个对象。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

### 1.3 线程信息的获取和设置 ###

Thread类有一些保存信息的属性，这些属性可以用来标识线程，显示线程的状态和控制线程的优先级。

ID:保存了线程的唯一标识符。
Name：保存了线程名称。
Priority：保存了线程对象的优先级。线程的优先级是从1到10，其中1是最低优先级；10是最高优先级。
Staus：保存了线程的状态。在Java中，线程的状态有6种：new、runnable、blocked、waiting、time waiting或者terminated。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**工作原理**

**更多信息**

### 1.4 线程的中断 ###

所有的非守护线程运行结束时，或者其中一个线程调用了System.exit()方法时，这个Java程序才运行结束。

Java提供了中断机制，使用它来结束一个线程。这种机制要求线程检查它是否被中断了，然后决定是不是响应这个中断请求。

**准备工作**

**范例实现**

**工作原理**

Thread类有一个表明线程被中断与否的属性，它存放的是布尔值。线程的interrupt()方法被调用时，这个属性就会被设置位true。isInterrupted()方法只是返回这个属性的值。

**更多信息**

Thread类的静态方法interrupted()，用来检查当前执行的线程是否被中断。

isInterrupted()和interrupt()方法有一个很大的区别。isInterrupted()不能改变interrupted属性的值，但是后者能设置interrupted属性位false。因为interrupted()是一个静态方法，梗推荐使用isInterrupted()方法。

### 1.5 线程中断的控制 ###

InterruptedException异常。当检查到线程中断的时候，就抛出这个异常，然后在run()种捕获并处理这个异常。

**准备工作**

**范例实现**

**工作原理**

使用Java异常来控制线程的中断，程序将递归调用processDirectory()方法3次。不管递归用了多少次，只要线程检测到它已经被中断，就会立即抛出InterruptedException异常，然后继续执行run()方法。

**更多信息**

**参见**

### 1.6 线程的休眠和恢复 ###

sleep()方法的另一种使用方式是通过TimeUnit枚举类元素进行调用。这个方法也使用Thread的sleep()方法来使当前线程休眠，但是它接收的参数单位是秒，最后会被转化成毫秒。

**准备工作**

**范例实现**

**工作原理**

当调用sleep()方法之后，线程会释放CPU并且不再继续执行任务。在这段时间内，线程不占用CPU时钟，所以CPU可以执行其他的任务。

如果休眠中线程被中断，该方法就会立即抛出InterruptedException异常，而不需要等待到线程休眠时间结束。

**更多信息**

Java并发API还提供了另外一个方法来使线程对象释放CPU，即yield()方法，将通知JVM这个线程对象可以释放CPU了

**参见**

### 1.7 等待线程的终止 ###

Thread类的join()方法。当一个线程对象的join()方法被调用时，调用它的线程将被挂起，直到这个线程对象完成它的任务。

**准备工作**

**范例实现**

**工作原理**

DataSourcesLoader线程运行结束，NetworkConnectionsLoader线程也运行结束的是偶，主线程对象才会继续并且打印出最终的信息。

**更多信息**

	join(long milliseconds)
	join(long milliseconds, long nanos)

当一个线程调用其他某个线程的join()方法时，如果使用第一种join()方式，那么不必等到被调用线程运行终止，如果参数指定的毫秒时钟已经到达，它将继续运行。

thread1有这样的代码thread2.join(1000)，thread1将挂起运行，直到

* thread2运行已经完成；
* 时钟已经过去1000毫秒。

当两个条件中的任何一条成立时，join()方法将返回。

### 1.8 守护线程的创建和运行 ###

守护（Daemon）线程。线程的优先级很低，通常来说，当同一个应用程序里没有其他的线程运行的时候，守护线程才运行。当守护线程是程序中唯一运行的线程时，守护线程执行结束后，JVM也就结束了这个程序。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

### 1.9 线程种不可控异常的处理 ###

* 非运行时异常（CheckedException）
* 运行时异常（Unchecked Exception）

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

### 1.10 线程局部变量的使用 ###

共享数据是并发程序最核心的问题之一，对于继承了Thread类或者实现了Runnable接口的对象来说尤其重要。

如果创建的对象是实现了Runnable接口的类的实例，用它作为传入参数创建多个线程对象并启动这些线程，那么所有的线程将共享相同的属性。也就是说，如果在一个线程中改变了一个属性，那么所有线程都将会被这个改变影响。

**准备工作**

**范例实现**

**工作原理**

线程局部变量分别为每个线程存储了各自的属性值，并提供给每个线程使用。使用get()方法读取这个值，并用set()方法设置这个值。如果线程是第一次访问线程局部变量，线程局部变量可能还没有为它存储值，这个时候initialValue()方法就会被调用，并且返回当前的时间值。

**更多信息**

**参见**

### 1.11 线程的分组 ###

并发API，能够把线程分组。

Java提供ThreadGroup类标识一组线程。线程组可以包含线程对象，也可以包含其他的线程组对象，它是一个树形结构。

**准备工作**

**范例实现**

**工作原理**

list()方法的输出及每个线程对象的状态。

线程组类存储了线程对象和关联的线程组对象，并可以访问它们的信息（例如状态），将执行的操作应用在所有成员上（例如中断）。

**更多信息**

**参见**

### 1.12 线程组种不可控异常的处理 ###

Java提供了捕获和处理异常的机制，有的异常必须被捕获，或者必须使用方法的throws声明再次抛出，这类异常叫作非运行时异常。还有一类异常叫作运行时异常，它们不需要被捕获或者声明抛出。

**准备工作**

**范例实现**

**工作原理**

当运行范例的时候，当一个线程对象抛出了异常，其余的线程对象都被中断。

当线程抛出非捕获异常时，JVM将会这个异常寻找3中可能的处理器。

1. 寻找抛出这个异常的线程的非捕获异常处理器
2. JVM继续查找这个线程所在的线程组的非捕获异常处理器

**更多信息**

**参见**

### 1.13 使用工厂类创建线程 ###

工厂模式是面向对象编程中最常使用的模式之一。

使用工厂类，可以将对象的创建集中化：

1. 更容易修改类，或者改变创建对象的方式；
2. 更容易为有限资源限制创建对象的数目。
3. 更容易为创建的对象生成统计数据。

**准备工作**

**范例实现**

**工作原理**

ThreadFactory接口只有一个方法，即newThread，它以Runnable接口对象为传入参数并且范佳慧一个线程对象。当实现ThreadFactory接口时，必须实现覆盖这个方法。大多数基本的线程工具类只有一行。
	
	return new Thread(r);

可以通过增加一些边划来强化实现方法覆盖。

* 创建一个个性化线程，如本范例使用一个特殊的格式作为线程名，或者通过继承Thread类来创建自己的线程类；
* 保存新创建的线程统计数据，如本节的范例那样；
* 限制创建的线程的数量；
* 对生成的线程进行验证；
* 更多你可以想到的。

**更多信息**

**参见**



# 第2章 线程同步基础 #

* synchronized实现同步方法
* 使用非依赖属性实现同步
* 在同步代码块中使用条件
* 使用锁实现同步
* 使用读写锁同步数据访问
* 修改锁的公平性
* 在锁中使用多条件

## 2.1 简介 ##

* synchronized关键字机制
* Lock接口及其实现机制

## 2.2 使用synchronized实现同步方法 ##

**准备工作**

**范例实现**

**工作原理**

synchronized关键字的使用，保证了在并发程序中对共享数据的正确访问。

**更多信息**

synchronized关键字会降低应用程序的性能。

可以递归调用被synchronized声明的方法。当线程访问一个对象的同步方法时，还可以调用这个对象的其他的同步方法，也包含正在执行的方法，而不必再次去获取这个方法的访问权。

this关键字来引用正在执行的方法所属的对象

	synchronized(this) {
		// Java code
	}

## 2.3 使用非依赖属性实现同步 ##

**准备工作**

**范例实现**

**工作原理**

用synchronized关键字保护代码块时，使用对象作为它的传入参数。JVM保证同一时间只有一个线程能够访问这个对象的代码保护块。

**更多信息**

**参见**

## 2.4 在同步代码中使用条件 ##

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

## 2.5 使用锁实现同步 ##

Java提供了同步代码块的另一种机制，它是一种比synchronized关键字更强大也更灵活的机制。这种机制基于Lock接口及其实现类（例如ReetrantLock），提供了更多的好处。

* 支持更灵活的同步代码块结构，使用synchronized关键字时，只能在同一个synchronized块结构中获取和释放控制。Lock接口允许实现更复杂的临界区结构（即控制的获取和释放不出现在同一个块结构中）。
* 相比synchronized关键字，Lock接口提供了更多的功能。tryLock()方法的实现。这个方法试图获取锁，如果锁已被其他线程获取，它将返回false并继续往下执行代码。使用synchronized关键字时，如果线程A视图执行一个同步代码块，而线程B已在执行这个同步代码块，则线程A就会被挂起直到线程B运行完这个同步代码块。使用锁的tryLock()方法，通过返回值将得知是否有其他线程正在使用这个锁保护的代码块。
* Lock接口允许分离读和写操作，允许多个读线程和只有一个写线程
* 相比synchronized关键字，Lock结构具有更好的性能。

**准备工作**

**范例实现**

**工作原理**

在临界区的开始，必须通过lock()方法获取对锁的控制。当线程A访问这个方法时，如果没有其他线程获取对这个锁的控制，lock()方法将让线程A获得锁并且允许它立刻执行临界区代码。否则，如果其他线程B正在执行这个锁保护的临界区代码，lock()方法将让线程A休眠直到线程B执行完临界区的代码。

当线程离开临界区的时候，必须使用unlock()方法来释放它持有的锁，以让其他的线程来访问临界区。如果在离开临界区的时候没有调用unlock()方法，其他线程将永久地等待，从而导致了死锁（Deadlock）情景。如果在临界区是用了try-catch块，不要忘记将unlock()方法放入finally部分。

**更多信息**

Lock接口（和它的实现类ReentrantLock）提供了另一个方法来获取锁，即tryLock()方法，即lock()方法最大的不同是，不仅能够获取锁，而且会立即返回，不会将线程置入休眠。

ReentrantLock类允许使用递归调用。

**参见**

## 2.6 使用读写锁实现同步数据访问 ##

锁机制的最大的改进之一就是ReadWriteLock接口和它的唯一实现类ReentrantReadWriteLock。读操作锁和写操作锁。使用读操作锁时可以允许多个线程同时访问，但是写操作锁时只允许一个线程进行。在一个线程执行写操作时，其他线程不能够执行读操作。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

ReetranReadWriteLock类有两个锁：一种是都操作锁，另一种是写操作锁。读操作锁是通过ReadWriteLock接口的readLock()方法获取的，这个锁实现了Lock接口，所以可以使用lock()，unlock()和tryLock()方法。写操作锁是通过ReadWriteLock接口的writeLock()方法获取的，这个锁同样也实现了Lock接口，所以可以使用lock()、unlock()和tryLock()方法。

**参见**

## 2.7 修改锁的公平性 ##

ReetrantLock和ReentrantReadWriteLock类的构造器都含有一个布尔参数fair，它允许控制着两个类的行为。默认fair值是false，称为非公平模式（Non-Fair Mode）。在非公平模式下，当有许多线程再等待锁（ReentranLock和ReentranReadWriteLock）时，锁将选择它们中的一个来访问临界区，而且选择的是等待事件最长的。

lock()和unlock()，Lock接口的tryLock()方法没有将线程置于休眠，fair属性并不影响这个方法。

**准备工作**

**范例实现**

**工作原理**

所有线程是按顺序创建的，每个线程都执行两个被锁保护的代码块。然后访问时线程并没有按照创建的先后顺序。锁将选择任一线程并让它访问锁保护的代码。JVM没有对线程的执行顺序提供保障。

**更多信息**

读/写锁的构造器也有一个公平策略的参数

**参见**

## 2.8 在锁中使用多条件（Multiple Condition） ##

一个锁可能关联一个或多个条件，这些条件通过Condition接口声明。目的是允许线程获取锁并且查看等待的某一个条件是否满足，如果不满足就挂起直到某个线程唤醒它们。

Condition接口提供了挂起线程和唤起线程的机制。

并发编程中的一个典型问题是生产者-消费者（Producer-Consumer）问题。使用一个数据缓冲区，一个或者多个数据生产者（Producer）将数据保存到缓冲区，一个货哦这多个数据消费者（Consumer）将数据从缓冲区中取走。

**准备工作**

**范例实现**

**工作原理**

与锁绑定的所有条件对象都是通过Lock接口的声明的newCondition()方法创建的。再使用条件的时候，必须获取这个条件绑定的锁，所以带条件的代码必须再调用Lock对象的lock方法和unlock()方法之间。

当线程调用条件的await()方法时，将自动释放这个条件绑定的锁，其他某个线程才可以获取这个锁并且执行相同的操作，或者执行这个锁保护的另一个临界区代码。

**更多信息**

Condition接口还提供了await()方法的其他形式。

await(long time, TimeUnit unit)，直到发生以下的情况之一之前，线程将一直处于休眠状态。

* 其他某个线程中断当前线程。
* 其他某个线程调用了将当前线程挂起的条件的signal()或signalAll()方法。
* 只当的等待时间已经过去。
* 通过TimeUnit类的常量DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES|ANOSECONDS和SECONDS指定的等待时间已经过去。

awaitUnitnterruptibly():它是不可中断你的。这个线程将休眠直到其他某个线程调用了将它挂起的条件的signal()或signalAll()方法。
awaitUnit(Date date):直到发生以下情况之一之前，线程将一直处于休眠状态。

* 其他某个线程中断当前线程
* 其他某个线程调用了将它挂起的条件的signal()或signalAll()方法
* 指定的最后期限到了
* 也可以将条件与读写锁ReadLock和WriteLock一起使用。

**参见**

# 第3章 线程同步辅助类 #

* 资源的并发访问控制
* 资源的多副本的并发访问控制
* 等待多个并发事件的完成
* 在集合点的同步
* 并发阶段任务的运行
* 并发阶段任务中的阶段切换
* 并发任务间的数据交换

## 3.1 简介 ##

* 信号量（Semaphore）
* CoundDownLatch
* CyclicBarrier
* Phaser
* Exchanger

## 3.2 资源的并发访问控制 ##






