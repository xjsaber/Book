# Java 7 并发编程实战手册 #

## 第1章 线程管理 ##

### 1.1 简介 ###

### 1.2 线程的创建和运行 ###

在Java语言中，线程跟其他所有元素一样，都是对象（Object）。Java提供了两种方式来创建线程：

* 继承Thread类，并且覆盖run()方法
* 创建一个实现Runnable接口的类。使用带参数的Thread构造器来构建Thread对象。这个参数就是实现Runnable接口的类的一个对象。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

### 1.3 线程信息的获取和设置 ###

Thread类有一些保存信息的属性，这些属性可以用来标识线程，显示线程的状态和控制线程的优先级。

ID:保存了线程的唯一标识符。
Name：保存了线程名称。
Priority：保存了线程对象的优先级。线程的优先级是从1到10，其中1是最低优先级；10是最高优先级。
Staus：保存了线程的状态。在Java中，线程的状态有6种：new、runnable、blocked、waiting、time waiting或者terminated。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**工作原理**

**更多信息**

### 1.4 线程的中断 ###

所有的非守护线程运行结束时，或者其中一个线程调用了System.exit()方法时，这个Java程序才运行结束。

Java提供了中断机制，使用它来结束一个线程。这种机制要求线程检查它是否被中断了，然后决定是不是响应这个中断请求。

**准备工作**

**范例实现**

**工作原理**

Thread类有一个表明线程被中断与否的属性，它存放的是布尔值。线程的interrupt()方法被调用时，这个属性就会被设置位true。isInterrupted()方法只是返回这个属性的值。

**更多信息**

Thread类的静态方法interrupted()，用来检查当前执行的线程是否被中断。

isInterrupted()和interrupt()方法有一个很大的区别。isInterrupted()不能改变interrupted属性的值，但是后者能设置interrupted属性位false。因为interrupted()是一个静态方法，梗推荐使用isInterrupted()方法。

### 1.5 线程中断的控制 ###

InterruptedException异常。当检查到线程中断的时候，就抛出这个异常，然后在run()种捕获并处理这个异常。

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

### 1.6 线程的休眠和恢复 ###

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

### 1.7 等待线程的终止 ###

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

### 1.8 守护线程的创建和运行 ###

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

### 1.9 线程种不可控异常的处理 ###

* 非运行时异常（CheckedException）
* 运行时异常（Unchecked Exception）

**准备工作**

**范例实现**

**工作原理**

**更多信息**

**参见**

### 1.10 线程局部变量的使用 ###

共享数据是并发程序最核心的问题之一，对于继承了Thread类或者实现了Runnable接口的对象来说尤其重要。

如果创建的对象是实现了Runnable接口的类的实例，用它作为传入参数创建多个线程对象并启动这些线程，那么所有的线程将共享相同的属性。也就是说，如果在一个线程中改变了一个属性，那么所有线程都将会被这个改变影响。

**准备工作**

**范例实现**

**工作原理**

线程局部变量分别为每个线程存储了各自的属性值，并提供给每个线程使用。使用get()方法读取这个值，并用set()方法设置这个值。如果线程是第一次访问线程局部变量，线程局部变量可能还没有为它存储值，这个时候initialValue()方法就会被调用，并且返回当前的时间值。

**更多信息**

**参见**

### 1.11 线程的分组 ###

并发API，能够把线程分组。

Java提供ThreadGroup类标识一组线程。线程组可以包含线程对象，也可以包含其他的线程组对象，它是一个树形结构。

**准备工作**

**范例实现**

**工作原理**

list()方法的输出及每个线程对象的状态。

线程组类存储了线程对象和关联的线程组对象，并可以访问它们的信息（例如状态），将执行的操作应用在所有成员上（例如中断）。

**更多信息**

**参见**

### 1.12 线程组种不可控异常的处理 ###

Java提供了捕获和处理异常的机制，有的异常必须被捕获，或者必须使用方法的throws声明再次抛出，这类异常叫作非运行时异常。还有一类异常叫作运行时异常，它们不需要被捕获或者声明抛出。

**准备工作**

**范例实现**

**工作原理**

当运行范例的时候，当一个线程对象抛出了异常，其余的线程对象都被中断。

当线程抛出非捕获异常时，JVM将会这个异常寻找3中可能的处理器。

1. 寻找抛出这个异常的线程的非捕获异常处理器
2. JVM继续查找这个线程所在的线程组的非捕获异常处理器

**更多信息**

**参见**

### 1.13 使用工厂类创建线程 ###

工厂模式是面向对象编程中最常使用的模式之一。

使用工厂类，可以将对象的创建集中化：

1. 更容易修改类，或者改变创建对象的方式；
2. 更容易为有限资源限制创建对象的数目。
3. 更容易为创建的对象生成统计数据。

**准备工作**

**范例实现**

**工作原理**

ThreadFactory接口只有一个方法，即newThread，它以Runnable接口对象为传入参数并且范佳慧一个线程对象。当实现ThreadFactory接口时，必须实现覆盖这个方法。大多数基本的线程工具类只有一行。
	
	return new Thread(r);

可以通过增加一些边划来强化实现方法覆盖。

* 创建一个个性化线程，如本范例使用一个特殊的格式作为线程名，或者通过继承Thread类来创建自己的线程类；
* 保存新创建的线程统计数据，如本节的范例那样；
* 限制创建的线程的数量；
* 对生成的线程进行验证；
* 更多你可以想到的。

**更多信息**

**参见**



# 第2章 线程同步基础 #

* synchronized实现同步方法
* 使用非依赖属性实现同步
* 在同步代码块中使用条件
* 使用锁实现同步
* 使用读写锁同步数据访问
* 修改锁的公平性
* 在锁中使用多条件

## 2.1 简介 ##

* synchronized关键字机制
* Lock接口及其实现机制

## 2.2 使用synchronized实现同步方法 ##

**准备工作**

**范例实现**

**工作原理**

synchronized关键字的使用，保证了在并发程序中对共享数据的正确访问。

**更多信息**

synchronized关键字会降低应用程序的性能。

可以递归调用被synchronized声明的方法。当线程访问一个对象的同步方法时，还可以调用这个对象的其他的同步方法，也包含正在执行的方法，而不必再次去获取这个方法的访问权。

this关键字来引用正在执行的方法所属的对象

	synchronized(this) {
		// Java code
	}

## 2.3 使用非依赖属性实现同步 ##

**准备工作**

**范例实现**

**工作原理**

用synchronized关键字保护代码块时，使用对象作为它的传入参数。JVM保证同一时间只有一个线程能够访问这个对象的代码保护块。

**更多信息**

**参见**

## 2.4 在同步代码中使用条件 ##





