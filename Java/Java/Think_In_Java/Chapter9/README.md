# 第9章 接口 #

再面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。

多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要添加新功能都可以“生长”的程序。

“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。

多态的作用则是消除类型之间的耦合关系。多态方法调用允许一种类型表现出来与其他相似类型之间的区别，只要它们都是从同一基类导出而来的。

这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。

## 8.1 再论向上转型 ##

对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。

视为对其基类型的引用的做法被称作向上转型——因为在继承树的画法中，基类是放置在上方的。

### 8.1.1 忘记对象类型 ###

Music.java

## 8.2 转机 ##


使用注解的过程中，很重要的一个部分就是创建与使用 *注解处理器*。

容器类。

容器，就是存放要使用的对象的地方。数组也是如此，不过与简单的数组相比，容器类更加灵活，具备更多不同的功能。

Java泛型的核心概念：告诉编辑器想使用什么类型，告诉编译器帮你处理一切细节。

### 8.2.1 方法调用绑定  ###

将一个方法调用同一个方法主体关联起来被称作*绑定*。若在程序执行前进行绑定（如果有的话，由编辑器和连接程序实现），叫作*前期绑定*。

解决的办法就是*后期绑定*，它的含义就是在运行时根据对象的类型进行绑定。后期绑定也叫做*动态绑定或运行时绑定*。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时判断对象的类型，从而调用恰当的方法。（编辑器一直不知道对象的类型，但是方法调用机制能够找到正确的方法体，并加以调用。）

Java中除了static方法和finnal方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。

为什么要将某个方法声明为final？可以防止其他人覆盖该方法。但更重要的一点或许是：这样做可以有效地“关闭”动态绑定，或者说，告诉编辑器不需要对其进行动态绑定。编辑器就可以final方法调用生成更有效的代码。然后，大多数情况下，这样做对程序的整体性能不会由改观。所以，最好根据设计来决定是否使用final，而不是出于试图提高性能的目的来使用final。

### 8.2.2 产生正确的行为 ###

末端哨兵（end sentinel）来判断堆栈何时为空。

### 8.2.3 可扩展性 ###

### 8.2.4 缺陷：“覆盖”私有方法 ###

只有非private方法才可以被覆盖，但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切地说，在导出类中，对于基类的private方法，最好采用不同的名字。

### 8.2.5 缺陷：域与静态方法 ###

只有普通的方法调用可以是多态的。

## 8.3 构造器和多态 ##

### 8.3.1 构造器的调用顺序 ###

1. 调用基类构造器。
2. 按声明顺序调用成员的初始化方法。
3. 调用导出类构造器的主体。

构造器的调用顺序是很重要的。当进行继承时，我们已经知道基类的一切，并且可以访问基类中任何声明为public和protected的成员。这意味着在导出类中，必须假定基类的所有成员都是有效的。

一种标准方法是，构造动作一经发生，那么对象所有部分的全体成员都会得到构建。

### 8.3.2 继承与清理 ###

通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理。如果确实遇到清理的问题，那么必须用心为新类创建dispose()方法。

万一某个子对象要依赖于其他对象，销毁的顺序应该和初始化顺序相反。对于字段，则意味着与声明的顺序相反（因为字段的初始化是按照声明的顺序进行的）。

### 8.3.3 构造器内部的多态方法的行为 ###

在一般的方法内部，动态绑定的调用是在运行时才决定的，因为对象无法知道它是属于方法所在的那个类，晒是属于那个类的导出类。

如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。然而，这个调用的效果可能相当难于预料，因为被覆盖的方法在对象被完全构造之前就会被调用。

从概念上讲，构造器的工作实际上是创建对象。在任何构造器内部，整个对象可能只是部分形成——只知道基类对象已经进行初始化。然后，一个动态绑定的方法调用却会向外深入到继承层次结构内部。如果我们是在构造器内部这样做，那么就可能会调用某个方法。

## 8.4 协变返回类型 ##

协变返回类型，它表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。较早的版本将强制process()的覆盖版本必须返回Grain，而不能返回Wheat，尽管Wheat是从Grain导出，因而也应该是一种合法的返回类型。协变返回类型允许返回更具体的Wheat类型。

### 8.5 匿名内部类 ###

当我们使用现成的类来建立新类时，如果首先考虑使用继承技术，反倒会加重我们的设计负担，使事情变得不必要地复杂起来。

更好的方式是首先选择“组合”，尤其是不能十分确定应该使用哪一种方式时。组合不会强制我们的程序设计进入继承的层次结构中。而且，组合更加灵活，因为它可以动态选择类型；相反，继承在编译时就需要知道确切类型。

State对象包含一个对Actor的引用，而Actor被初始化为HappyActor对象。着意味着performPlay()会产生某种特殊行为。既然引用在运行时可以与另一个不同的对象重新绑定起来，所以SadActor对象的引用可以在actor被替换，然后由performPlay()产生的行为也随之改变。

### 8.5.1 纯继承与扩展 ###

基类可以接收发送给导出类的任何消息，因为二者由着完全相同的接口。

### 8.5.2 向下转型与运行时类型识别 ###

向上转型（在继承层次中向上移动）会丢失具体的类型信息，通过向下转型——也就是在继承层次中向下移动——应该能够获取类型信息。

MoreUseful接口扩展了Useful接口；但是由于它是继承而来的，所以它也可以向上转型到Useful类型。如果我们视图调用u()方法（它只存在于MoreUseful），就会返回一条编译时出错消息。

如果想访问MoreUsefu对象的扩展接口，就可以尝试进行向下转型。如果所转型类型是正确的类型，那么转型成功；否则，就会返回一个ClassCastException异常。

## 8.6 总结 ##

多态意味着“不同的形式”。在面向对象的程序设计中，持有从基类继承而来的相同接口，以及使用该接口的不同形式：不同版本的动态绑定方法。

