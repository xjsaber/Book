# 第5章 初始化与清理 #

随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。

初始化和清理（cleanup）正是涉及安全的两个问题。

C++引入了构造器（construct）的概念，这是一个在创建对象时被自动调用的特殊方法。Java中也采用了构造器，并额外提供了“垃圾回收器”。

## 5.1 用构造器确保初始化 ##

initialize()

## 5.2 方法重载 ##

### 5.2.1 区分重载方法 ###

参数顺序的不同也足以区分两个方法，但一般会使代码难以维护。

### 5.2.2 涉及基本类型的重载 ###

基本类型能从一个“较小”的类型自动提升至一个“较大”的类型。

### 5.2.3 以返回值区分重载方法 ###

## 5.3 默认构造器 ##

## 5.4 this关键字 ##

	Banana a = new Banana(),
		   b = new Banana();
	a.peel(1);
	b.peel(2);
等于
	Banana.peel(a, 1);
	Banana.peel(b, 2);
假设希望在方法的内部获得对当前对象的引用。由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：this。this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。

### 5.4.1 在构造器中调用构造器 ###
this调用一个构造器，但却不能调用两个，必须将构造器调用置于最起始处，否则编译器会报错。

this的另一个用法，由于参数s的名称和数据成员s的名字相同，所以会产生歧义，使用this.s来代表数据成员解决问题。

### 5.4.2 static的含义 ###

static方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来可以。可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。

## 5.5 清理：终结处理和垃圾回收 ##

一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

1. 对象可能不被垃圾回收
2. 垃圾回收并不等于“析构”


### 5.5.1 finalize()的用途何在 ###

3. 垃圾回收只与内存有关

使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们也必须同内存及其回收有关。

### 5.5.2 你必须实施清理 ###

垃圾回收器的存在并不能完全代替析构函数。无论是“垃圾回收”还是“终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

### 5.5.3 终结条件 ###

System.gc()用于强制进行终结动作

### 5.5.4 垃圾回收器如何工作 ###

Java虚拟机将采用一种自适应的垃圾回收技术。

1. 停止——复制（stop-and-copy）。显然这意味着，先暂停程序的运行（所以它不属于后台回收模式）然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列，然后就可以按前述方法简单、直接地分配新控件了。
2. 当把对象从一处搬到另一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想象成有个表格，将旧地址映射至新地址）。

缺点
 
1. 效率低，两个堆来回倒腾，比实际需要多一倍的空间。
2. 程序进入稳定状态后，会产生少量垃圾甚至没有垃圾。而复制式回收站仍然会将所有内存自一处复制到另一处。

为了避免这种情形，一些Java虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种工作模式（即“自适应”）。这种模式称为标记——清扫（mark-and-sweep）。对于一般用途而言，“标记-清扫”方式速度相当慢，但是只会产生少量垃圾甚至不会产生垃圾时，它的速度就很快了。

“标记-清扫”所依据的思路同样是从堆栈和静态存储区触发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活丢向，就会给对象设一个标记，这个过程中不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。

“停止-复制”的意思是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会被暂停。当可用内存数量较低时，Sun版本的垃圾回收器会暂停运行程序，同样，“标记——清扫”工作也必须在程序暂停的情况下才能进行。

Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大，它会占用单独的块。严格来说，“停止——复制”要求在释放旧有对象之前，必须先把所有存活对象从旧堆复制到新堆，这将导致大量内存复制行为。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝对象了。每个块都由相应的代数（generation count）来记录它是否还存活。通常，如果块在某处被引用，某代数会增加；垃圾回收器将对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会被复制（只是其代数会增加），内含小型对象的那些快则被复制并整理。Java虚拟机会进行检视，如果所有对象很稳定，垃圾回收器的效率降低的话，就会切换到“标记-清扫”方式；同样，Java虚拟机会跟踪“标记-清扫”的效果，要是堆空间出现很多碎片，就会切换回“停止——复制”方式。这就事“自适应”技术，即“自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。

Java虚拟机中由许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为“即时”（Just-In-Time, JIT）编译器的技术。可以把程序全部或部分翻译成本地机器码，程序运行速度因此得以提升。当需要转载某个类（通常是在为该类创建第一个对象）时，编译器会先找到其.class文件，然后将该类的字节码装入内存。此时由两种方案可供选择。

1. 让即时编译器编译所有代码。 但这种方式会有两个缺陷：这种加载动作散落在整个程序声明周期内，累加起来要话很多时间；而且会增加可执行代码的长度（字节码比即时编译器展开后的本地机器码小很多），这将导致页面调度，从而降低程序速度。
2. 惰性评估（lazy evaluation），意思是即时编译器只在必要的时候才编译代码

## 5.6 成员初始化 ##




