# 第15章 泛型 #

一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。

泛型实现了参数化类型的概念

## 15.1 与C++的比较 ##

File(文件)类既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果它指的是一个文件集，可以对此集合调用list()方法，会返回一个字符数组。

如果我们想取得不同的目录列表，只需要再创建一个不同的File对象就可以了，实际上可以使用FilePath(文件路径)，还包括了与它相关的FilenameFilter接口。

## 15.2  ##

使用注解的过程中，很重要的一个部分就是创建与使用 *注解处理器*。

容器类。

容器，就是存放要使用的对象的地方。数组也是如此，不过与简单的数组相比，容器类更加灵活，具备更多不同的功能。

Java泛型的核心概念：告诉编辑器想使用什么类型，告诉编译器帮你处理一切细节。

### 15.2.1 一个元祖类库  ###

元祖（tuple），将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。

### 15.2.2 一个堆栈类 ###

末端哨兵（end sentinel）来判断堆栈何时为空。

### 15.2.3 RandomList ###

## 15.3 泛型接口 ##

泛型也可以应用于接口。工厂方法设计模式的一种应用。

工厂方法设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要需要参数。

## 15.4 泛型方法 ##

GenericMethods并不是参数化的，尽管这个类和其内部的方法可以被同时参数化，但是在这个例子中，只有方法f()同游

### 15.4.1 杠杆利用类型参数推断 ###

### 15.4.2 可变参数与泛型方法 ###

### 15.4.3 用于Generator的泛型方法 ###

Collection

### 15.4.4 一个通用的Generator ###

可以为任何类构造一个Generator，只要该类具有默认的构造器。为了减少类型声明，提供了一个泛型方法，用以生成BasicGenerator。

### 15.4.5 简化元祖的使用 ###

有了类型参数推断，再加上static方法，可以重新编写之前看到的元祖工具，使其成为更通用的工具类哭。

### 15.4.6 一个Set实用工具 ###

泛型方法的另一个示例。

HastSet：union，intersection()，difference()，complement()

### 15.5 匿名内部类 ###

泛型还可以应用于内部类以及匿名内部类

### 20.2.1 注解元素 ###

标签@UseCase由UseCase.java定义，其中包含int元素id，以及一个String元素description

* 所有基本类型（int， float， boolean等）
* String
* Class
* enum
* Annotation
* 以上类型的数组

### 20.2.2 默认值限制 ###

1. 元素不能由不确定的值
2. 元素必须要么具有默认值，要么在使用注解时提供元素的值。

对于非基本类型的元素，在源代码中声明时，或是在注解接口中定义默认值时，都不能以null作为其值。

### 20.2.3 生成外部文件 ###

Web Service、自定义标签库以及对象/关系映射工具，一般需要XML描述文件，而这些描述文件脱离于源代码之外。

假设希望提供一些基本的对象/关系映射功能，能够自动生成数据库表，用以存储JavaBean对象。可以选择使用XML描述文件，指明类的名字、每个成员以及数据库映射的相关信息。然而，如果使用注解的话，可以将搜娱哦的信息保存在JavaBean源文件中。

### 20.2.4 注解不支持继承 ###

不能使用关键字extends来继承某个@interface。

### 20.2.5 实现处理器 ###


## 20.3 使用apt处理注解 ##