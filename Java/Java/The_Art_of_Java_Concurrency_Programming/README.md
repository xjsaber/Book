# Java 并发编程的艺术 #

## 第1章 并发编程的挑战 ##

### 1.1 上下文切换 ###

#### 1.1.1 多线程一定快吗 ####

#### 1.1.2 测试上下文切换次数和时长 ####

#### 1.1.3 如何减少上下文切换 ####

减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。

无锁并发编程。

CAS算法。

使用最小线程。

协程：

#### 1.1.4 减少上下文切换实战 ####

jstack命令dump线程信息

### 1.2 死锁 ###

### 1.3 资源限制的挑战 ###

### 1.4 本章小结 ###

## 第2章 Java并发机制的底层实现原理 ##

Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节 码，最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于JVM的实现和 CPU的指令。

### 2.1 volatile的应用 ###

volatile是轻量级的synchronized，它在多处理开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不回引起线程的上下文的切换和调度。

**1. volatile的定义和实现原理 **

1）将当前处理器缓存行的数据写回到系统内存。
2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

|术语|英文单词|术语描述|
|--|--|--|
|内存屏障|memory barriers|是一组处理器指令，用于实现队内存操作的顺序限制|
|缓存行|cache line|缓存中可以分配的最小存储单位。处理器|
|原子操作|atomic operations|是一组处理器指令，用于实现队内存操作的顺序限制|
|缓存行填充|cache line fill|是一组处理器指令，用于实现队内存操作的顺序限制|
|缓存命中|cache bit|是一组处理器指令，用于实现队内存操作的顺序限制|
|写命中|write hit|是一组处理器指令，用于实现队内存操作的顺序限制|

1）Lock前缀指令会引起处理器缓存回写到内存。
2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。

**2. volatilede使用优化**

LinkedTransferQueue，在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。

### 2.2 synchronized的实现原理与应用 ###

Java的每一个对象都可以作为锁。

1. 对于普通同步方法，锁是当前实例对象。
2. 对于静态同步方法，锁是当前类的Class对象。
3. 对于同步方法块，锁是Synchonized括号里配置的对象。

当一个线程试图访问同步代码块时，首先得到锁，退出或抛出异常必须释放锁。



#### 2.2.1 Java对象头 ####

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。

## 第3章 Java内存模型 ##

Java内存模型的基础，主要介绍内存模型相 关的基本概念；Java内存模型中的顺序一致性，主要介绍重排序与顺序一致性内存模型；同步 原语，主要介绍3个同步原语（synchronized、volatile和final）的内存语义及重排序规则在处理器中的实现。

### 3.1 Java内存模型的基础 ###

#### 3.1.1 并发编程模型的两个关键问题 ####

在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步

通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。

在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。

Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。

#### 3.1.2 Java内存模型的抽象结构 ####




