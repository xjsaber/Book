# Java NIO 系列教程 #

[http://tutorials.jenkov.com/java-nio/index.html](http://tutorials.jenkov.com/java-nio/index.html)

[http://ifeve.com/java-nio-all/](http://ifeve.com/java-nio-all/)

# 第一章 简介 #

## 1.1 I/O与CPU时间的比较 ##

## 1.2 CPU已不再是束缚 ##

JVM的I/O类喜欢操作小块数据——单个字节、几行文本。操作洗脱功能送来整缓冲区的数据，java.io的流数据类再发大量时间把它们拆成小块，往往拷贝一个小块都要往返于几层对象。（操作系统喜欢整卡车地运来数据，java.io类则喜欢一铲子一铲子地加工数据。有了NIO，就可以轻松地把一卡车数据备份到您）

## 1.3 进入正题 ##

java.nio 软件包提供了新的抽象。具体地说，就是 Channel 和 Selector类。

## 1.4 I/O概念 ##

* 缓冲区操作
* 内核控件与用户空间
* 虚拟内存
* 分页技术
* 面向文件的I/O和流I/O
* 多工I/O(就绪性选择)

### 1.4.1 缓冲区操作 ###

缓冲区，是所有 I/O 的基础。所谓“输入／输出”讲的无非就是把数据移进或移出缓冲区。

进程执行I/O操作，向操作系统发起请求，让它要么把缓冲区里的数据排干（写），要么用数据把缓冲区填满（读）。

当进程请求I/O操作的时候，执行一个系统调用将控制权移交给内核。C/C++程序员所熟知的底层函数open()、read()、write()和close()要做的就是建立和执行适当的系统调用。

当内核以这种方式被调用，它随即采取任何必要步骤，找到进程所需数据，并把数据传送到用户空间内的指定缓冲区。内核试图对数据进行高速缓存或预读取，因此进程所需数据可能已经在内核空间里了。如果是这样，该数据只需简单地拷贝出来即可。如果数据不在内核空间，则进程被挂起，内核着手把数据读进内存。

#### 1.4.1.1 发散/汇聚 ####

进程只需一个系统调用，就能把一连串缓冲区地址传递给操作系统。然后，内核就可以顺序填充或排干多个缓冲区，读的时候就把数据发散到多个用户空间缓冲区，写的时候再从多个缓冲区把数据汇聚起来。

### 1.4.2 虚拟内存 ###

所有现代操作系统都使用虚拟内存。虚拟内存意为使用虚假（或虚拟）地址取代物理（硬件RAM）内存地址。

1. 一个以上的虚拟地址可指向同一个物理内存地址。
2. 虚拟内存空间可大于实际可用的硬件内存。

### 1.4.3 内存页面调度 ###

为了支持虚拟内存的第二个特性（寻址空间大于物理内存），就必须进行虚拟内存分页（经常称为交换，虽然真正的交换是在进程层面完成，而非页层面）。

把内存页大小设定为磁盘块大小的倍数。这样内核就可以直接向磁盘控制硬件发布命令，把内存页写入磁盘，在需要时再重新装入。结果，所有磁盘I/O都在页层面完成。对于采用分页技术的现代操作系统而言，这数据在磁盘与物理内存之间往来的唯一方式。

现代CPU包含一个称为内存管理单元（MMU）的子系统，逻辑上位于CPU与物理内存之间。该设备包含虚拟地址向物理内存地址转换时所需映射信息。当CPU引用某内存地址时，MMU负责确定该地址所在页（往往通过对地址值进行移位），并将虚拟页号转换为物理页号（这一步由硬件完成）。如果当前不存在与该虚拟页形成有效映射的物理页面，MMU会向CPU提交一个页错误。

### 1.4.4 文件I/O ###

磁盘把数据存在扇区上，通常一个扇区 512 字节。磁盘属硬件设备，对何谓文件一无所知，它只是提供了一系列数据存取窗口。

文件系统是更高层次的抽象，是安排、解释磁盘（或其他随机存取块设备）数据的一种独特方式。

所有 I/O 都是通过请求页面调度完成的。您应该还记得，页面调度是非常底层的操作，仅发生于磁盘扇区与内存页之间的直接传输。而文件 I/O 则可以任意大小、任意定位。

采用分页技术的操作系统执行 I/O 的全过程可总结为以下几步：

1. 确定请求的数据分布在文件系统的哪些页（磁盘扇区租）。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页可能也不连续。
2. 在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。
3. 在内存页与磁盘上的文件系统页之间建立映射。
4. 为每一个内存页产生页错误。
5. 虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。
6. 一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。

#### 1.4.4.1 内容映射文件 ####

传统的文件 I/O 是通过用户进程发布 read( )和 write( )系统调用来传输数据的。

内存映射I/O使用文件系统建立从用户空间直到可用文件系统页的虚拟内存映射。

1. 用户进程把文件数据当作内存，所以无需发布 read( )或 write( )系统调用。
2. 当用户进程碰触到映射内存空间，页错误会自动产生，从而将文件数据从磁盘读进内存。如果用户修改了映射内存空间，相关页会自动标记为脏，随后刷新到磁盘，文件得到更新。
3. 操作系统的虚拟内存子系统会对页进行智能高速缓存，自动根据系统负载进行内存管理。
4. 数据总是按页对齐的，无需执行缓冲区拷贝。
5. 大型文件使用映射，无需耗费大量内存，即可进行数据拷贝。

虚拟内存和磁盘 I/O 是紧密关联的，从很多方面看来，它们只是同一件事物的两面。在处理大量数据时，尤其要记得这一点。如果数据缓冲区是按页对齐的，且大小是内建页大小的倍数，那么，对大多数操作系统而言，其处理效率会大幅提升。

#### 1.4.4.2 文件锁定 ####

文件锁定机制允许一个进程阻止其他进程存取某文件，或限制其存取方式。通常的用途是控制共享信息的更新方式，或用于事务隔离。在控制多个实体并行访问共同资源方面，文件锁定是必不可少的。数据库等复杂应用严重信赖于文件锁定。

文件锁定有两种方式：共享的和独占的。多个共享锁可同时对同一文件区域发生作用；独占锁则不同，它要求相关区域不能有其他锁定在起作用。

共享锁和独占锁的经典应用，是控制最初用于读取的共享文件的更新。某个进程要读取文件，会先取得该文件或该文件部分区域的共享锁。第二个希望读取相同文件区域的进程也会请求共享锁。

### 1.4.5 流I/O ###

并非所有 I/O 都像的是面向块的，也有流 I/O，其原理模仿了通道。I/O字节流必须顺序存取，常见的例子TTY（控制台）设备、打印机端口和网络连接。

流的传输一般比块设备慢，经常用于间歇性输入。多数操作系统允许把流置于非块模式，这样，进程可以查看流上是否有输入，即便当时没有也不影响它干别的。这样一种能力使得进程可以在有输入的时候进行处理，输入流闲置的时候执行其他功能。

## 1.5 总结 ##

系统层面的 I/O

Avi Silberschatz 所著《操作系统概念》（第六
版）（Operating System Concepts, Sixth Edition [John Wiley & Sons]）

# 第二章 缓存区 #

Buffer java.nio java.nio.channels

一个Buffer对象是固定数量的数据的容器。其作用是一个存储器，或者分段运输区，在这里数据可悲存储并在之后用于检索。缓冲区写满和释放。对于每个非布尔原始数据都一个缓冲区类。尽管缓冲区作用于它们存储的原始数据类型，但缓冲区十分倾向于处理字节。非字节缓冲区可以在后台执行从字节或到字节的转换，这取决于缓冲区是如何创建的。

## 2.1 缓冲区基础 ##

缓冲区是包在一个对象内的基本数据元素数组。Buffer 类相比一个简单数组的优点是它将关于数据的数据内容和信息包含在一个单一的对象中。Buffer 类以及它专有的子类定义了一个用于处理数据缓冲区的 API。

### 2.1.1 属性 ###

* 容量（Capacity）

缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能够被改变。

* 上界（Limit）

缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。

* 位置（Position）

下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。

* 标记（Mark）

一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的( undefined) 。

0 <= mark <= position <= limit <= capacity

### 2.1.2 缓冲区API ###

Buffer类的方法签名

级联调用允许这种类型的代码：

	buffer.mark( );
	buffer.position(5);
	buffer.reset( );

被简写为：

	buffer.mark().position(5).reset( );

java.nio 中的类被特意地设计为支持级联调用

对于 API 还要注意的一点是 isReadOnly()函数。所有的缓冲区都是可读的，但并非所有都可写。每个具体的缓冲区类都通过执行 isReadOnly()来标示其是否允许该缓存区的内容被修改。一些类型的缓冲区类可能未使其数据元素存储在一个数组中。例如MappedByteBuffer 的内容可能实际是一个只读文件。您也可以明确地创建一个只读视图缓冲区，来防止对内容的意外 修改。对只读的缓冲区的修改尝试将会导致ReadOnlyBufferException 抛出。但是我们要提前做好准备。

### 2.1.3 存取 ###

# 第四章 选择器 #

选择器（selectors）。选择器提供选择执行已经就绪的任务的能力，这使得多元I/O成为可能。

## 4.1 选择器基础 ##

### 4.1.1 选择器，可选择通道和选择键类 ###

#### 选择器（Selector） ####

选择棋类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和
选择器一起被注册的，并且使用选择器来更新通道的就绪状态。当这么做的时候，可以选择将被激发的线程挂起，直到有就绪的通道。

#### 可选择通道（SelectableChannel） ####

FileChannel对象不是可选择的，因为它们没有继承SelectableChannel。所有socket通道都是可选择的，包括从管道（Pipe）对象中获得的通道。SelectableChannel可以被注册到Selector对象上，同时可以指定对那个选择器而言。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。

#### 选择键（SelectionKey） ####

选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记。

## 4.2 使用选择键 ##

SelectiionKey

## 4.3 使用选择器 ##

### 4.3.1 选择过程 ###

每一个Selector对象维护三个键的集合：

	public abstract class Selector{
		// This is a 
	}

#### 已注册的键的集合（Registered key set） ####