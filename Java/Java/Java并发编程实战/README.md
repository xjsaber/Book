# Java并发编程实战 #

# 学习攻略|如何才能学好并发编程 #

第一部分：并发理论基础

# 01 | 可见性、原子性和有序性问题：并发编程Bug的源头 #

# 02 | Java内存模型：看Java如何解决可见性和有序性问题 #

# 03 | 互斥锁（上）：解决原子性 #

# 04 | 互斥锁（下）：如何用一把锁保护多个资源 #

# 05 | 一不小心就死锁了，怎么办？ #

# 06 | 用“等待-通知”机制优化循环等待 #

等待-通知机制

### 尽量使用 notifyAll() ###

### 总结 ###

synchronized 配合 wait()、notify...

### 课后思考 ###

wait()方法和sleep()方法

# 07 | 安全性、活跃性以及性能问题 #

### 安全性问题 ###

锁

### 活跃性问题 ###

死锁，活锁和饥饿

### 性能问题 ###

### 总结 ###

* 微观上涉及到原子性问题、可见性问题和有序性问题
* 宏观则表现为安全性、活跃性以及性能问题

### 课后思考 ###


# 08 | 管程：并发编程的万能钥匙 #

### 什么是管程 ###

管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。

管程：指的是管理共享变量以及共享变量的操作过程，让他们支持并发。

### MESA模型 ###

管程的发展史：

1. Hasen模型
2. Hoare模型
3. MESA模型

# 08 | 管程：并发编程的万能钥匙 #

# 09 | Java线程（上）：Java线程的生命周期 #

### 通用的线程生命周期 ###

### Java中线程的生命周期 ###

1. NEW（初始化状态）
2. RUNNABLE（可运行/运行状态）
3. BLOCKED（阻塞状态）
4. WAITING（无时限等待）
5. TIMED_WAITING（有时限等待）
6. TERMINATED（终止状态）

#### 1. RUNNABLE与BLOCKED的状态转换 ####

#### 2. RUNNABLE与WAITING的状态转换 ####

#### 3. RUNNABLE与TIMED_WAITING的状态转换 ####

1. 调用带超时参数的Thread.sleep(long millis)方法；
2. 获得synchronized隐式锁的线程，调用带超时参数的Object.wait(long timeout)方法
3. 调用带超时参数的Thread.join(long millis)方法；
4. 调用带超时参数的LockSupport.parkNanos(Object blocker, long deadline)方法；
5. 调用带超时参数的LockSupport.partUntil(long deadline)方法。

#### 4. 从NEW到RUNNABLE状态 ####

#### 5. 从RUNNABLE到TERMINATED状态 ####

* stop()
* interrupt()

### 总结 ###

### 课后思考 ###

# 10 | Java线程（中）：创建多少线程才是合适的？ #

### 为什么要使用多线程？ ###

延迟和吞吐量

### 多线程的应用场景 ###

### 创建多少线程合适？ ###



### 总结 ###

将硬件的性能发挥到极致

### 课后思考 ###



# 11 | Java线程（下）：为什么局部变量是线程安全的？ #

### 方法是如何被执行 ###

### 局部变量存哪里？ ###

### 调用栈与线程 ###

每个线程都有自己独立的调用栈。

### 线程封闭 ###

### 总结 ###

### 课后思考 ###


# 12 | 如何用面向思想写好并发程序？ #

# 13 | 理论基础模块热点问题答疑 #

### 1. 用锁的最佳实践 ###

### 2. 锁的性能要看场景 ###

### 3. 竞态条件需要格外关注 ###

### 4. 方法调用是先计算参数 ###

### 5. InterruptedException异常处理需小心 ###