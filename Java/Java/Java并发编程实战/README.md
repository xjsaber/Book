# Java并发编程实战 #

# 学习攻略|如何才能学好并发编程 #

第一部分：并发理论基础

# 01 | 可见性、原子性和有序性问题：并发编程Bug的源头 #

# 02 | Java内存模型：看Java如何解决可见性和有序性问题 #

# 03 | 互斥锁（上）：解决原子性 #

# 04 | 互斥锁（下）：如何用一把锁保护多个资源 #

# 05 | 一不小心就死锁了，怎么办？ #

# 06 | 用“等待-通知”机制优化循环等待 #

等待-通知机制

### 尽量使用 notifyAll() ###

### 总结 ###

synchronized 配合 wait()、notify...

### 课后思考 ###

wait()方法和sleep()方法

# 07 | 安全性、活跃性以及性能问题 #

### 安全性问题 ###

锁

### 活跃性问题 ###

死锁，活锁和饥饿

### 性能问题 ###

### 总结 ###

* 微观上涉及到原子性问题、可见性问题和有序性问题
* 宏观则表现为安全性、活跃性以及性能问题

### 课后思考 ###


# 08 | 管程：并发编程的万能钥匙 #

### 什么是管程 ###

管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。

管程：指的是管理共享变量以及共享变量的操作过程，让他们支持并发。

### MESA模型 ###

管程的发展史：

1. Hasen模型
2. Hoare模型
3. MESA模型

# 08 | 管程：并发编程的万能钥匙 #

# 09 | Java线程（上）：Java线程的生命周期 #

### 通用的线程生命周期 ###

### Java中线程的生命周期 ###

1. NEW（初始化状态）
2. RUNNABLE（可运行/运行状态）
3. BLOCKED（阻塞状态）
4. WAITING（无时限等待）
5. TIMED_WAITING（有时限等待）
6. TERMINATED（终止状态）

#### 1. RUNNABLE与BLOCKED的状态转换 ####

#### 2. RUNNABLE与WAITING的状态转换 ####

#### 3. RUNNABLE与TIMED_WAITING的状态转换 ####

1. 调用带超时参数的Thread.sleep(long millis)方法；
2. 获得synchronized隐式锁的线程，调用带超时参数的Object.wait(long timeout)方法
3. 调用带超时参数的Thread.join(long millis)方法；
4. 调用带超时参数的LockSupport.parkNanos(Object blocker, long deadline)方法；
5. 调用带超时参数的LockSupport.partUntil(long deadline)方法。

#### 4. 从NEW到RUNNABLE状态 ####

#### 5. 从RUNNABLE到TERMINATED状态 ####

* stop()
* interrupt()

### 总结 ###

### 课后思考 ###

# 10 | Java线程（中）：创建多少线程才是合适的？ #

### 为什么要使用多线程？ ###

延迟和吞吐量

### 多线程的应用场景 ###

### 创建多少线程合适？ ###



### 总结 ###

将硬件的性能发挥到极致

### 课后思考 ###



# 11 | Java线程（下）：为什么局部变量是线程安全的？ #

### 方法是如何被执行 ###

通过CPU的堆栈寄存器。CPU支持一种栈结构。因为栈和方法调用相关，因此被称为调用栈。

每个方法在调用栈里都有自己的独立空间，称为帧栈。每个栈帧里都有对应方法需要的参数和返回地址。当调用方法时，会创建新的栈帧，并压入调用栈；当方法返回时，对应的栈帧就会被自动弹出。也就是说，栈帧和方法是同生同死的。

Java语言虽然是靠虚拟机解释执行的，但是方法调用也是利用栈结构解决的。

### 局部变量存哪里？ ###

局部变量的作用域是方法内部，也就是说方法执行完，局部变量就没用了，局部变量和方法应该同生共死。调用栈的栈帧就是和方法同生共死的，所以局部变量放到调用栈那儿是相当的合理。

局部变量就是放到调用栈里的。

局部变量和方法同生共死的，一个变量如果想要跨越方法的边界，就必须创建在堆中。

### 调用栈与线程 ###

每个线程都有自己独立的调用栈。

Java方法里面的局部变量是否存在并发问题？一点问题都没有，因为每个线程都有自己的调用栈，局部变量保存在线程各自的调用栈里面，不会共享，所以自然也就没有并发问题。

没有共享，就没有伤害。

### 线程封闭 ###

方法里的局部变量，因此不会和其他线程共享，所以没有并发问题。

线程封闭，仅在单线程内访问数据。

在JDBC规范里并没有要求这个Connection必须是线程安全的。数据库连接池通过线程封闭技术，保证一个Connection一旦被一个线程获取之后，在这个线程关闭Connection之前的这段时间里，不会再分配给其他线程，从而保证了Connection不会有并发问题。

### 总结 ###

研究原理性的东西、通用的东西。

### 课后思考 ###

常听人说，递归调用太深，可能导致栈溢出。

# 12 | 如何用面向思想写好并发程序？ #

在Java语言中，面向对象思想能够让并发编程变得更简单。

封装共享变量、识别共享变量间的约束条件和制定并发访问策略这三方面下手

### 一、封装共享变量 ###

面向对象思想里面有一个很重要的特性是**封装**，封装的通俗解释就是讲属性和实现细节封装在对象内部，外界对象只能通过目标对象提供的公共方法来间接访问这些属性。

利用面向对象思想写并发程序的思想，将共享变量作为对象属性封装在内部，对所有公共方法制定并发访问策略

对于不会发生变化的共享变量，建议使用final关键字来修饰。

### 二、识别共享变量间的约束条件 ###

识别共享变量间的约束条件非常重要。因为这些约束条件，决定并发访问策略。

### 三、制定并发访问策略 ###

1. 避免共享：避免共享的技术主要是利于线程本地存储以及为每个任务分配独立的线程。
2. 不变模式：这个在Java领域应用的很少，但在其他领域却有着广泛的应用，例如Actor模式、CSP模式以及函数式编程的基础都是不变模式。
3. 管程及其他同步工具：Java领域万能的解决方案是管程，但是对于很多特定的场景，使用Java并发包提供的读写锁、并发容器等同步工具会更好。

### 总结 ###

利用面向对象思想编写并发程序

1. 利用面向对象里的封装特性
2. 面对共享变量进行封装，要避免“逸出”，所谓“逸出”就是共享变量逃逸到对象的外面。

### 课后思考 ###

类SafeVM不满足库存下限要小于库存上限这个约束条件，修改让它能够在并发条件下满足库存下限要小于库存上限这个约束条件

### 延伸阅读 ###

# 13 | 理论基础模块热点问题答疑 #

### 1. 用锁的最佳实践 ###

### 2. 锁的性能要看场景 ###

### 3. 竞态条件需要格外关注 ###

### 4. 方法调用是先计算参数 ###

### 5. InterruptedException异常处理需小心 ###