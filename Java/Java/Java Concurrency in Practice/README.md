Java并发编程实践

# 第1章 简介 #

## 1.1 并发简史 ##

资源利用率

公平性

便利性

*线程也被称为轻量级进程。*在大多数现代操作系统中，都是以线程为基本的调度单位，而不是进程。如果没有明确的协同机制，那么线程将彼此独立执行。*由于同一个进程中的所有线程都将共享进程的内存地址空间。*

## 1.2 线程的优势 ##

### 1.2.1 发挥多处理器的强大能力 ###

### 1.2.2 建模的简单性 ###

### 1.2.3 异步事件的简化处理 ###

## 1.3 线程带来的风险 ##

### 1.3.1 安全性问题 ###

在没有充足同步的情况下，多个线程的操作执行顺序是不可预测的。

### 1.3.2 活跃性问题 ###

### 1.3.3 性能问题 ###

## 1.4 线程无处不在 ##

基础知识

# 第2章 线程安全 #

共享的（Shared）和可变的（Mutable）状态

对象的状态是指存储在状态变量（例如实例或静态域）中的数据。

“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

一个对象是否需要是线程安全的，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式。而不是对象要实现的功能。要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。

Java中的主要同步机制是关键字synchronized。

## 2.1 什么是线程安全性 ##

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出的正确的行为，那么就称这个类是线程安全的。

## 2.2 原子性 ##

### 2.2.1 竞态条件 ###

### 2.2.2 示例：延迟初始化中的竞态条件 ###

### 2.2.3 复合操作 ###

## 2.3 加锁机制 ##

当在Servlet种添加一个状态变量时，可以通过线程安全的对象来管理Servlet的状态以维护Servlet的线程安全性。

### 2.3.1 内置锁 ###

### 2.3.2 重入 ###


## 2.4 用锁来保护状态 ##

由于锁能使其保护的代码路径以串行形式来访问，通过锁来构造一些协议以实现对共享状态的独占访问。

对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象不会发生并发访问。在许多线程安全类种都使用了这种模式。

## 2.5 活跃性与性能 ##




# 第3章 对象的共享 #

内存可见性（Memory Visibility）

## 3.1 可见性 ##

只要有数据在多个线程之间的共享，就使用正确的同步。

NoVisibility 代码 

### 3.1.1 失效数据 ###

code

	MutableInteger

	SynchronizedInteger

### 3.1.2 非原子的64位操作 ###

### 3.1.3 加锁与可见性 ###



### 3.1.4 Volatile变量 ###

Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存一起重排序。vilatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

使用volatile变量

* 对变量的写入操作不依赖变量的当前值，或者你能确保只有一个单个线程更新变量的值
* 该变量不会与其他状态变量一起纳入不变性条件中
* 

## 3.2 发布与逸出 ##

**安全的对象构造过程**

封装能够使得对程序的正确性进行分析变得可能，并使得无意种破坏设计约束条件变得更难。

## 3.3 线程封闭 ##

当访问共享的可变数据时，通常需要使用同步。

避免使用同步的方式就是不共线数据（线程封闭）

1. Swing
2. JDBC（Java Database Connectivity）的Connection对象

局部变量和ThreadLocal类

### 3.3.1 Ad-hoc线程封闭 ###

Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。

由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（栈封闭和ThreadLocal类）

### 3.3.2 栈封闭 ###

### 3.3.3 ThreadLocal类 ###

ThreadLocal提供了get与set等访问接口或方法。

ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。

## 3.4 不变性 ##

不可变对象一定是线程安全的

当满足以下条件时，对象才是不可变的：

* 当满足以下条件时，对象才是不可变的
* 对象的所有域都是final类型。
* 对象是正确创建的（在对象的创建期内，this引用没有逸出）。

### 3.4.1 Final域 ###

final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。

### 3.4.2 示例：使用Volatile类型来发布不可变对象 ###



## 3.5 安全发布 ##

### 3.5.1 不正确的发布：正确的对象被破坏 ###

### 3.5.2 不可变对象与初始化安全性 ###

### 3.5.3 安全发布的常用模式 ###

### 3.5.4 事实不可变对象 ###

### 3.5.5 可变对象 ###

对象的发布需求取决于它的可变性：

* 不可变对象可以通过任意机制来发布。
* 事实不可变对象必须通过安全方式来发布。
* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

### 3.5.6 安全地共享对象 ###

在并发程序使用和共享对象时，可以使用一些使用的策略，包括：

* 线程封闭。 线程封闭的对象只能由一个线程拥有。
* 只读共享。
* 线程安全共享。
* 保护对象。

# 第4章 组合对象 #

## 4.1 设计线程安全的类 ##

在设计线程安全类的过程中，需要包含以下三个基本要素：

* 找出构成对象状态的所有变量。
* 找出约束状态变量的不变性条件。
* 建立对象状态的并发访问管理策略。

同步策略（Synchronization Policy）定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性。

### 4.1.1 收集同步需求 ###

### 4.1.2 依赖状态的操作 ###

### 4.1.3 状态的所有权 ###

所有权和封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。

容器类通常表现出一种“所有权分离”的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器种各个对象的状态。Servlet框架种的ServletContext就是其中一例。

ServletContext为Servlet提供了类似于Map形式的对象容器服务，在ServletContext种可以通过名称来注册（setAttribute)或获取（getAttribute）应用程序对象。由Servlet容器实现的ServletContext对象必须是线程安全，因为它肯定会被多个线程同时访问。当调用setAttribute和getAttribute时，Servlet不需要使用同步，但当使用保存在ServletContext种的对象时，则可能需要使用同步，这些对象由应用程序，Servlet容器只是替应用程序保管它们。与所有共享对象一样，必须安全地共享。为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。

## 4.2 实例封闭 ##

### 4.2.1 Java监视器模式 ###

从线程封闭原则及其逻辑推论可以得出Java监视器模式。

Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都是该锁对象，都可以用来保护对象的状态。

[code]()

### 4.2.2 示例：车辆追踪 ###

code

## 4.3 线程安全性的委托 ##

### 4.3.1 示例：基于委托的车辆追踪器 ###

### 4.3.2 独立的状态变量 ###

### 4.3.3 当委托失效时 ###

### 4.3.4 发布底层的状态变量 ###

## 4.5 将同步策略文档化 ##

synchronized、volatile或者任何一个线程安全类都对应于某种同步策略，用于在并发访问时确保数据的完整性。

标注@GuardedBy

**解释含糊的文档**

如果某个类没有明确地声明是线程安全的，那么就不要假设它是线程安全的，从而有效地避免类似SimpleDateFormat的问题。而另一方面，如果不对容器提供对象（例如HttpSession）的线程安全坐某种有问题的假设，也就是不可能开发出一个基于Servlet的应用程序。

# 第5章 基础构建模块 #

## 5.1 同步容器类 ##

### 5.1.1 同步容器类的问题 ###

同步容器类都是线程安全的，但在某种情况下可能需要额外的客户端加锁来保护符合操作。

迭代、跳转以及条件运算。

	for (int i = 0; i < vector.size(); i++){
		doSomething(verctor.get(i));
	}

	synchronized(vector) {
		for (int i = 0; i < vector.size(); i++){
			doSomething(verctor.get(i));
		}
	}

### 5.1.2 迭代器与ConcurrentModificationException ###



### 5.1.3 隐藏迭代器 ###


## 5.2 并发容器 ##

Java5.0提供了多种并发容器类来改进同步容器的性能。同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性。

Queue和BlockingQueue。Queue用来临时保存一组等待处理的元素。

1. ConcurrentLinkedQueue，传统的先进先出队列
2. PriorityQueue（非并发的）优先队列
3. BlockingQueue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列种出现一个可用的元素

### 5.2.1 ###


## 结构化并发应用程序 ##

# 第6章 任务执行 #

# 第7章 取消和关闭 #

## 7.1 任务取消 ##

[code1](code1)

[code2](code2)

一个可取消的任务必须拥有取消策略（Cancellation Policy），在这个策略中将详细地定义取消操作的“How”、“When”以及“What”，即其他代码

### 7.1.1 中断 ###

PrimeGenerator中的取消机制最终会使得搜索素数的任务退出，但在退出过程中需要花费一定的时间。

# 第8章 应用程序池 #

# 第9章 GUI应用程序 #

## 活跃性、性能与测试 ##

# 第10章 避免活跃度危险 #

# 第11章 性能和可伸缩性 #

# 第12章 测试并发程序 #

高级主题

# 第13章 显示锁 #

# 第14章 构建自定义的同步工具 #