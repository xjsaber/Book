Java并发编程实践

# 第1章 简介 #

## 1.1 并发简史 ##

资源利用率

公平性

便利性

*线程也被称为轻量级进程。*在大多数现代操作系统中，都是以线程为基本的调度单位，而不是进程。如果没有明确的协同机制，那么线程将彼此独立执行。*由于同一个进程中的所有线程都将共享进程的内存地址空间。*

## 1.2 线程的优势 ##

### 1.2.1 发挥多处理器的强大能力 ###

### 1.2.2 建模的简单性 ###

### 1.2.3 异步事件的简化处理 ###

## 1.3 线程带来的风险 ##

### 1.3.1 安全性问题 ###

在没有充足同步的情况下，多个线程的操作执行顺序是不可预测的。

### 1.3.2 活跃性问题 ###

### 1.3.3 性能问题 ###

## 1.4 线程无处不在 ##

基础知识

# 第2章 线程安全 #

共享的（Shared）和可变的（Mutable）状态

对象的状态是指存储在状态变量（例如实例或静态域）中的数据。

“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

一个对象是否需要是线程安全的，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式。而不是对象要实现的功能。要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。

Java中的主要同步机制是关键字synchronized。

## 2.1 什么是线程安全性 ##

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出的正确的行为，那么就称这个类是线程安全的。

## 2.2 原子性 ##

### 2.2.1 竞态条件 ###

### 2.2.2 示例：延迟初始化中的竞态条件 ###

### 2.2.3 复合操作 ###

## 2.3 加锁机制 ##

当在Servlet种添加一个状态变量时，可以通过线程安全的对象来管理Servlet的状态以维护Servlet的线程安全性。

### 2.3.1 内置锁 ###

### 2.3.2 重入 ###


## 2.4 用锁来保护状态 ##

由于锁能使其保护的代码路径以串行形式来访问，通过锁来构造一些协议以实现对共享状态的独占访问。

对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象不会发生并发访问。在许多线程安全类种都使用了这种模式。

## 2.5 活跃性与性能 ##




# 第3章 对象的共享 #

内存可见性（Memory Visibility）

## 3.1 可见性 ##

只要有数据在多个线程之间的共享，就使用正确的同步。

NoVisibility 代码 

### 3.1.1 失效数据 ###

code

	MutableInteger

	SynchronizedInteger

### 3.1.2 非原子的64位操作 ###

### 3.1.3 加锁与可见性 ###



### 3.1.4 Volatile变量 ###

Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存一起重排序。vilatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

使用volatile变量

* 对变量的写入操作不依赖变量的当前值，或者你能确保只有一个单个线程更新变量的值
* 该变量不会与其他状态变量一起纳入不变性条件中
* 

## 3.2 发布与逸出 ##

**安全的对象构造过程**

封装能够使得对程序的正确性进行分析变得可能，并使得无意种破坏设计约束条件变得更难。

## 3.3 线程封闭 ##

当访问共享的可变数据时，通常需要使用同步。

避免使用同步的方式就是不共线数据（线程封闭）

1. Swing
2. JDBC（Java Database Connectivity）的Connection对象

局部变量和ThreadLocal类

### 3.3.1 Ad-hoc线程封闭 ###

Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。

由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（栈封闭和ThreadLocal类）

### 3.3.2 栈封闭 ###

### 3.3.3 ThreadLocal类 ###

ThreadLocal提供了get与set等访问接口或方法。

ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。

## 3.4 不变性 ##

不可变对象一定是线程安全的

当满足以下条件时，对象才是不可变的：

* 当满足以下条件时，对象才是不可变的
* 对象的所有域都是final类型。
* 对象是正确创建的（在对象的创建期内，this引用没有逸出）。

### 3.4.1 Final域 ###

final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。

### 3.4.2 示例：使用Volatile类型来发布不可变对象 ###



## 3.5 安全发布 ##

### 3.5.1 不正确的发布：正确的对象被破坏 ###

### 3.5.2 不可变对象与初始化安全性 ###

### 3.5.3 安全发布的常用模式 ###

### 3.5.4 事实不可变对象 ###

### 3.5.5 可变对象 ###

对象的发布需求取决于它的可变性：

* 不可变对象可以通过任意机制来发布。
* 事实不可变对象必须通过安全方式来发布。
* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

### 3.5.6 安全地共享对象 ###

在并发程序使用和共享对象时，可以使用一些使用的策略，包括：

* 线程封闭。 线程封闭的对象只能由一个线程拥有。
* 只读共享。
* 线程安全共享。
* 保护对象。

# 第4章 组合对象 #

## 4.1 设计线程安全的类 ##

在设计线程安全类的过程中，需要包含以下三个基本要素：

* 找出构成对象状态的所有变量。
* 找出约束状态变量的不变性条件。
* 建立对象状态的并发访问管理策略。

同步策略（Synchronization Policy）定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性。

### 4.1.1 收集同步需求 ###

### 4.1.2 依赖状态的操作 ###

### 4.1.3 状态的所有权 ###

所有权和封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。

容器类通常表现出一种“所有权分离”的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器种各个对象的状态。Servlet框架种的ServletContext就是其中一例。

ServletContext为Servlet提供了类似于Map形式的对象容器服务，在ServletContext种可以通过名称来注册（setAttribute)或获取（getAttribute）应用程序对象。由Servlet容器实现的ServletContext对象必须是线程安全，因为它肯定会被多个线程同时访问。当调用setAttribute和getAttribute时，Servlet不需要使用同步，但当使用保存在ServletContext种的对象时，则可能需要使用同步，这些对象由应用程序，Servlet容器只是替应用程序保管它们。与所有共享对象一样，必须安全地共享。为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。

## 4.2 实例封闭 ##

### 4.2.1 Java监视器模式 ###

从线程封闭原则及其逻辑推论可以得出Java监视器模式。

Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都是该锁对象，都可以用来保护对象的状态。

[code]()

### 4.2.2 示例：车辆追踪 ###

code

## 4.3 线程安全性的委托 ##

### 4.3.1 示例：基于委托的车辆追踪器 ###

### 4.3.2 独立的状态变量 ###

### 4.3.3 当委托失效时 ###

### 4.3.4 发布底层的状态变量 ###

## 4.5 将同步策略文档化 ##

synchronized、volatile或者任何一个线程安全类都对应于某种同步策略，用于在并发访问时确保数据的完整性。

标注@GuardedBy

**解释含糊的文档**

如果某个类没有明确地声明是线程安全的，那么就不要假设它是线程安全的，从而有效地避免类似SimpleDateFormat的问题。而另一方面，如果不对容器提供对象（例如HttpSession）的线程安全坐某种有问题的假设，也就是不可能开发出一个基于Servlet的应用程序。

# 第5章 基础构建模块 #

## 5.1 同步容器类 ##

### 5.1.1 同步容器类的问题 ###

同步容器类都是线程安全的，但在某种情况下可能需要额外的客户端加锁来保护符合操作。

迭代、跳转以及条件运算。

	for (int i = 0; i < vector.size(); i++){
		doSomething(verctor.get(i));
	}

	synchronized(vector) {
		for (int i = 0; i < vector.size(); i++){
			doSomething(verctor.get(i));
		}
	}

### 5.1.2 迭代器与ConcurrentModificationException ###

### 5.1.3 隐藏迭代器 ###

## 5.2 并发容器 ##

Java5.0提供了多种并发容器类来改进同步容器的性能。同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性。

Queue和BlockingQueue。Queue用来临时保存一组等待处理的元素。

1. ConcurrentLinkedQueue，传统的先进先出队列
2. PriorityQueue（非并发的）优先队列
3. BlockingQueue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列种出现一个可用的元素

### 5.2.1 ConcurrentHashMap ###

同步容器类在执行每个操作期间都持有一个锁。

ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使用每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁（Lock Striping）。在这种机制中，任意数量的读取线程可以并发地访问Map，执行读取操作的线程和执行写入操作的线程可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map。ConcurrentHashMap带来的结果是，在并发访问环境下将实现更高的吞吐量，而在单线程环境只损失非常小的性能。

ConcurrentHashMap与其他并发容器一起增强了同步容器类：它们提供的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中对容器加锁。ConcurrentHashMap返回的迭代器具有弱一致性（Weakly Consistent），而并非“及时失败”。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但是不保证）在迭代器被构造后将修改操作反映给容器。

在ConcurrentHashMap中没有实现对Map加锁以提供独占访问。在Hashtable和synchronizedMap中，获得Map的锁能防止其他线程访问这个Map。

在Hashtable与synchronizedMap相比，ConcurrentHashMap有着更多的优势以及更少的劣势，因此在大多数情况下，用ConcurrentHashMap来代替同步Map能进一步提高代码的可伸缩性。只有当应用程序需要加锁Map以进行独占访问时，才应该放弃使用ConcurrentHashMap。

### 5.2.2 额外的原子Map操作 ###

	public interface ConcurrentMap<K, V> extends Map<K, V> {
		// 仅当K没有相应的映射值时才插入
		V putIfAbsend(K key, V value);
		// 仅当K被映射到V时才移除
		boolean remove(K key, V value);
		// 仅当K被映射到oldValue时才替换为newValue
		boolean replace(K key, V oldValue, V newValue);
		// 仅当K被映射到某个值才替换为newValue
		V replace(K key, V newValue);
	}

### 5.2.3 CopyOnWriteArrayList ###

CopyOnWriteArrayList用来代替同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。（类似地，CopyOnWriteArraySet的作用是代替同时Set。）

## 5.3 阻塞队列和生产者——消费者模式 ##

阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果队列已经满了，那么put方法将阻塞直到有空间可用；如果队列为空，那么take方法将会阻塞直到有元素可用。队列可以有界的也可以是无界的，无界队列永远都不会充满，因此无界队列上的put方法也永远不会阻塞。

BlockingQueue的多种实现

1. LinkedBlockingQueue（与LinkedList类似）
2. ArrayBlockingQueue（与ArrayList类似）
3. PriorityBlockingQueue是一种比较优先级排序的队列，根据元素的自然顺序来比较元素（如果它们实现了Comparable方法），也可以使用Comparator来比较。
4. SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等着元素加入或移出队列。

### 5.3.1 示例：桌面搜索 ###


### 5.3.2 串行线程封闭 ###


### 5.3.3 双端队列与工作密取 ###

Java6增加了两种容器类型，Deque和BlockingDeque，分别对Queue和BlockingQueue进行了扩展。Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。

## 5.4 阻塞方法与中断方法 ##

线程可能会阻塞或暂停执行，原因有很多种：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep方法中醒来，或是等待另一个线程的计算结果。

当线程阻塞时，它通常被挂起，并处于某种阻塞状态（BLOCKED、WAITING或TIMED_WAITING）。

BlockingQueue的put和take等方法会抛出受检查异常（Checked Exception）InterruptedException，这与类库中其他一些方法的做法相同。

* 传递InterruptedException
* 恢复中断

## 5.5 同步工具类 ##

## 结构化并发应用程序 ##

# 第6章 任务执行 #

# 第7章 取消和关闭 #

## 7.1 任务取消 ##

[code1](code1)

[code2](code2)

一个可取消的任务必须拥有取消策略（Cancellation Policy），在这个策略中将详细地定义取消操作的“How”、“When”以及“What”，即其他代码

### 7.1.1 中断 ###

PrimeGenerator中的取消机制最终会使得搜索素数的任务退出，但在退出过程中需要花费一定的时间。

# 第8章 应用程序池 #

# 第9章 GUI应用程序 #

## 活跃性、性能与测试 ##

# 第10章 避免活跃度危险 #

# 第11章 性能和可伸缩性 #

# 第12章 测试并发程序 #

高级主题

# 第13章 显示锁 #

## 13.1 Lock与ReentrantLock ##

必须在finally中释放Lock，不然相当于启动了一个定时炸弹。当“炸弹爆炸”时，将很难追踪到最初发生错误的位置，因为没有记录应该释放锁的位置和时间。这就事ReentrantLock不能完全替代synchronized的原因：它更加“危险”，因为当程序的执行控制离开呗保护的代码块时，不会自动清除锁。虽然在finally块中释放锁并不困难，但也不能忘记。

### 13.1.1 轮询锁与定时锁 ###



### 13.1.2 可中断的锁获取操作 ###



### 13.1.3 非块结构的加锁 ###


## 13.2 性能考虑因素 ##

## 13.3 公平性 ##

## 13.4 在synchronized和ReentrantLock之间进行选择 ##

## 13.5 读-写锁 ##



* 释放优先 当一个写入操作释放写入锁，并且队列中同时存在读线程和写线程，那么应该有限选择读线程，写线程，还是最先发出请求的线程？
* 读线程插队 如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程是否
* 重入性
* 降级
* 升级

## 小结 ##

与内置锁相比，显式的Lock提供了一些扩展功能，在处理锁的不可用性方面有着更高的灵活性，并且对队列行有着更好的控制。但ReentrantLock不能完全替代synchronized，只有在synchronized无法满足需求时，才应该使用它。

读-写锁允许多个读线程并发地访问被保护的对象，当访问以读取操作为主的数据结构时，它能够提高程序的可伸缩性。

# 第14章 构建自定义的同步工具 #

## 14.6 java.util.concurrent同步器类中的AQS ##

### 14.6.1 ReentrantLock ###

### 14.6.2 Semaphore 与 CountDownLatch ###

CountDownLatch使用AQS的方式与Semaphore很相似：再同步状态中保存的是当前的计数值。countDown方法调用release，从而导致计数值递减，并且当计数值为零时，解除所有等待线程的阻塞。await调用acquire，当计数器为零时，acquire将立即返回，否则将阻塞。

### 14.6.3 FutureTask ###
                        
# 第15章 原子变量与非阻塞同步机制 #      

## 15.1 锁的劣势 ##

                                                                                      