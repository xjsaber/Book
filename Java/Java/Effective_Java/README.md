# Effective Java（第3版） #

## 第1章 引言 ##

更加有效地使用Java编程语言及其基本类库java.lang、java.util和java.io，以及子包java.util.concurrent和java.util.function等。

|特性|条目|发行版本|
|--|--|--|
|Lambda表达式|42-44|Java 8|
|Stream流|45-44|Java 8|
|Optional类|55|Java 8|
|接口的默认方法|21|Java 8|
|try-with-resources|9|Java 7|
|@SafeVarages注解|32|Java 7|
|Module模块化|15|Java 9|

## 第2章 创建和销毁对象 ##

何时以及如何创建对象，何时以及如何避免创建

### 第1条 用静态工厂方法代替构造器 ###

类可以提供一个公有的静态工厂方法（ static factory method ），它只是一个返回类的实例的静态方法。

**1. 静态工厂方法与构造器不同的第一大优势在于，它们有名称***

构造器BigInteger(int, int, Random)返回的BigInteger可能为素数，如果有名为BigInteger.probablePrime的静态工厂方法来表示，显然更为清楚。

**2. 静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。**

**3. 静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。**



* from——类型转换方法，它只有单个参数，返回该类型的一个相对应的实例，例如： `Date d = Date.from(instant);`
* of——聚合方法，
* valueOf
* instance
* create
* getType
* newType
* type——getType和newType的简版

简而言之，静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处。静态工厂经常更合适，因切忌第一反应就是提供公有的构造器，不先考虑静态工厂。

### 第2条：遇到多个构造器参数时考虑使用构造器 ###

### 第3条：用私有构造器或者枚举类型强化Singleton属性 ###

## 第3章 对于所有对象都通用的方法 ##

## 第4章 类和接口 ##

### 第13条 使类和成员的可访问性最小化 ###

* 私有的
* 包级私有的
* 受保护的
* 公有的

### 第14条：在公有类中使用访问方法和非公有域 ###

### 第15条：使可变性最小化 ###

我不可变类真正的唯一的缺点是，对于每个不同的值都需要一个单独的对象。

坚持不要为每个get方法编写一个相应的set方法。

### 第16条：复合优先于继承 ###

### 第17条：要么为继承而设计，并提供文档说明，要么就禁止继承 ###

该类必须有文档说明他可覆盖（overridable）的方法的自用性（self-use）。

### 第18条：接口优于抽象类 ###

抽象类允许包含某些方法的实现，但是接口则不允许。

现有的类可以很容易被更新，以实现新的接口。

### 第19条：接口只用于定义类型 ###

### 第20条：类层次优于标签类 ###

### 第21条：用函数对象表示策略 ###

函数指针（function pointer）、代理（delegate）、lambda表达式（lambda expression），或者支持类似的机制、允许程序把“调用特殊函数的能力”存储起来并传递这能力。

### 第22条：优先考虑静态成员类 ###





## 第5章 泛型 ##

在没有泛型之前，从集合中读取到的每一个对象都必须进行转换。如果有人不小心插入了类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动为你的插入进行转换，并在*编译时*告知是否插入了类型错误的对象。

### 第26条：请不要使用原生态类型 ###

使用原生态类型（没有类型参数的泛型的）是合法的，但是永远不应该这么做。如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势。


### 第27条：消除非受检的警告 ###

### 第28条：列表优于数组 ###

数组与泛型相比，有两个重要的不同点。

1. 数组是协变，Sub为Super的子类型，数组类型Sub[]就是Super[]的子类型。相反，泛型是不可变的（invariant），对于任意两个不同的类型Type1和Type2，List<Type1>既不是List<Type2>的子类型，也不是List<Type2>的超类型。
2. 数组是具体化的，因此数组会在运行时发现所犯的错误；利用列表，则可以在编译时发现错误。

不能将String放

### 第30条：优先考虑泛型方法 ###

静态概念股据方法尤其适合于泛型化。Collections中的所有“算法”方法（例如binarySearch和sort）都泛型化。


第6章 枚举和注解

第7章 方法

# 第9章 通用程序设计 #

## 第58条：for-each循环优先于传统的for循环 ##

for-each循环，通过完全隐藏迭代器或者索引变量。

有三种情况无法使用for-each循环：

* 结构过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的remove方法。（removeIf）
* 转换——如果需要遍历列表或者数组
* 平行迭代

# 第10章 异常 #

## 第69条：只针对异常的情形才使用异常 ##

* 因为异常机制的设计初衷是用于不正常的情形，所以几乎没有JVM实现试图对他们进行优化，使他们与显式的测试一样快速
* 把代码放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定优化。
* 对数组进行便利的标准模式并不会导致冗余的检查。有些现代的JVM实现会将他们优化掉。

异常应该只用于异常的模式下：他们永远不应该用于正常的控制流。

	for(Iterator<Foo> i = collection.iterator(); i.hasNext();) {
		Foo foo = i.next();
		...
	}
	try {
		Iterator<Foo> i = collection.iterator();
		while(true) {
			Foo foo = i.next();
			...
		}
	} catch (NoSuchElementException e) {

	}

## 第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 ##

Java程序设计语言提供了三种可抛出结构（throwable）：受检异常（checked exception）、运行时异常（run-time exception）和错误（error）。

## 第10章 并发 ##

### 第66条：同步访问共享的可变的数据 ###

synchronized

Java语言规范保证读或者写一个变量是原子的（atomic），除非这个变量的类型为long或double。

第11章 序列化