# 深入拆解Java虚拟机 #

开篇词

## 开篇词 | 为什么我们要学习Java虚拟机？ ##

模块一：Java虚拟机基本原理

## 01 | Java代码是怎么运行的？ ##

### 为什么Java要在虚拟机里运行？ ###

Java字节码，因为Java字节码指令的操作码（opcode）被固定为一个字节。

### Java虚拟机具体是怎么样运行Java字节码的？ ###

### Java虚拟机的运行效率究竟是怎么样的？ ###

HotSpot内置了多个即时编译器：C1、C2和Graal。C1又叫做Client编译器，面向的是对启动性能有要求的客户端GUI程序。

C2又叫做Server编译器，面向的是对峰值性能有要求的服务端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。

从Java7开始，HotSpot默认采用分层编译的方式：热点方法首先会被C1编译，而后热点方法中的热点会进一步被C2编译。

HotSpot的即时编译时放在额外的编译线程中进行的。HotSpot会根据CPU的数量设置编译线程的数目，并且按1：2比例配置给C1及C2编译器。

### 总结与实践 ###

为了可移植性,所以Java要在虚拟机中运行——一旦Java代码被编译为Java字节码，便可以在不同平台上的Java虚拟机实现上运行。（虚拟机还提供了一个代码托管的环境，代替我们处理部分冗长而且容易出错的事务）。

Java虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC寄存器、Java方法栈和本地方法栈。Java程序编译而成的class文件，需要先加载至方法区中，方能在Java虚拟机中运行。

HotSpot虚拟机采用的是一种混合执行的策略。（解释执行Java字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上）

HotSpot装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。

## 02 | Java的基本类型 ##

Java，8个基本类型

### Java虚拟机的boolean类型 ###

在Java虚拟机规范中，boolean类型则被映射成int类型。具体来说，“true”被映射为整数1，而“false”被映射为整数0。

### Java的基本类型 ###

|类型|值域|默认值|虚拟机内部符号|
|--|--|--|--|
|boolean|{false,true}|false|Z|
|byte|[-128,127]|0|B|
|short|[-32768,32767]|0|S|
|char|[0,65535]|'\u0000'|C|
|int|[-2^31,2^31-1]|0|I|
|long|{-2^64,2^64-1}|0L|J|
|float|~[3.4E38,3.4E38]|+0.0F|F|
|double|~[1.8E308,1.8E308]|+0.0D|D|

byte、short、int、long、float以及double的值域依次扩大，而且前面的值域被后面的值域所包含。

基本类型中，boolean和char是唯二的无符号类型。在不考虑违反规范的情况下，boolean类型

### Java的基本类型的大小 ###

Java虚拟机每调用一个Java方法，便会创建一个栈帧。

这个栈帧有两个主要部分，分别是局部变量区，以及字节码的操作数栈。

在Java虚拟机规范中，局部变量区等价于一个数组，并且用正整数来索引。除了long、double值需要两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。

### 总结与实践 ###

boolean类型在Java虚拟机中被映射为整数类型。“true”被映射为1，而“false”被映射为0。Java代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。

除long和double外，其他基本类型与引用类型在解释执行在方法栈中占用的大小是一致的，但它们在堆中占用的大小却不同。在将boolean、byte、char以及short的值存入字段或者数组单元时，Java虚拟机会进行掩码操作。在读取时，Java虚拟机则会将其扩展为int类型。

## 03 | Java虚拟机是如何加载Java类的 ##

加载、链接以及初始化

Java将其细分为四种：类、接口、数组类和泛型参数。

### 加载 ###

加载：是指查找字节流，并且据此创建类的过程。根据ch2，对于数组类来说，它并没有对应的字节流，而是由Java虚拟机直接生成的。对于其他类来说，Java虚拟机则需要借助类加载器来完成查找字节流的过程。

启动类加载器，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader）

扩展类加载器的父类是启动类加载器。它负责加载相对次要、但又通用的类

应用类加载器的父类是扩展类加载器。

Java9引入了模块系统，扩展类加载器被改名为平台类加载器（platform class loader）。Java SE

### 链接 ###

链接，是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。分为验证、准备以及解析三个阶段。

准备阶段的目的，则是为被加载类的静态字段分配内存。Java代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。

除了分配内存，部分Java虚拟机还会在此构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。

解析阶段的目的，正是将这些符号引用解析称为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化）

Java虚拟机规范并没有要求在链接过程中完成解析。仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要对这些符号引用的解析。

### 初始化 ###

在Java代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。

如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被Java编译器标记成常量值（ConstantValue），其初始化直接由Java虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并把它命名为<clinit>。

类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行<clinit>方法的过程。Java虚拟机会通过加锁来确保类的<clinit>方法仅被执行一次。

只有当初始化完成之后，类才正式成为可执行的状态。


### 总结与实践 ###


## 04 | JVM是如何执行方法调用的（上） ##

```
void invoke(Object obj, Object...args) {...}
void invoke(String s, Object obj, Object...args) {...}

invoke(null, 1); //调用第二个invoke方法
invoke(null, 1, 2); //调用第二个invoke方法
invoke(null, new Object[]{1}); //只有手动绕开可变长的语法糖，才能调用第一个invoke方法
```

1. 第一个接收一个Object，以及声明为Object...的变长参数；
2. 第二个接收一个String、一个Object，以及声明为Object...的变长参数。

### 重载与重写 ###

在Java程序里，如果同一个类出现多个名字相同，并且参数类型相同的方法，那么它无法通过编译。

重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java编译器会根据锁传入参数

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长的情况情况下选取重载方法；
2. 如果在第1个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
3. 如果在第2个阶段没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果Java编译器在同一阶段中找到了多个适配的方法，

### JVM的静态绑定和动态绑定 ###

Java虚拟机实憋方法的关键在于类名、方法名以及方法描述符（method desciptor）。至于方法描述符，由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么Java虚拟机会在类的验证阶段报错。

Java虚拟机中关于方法重写的绑定同样基于方法描述。如果子类定义了与父类非私有、非静态方法同名的方法，那么只有当两个方法的参数类型以及返回类型一致，Java虚拟机才判定为重写。

## 05 | JVM是如何执行方法调用的（下） ##

设计模式大量使用了虚方法来实现多态。但是虚方法的性能效率并不高。

#### 1. 虚方法调用 ####

Java里所有非私有实例方法调用都会被编译成invokevirtual指令，而接口方法调用都会被编译成invokeinterface指令。这两种指令，均属于Java虚拟机中的虚方法调用。

在绝大数情况下，Java虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法，这个过程称为动态绑定，相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。

在Java虚拟机中，静态绑定包括用于调用静态方法的invokestatic指令，

Java虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。为每个类生成一张放发表，用以快速定位目标方法。

#### 2.方法表 ####

类加载的准备阶段，除了静态字段分配内存之外，还会构造与该类相关联的方法表。

这个数据结构，便是Java虚拟机实现动态绑定的关键所在。下面我将以invokevirtual所使用的虚方法表（virtual method table）为例介绍方法表的用法。invokeinterface所使用的接口方法表（interface method table，itable）。

方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。

方法表满足两个特质：

1. 子类方法表中包含父类方法表中的所有方法；
2. 子类方法在方法表章的索引值，与它所重写的父类方法的索引值相同。


# 模块二：高效编译 #

## 【工具篇】常用工具介绍 ##

### javap：查阅Java字节码 ###

### 3. ASM：Java字节码框架 ###

