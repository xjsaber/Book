# C#并发并发经典实例 #

并行 编程 方面， 推荐 阅读 Parallel Programming with Microsoft .NET（ Microsoft Press）， 英文 原 书 电子 版 可以 从 网上 下载。 可惜 这 本书 的 内容 有点 过时 了。 例如，“ future 模式” 部分 应该 改用 异步 编程，“ 流水线”（ pipeline） 部分 应该 改用 任务 TPL 数据 流。

异步 编程 方面， 推荐 阅读 MSDN， 特别是“ Task- based Asynchronous Pattern” 这篇 文档。

TPL 数据 流 方面， 推荐 阅读 微软 发布 的

网络 上， 响应 式 扩展（ Rx） 程序 库 越来越 流行 了， 并且 它本身 还在 继续 发展。 在我看来， 学习 Rx 最好 的 资料 是 Lee Campbell 写的 Introduction to Rx。

## 第1章 并发编程概述 ##

### 1.1 并发编程简介 ###

**并发**

### 1.2 异步编程简介 ###

async和await。async关键字加在方法声明上，它的主要目的是使方法内的

async关键字加在方法声明上，主要目的使方法内的await关键字生效（为了保持向后兼容，同事引入了这两个关键字）。如果async方法没有返回值，应返回Task<T>；如果async方法有返回值，应返回Task<T>；如果没有返回值，应返回Task。

如果使用了async，最好就一直使用它

知识， 可 参阅 Alex Davies（ O' Reilly） 编写 的 Async in 
C# 5. 0， 这本 书 非常 不错。 另外， 微软 公司 有关 异步 编程 的 在 线 文档 也 很 不错， 建议 你 至少 读 一读“ async overview” 和“ Task- based Asynchronous Pattern( TAP) overview” 这 两 篇。 如果 要 深入 了解， 官方 FAQ 和 博 客上 也有 大量 的 信息。

克利里(Stephen Cleary). C#并发编程经典实例 (图灵程序设计丛书) (p. 6). 人民邮电出版社. Kindle 版本. 

### 1.3 并行编程简介 ###

数据并行（data parallelism）

任务并行（task parallelism）

### 1.4 响应式编程简介 ###

	observable stream

申请了可观察流，就可以收到任意数量的数据项（OnNext），并且流在结束时会发出一个错误（OnError）或一个“流结束”的通知（OnCompleted）

	Introduction to Rx。

### 1.5 数据流简介 ###

TPL数据流通常作为一个简易的管道，数据从管道的一端进入，在管道中穿行，最后从另一端出来。

对处理各种类型的网络（mesh），在网络中定义分叉（fork）、连接（join）、循环（loop）的工作。

### 1.6 多线程编程简介 ###

线程是一个独立的运行单元，每个进程内部有多个线程，每个线程可以各自同时执行指令。每个线程有自己独立的栈，但是与进程内的其他线程共享内存。对某些线程来说，其中有一个线程是特殊的，例如用户界面程序有一个UI线程，控制条程序有一个main线程。

线程是低级别的抽象，线程池是稍微高级一点的抽象，当代码段遵循线程池的规则运行时，线程池就会在需要时创建线程。（并行的数据流的处理队列会根据情况遵循线程池运行。抽下你跟级别更高，正确代码的编写就更容易）

### 1.7 并发编程的集合 ###

并发集合和不可变集合

多个线程可以用安全的方式同时更新并发集合。大多数并发集合使用快照（snapshot），当一个线程在增加或三处数据时，另一个线程也能枚举数据。比起给常规集合加锁以保护数据的方式，采用并发集合的方式要高效得多。

不可变集合则

### 1.8 现代设计 ###

函数式编程的一个原则就是简洁（换言之，就是避免副作用）。

函数式编程的另一个原则是不变性。不变性是指一段数据是不能被修改的。

### 1.9 技术要点总结 ###

## 第2章 异步编程基础 ##

### 2.1 暂停一段时间 ###

指数退避

### 2.2 返回完成的任务 ###

对异步代码做单元测试，以及用简单的生成方法存根（stub）或者模拟对象（mock）来产生异步接口。

可以使用Task.FormResult方法创建并返回一个新的Task<T>对象吗，这个Task对象已经完成，并有指定的指。

### 2.3 报告进度 ###

### 2.4 等待一组任务完成 ###

	Task.WhenAll

Task.WhenAll方法有以IEnumberable类型作为参数的重载，但**建议大家不要使用**。只要异步代码与LINQ结合，显式的“具体化”序列（即对序列求值，创建集合）就会使代码更清晰。

使用Task.WhenAll时，一般**不会**检查所有的异常。通常情况下，只处理第一个错误就足够了，没必要处理全部错误。

### 2.5 等待任意一个任务完成 ###

	Task.WhenAny

使用Task.WhenAny方法。该方法的参数是一批任务，当其中一个任务完成时就会返回。作为返回值的Task对象，就是那个完成的任务。

### 2.6 任务完成时的处理 ###

### 2.7 避免上下文延续 ###

一个async方法在被await调用后，恢复运行时，会在原来的上下文中运行。

### 2.8 处理async Task方法的异常 ###

在async Task方法中引发的异常，存放在返回的Task对象中。只有当Task对象被await调用时，才会引发异常。

当await调用有异常的Task对象时，对象里的第一个异常会重新抛出。若你对重新抛出异常的问题比较熟悉的话，就会担心栈轨迹是否会出错；异常重新抛出时，原始的栈轨迹会被正确的保存。

### 2.9 处理async void方法的异常 ###






