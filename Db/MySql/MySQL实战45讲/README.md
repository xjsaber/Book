# MySQL实战45讲 #

# 开篇词 #

## 开篇词 | 这一次，让我们一起来搞懂MySQL ##

平时使用数据库时高频出现的知识，如事务、索引、锁等内容构成专栏的主线。


点->线->面，形成自己的MySQL知识网络

# 基础篇 #

## 01 | 基础架构：一条SQL查询语句是如何执行的？ ##

mysql> select * from T where ID = 10;

![0d2070e8f84c4801adbfa03bda1f98d9](img/0d2070e8f84c4801adbfa03bda1f98d9.png)

MySQL分为Server层和存储引擎层两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大部分核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

不同的存储引擎共用一个Server层。

### 连接器 ###

1. 先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。`mysql -h$ip -P$port -u$user -p`（连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。）

建立连接的过程通常比较复杂的，所以在使用中要尽量减少建立连接的动作，也尽量使用长连接。但全部使用长连接后，有时候MySQL占用内存涨得特别快，因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。=>内存占用太大，被系统强行杀掉（OOM）=>MySQL异常重启

解决方案：
1. 定期断开长连接。使用一段时间后，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. 如果是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

### 查询缓存 ###

*但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。*

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

8.0以后没有这块功能。

### 分析器 ###

如果没有命中查询缓存

1. MySQL需要对SQL语句做解析
2. 词法分析， `select * from T where ID = 10;` 比如select，识别出来是一个查询语句，把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。
3. 语法分析，语法分析器会根据语法判断，判断是否满足MySQL语法。

### 优化器 ###

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：

	mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;

* 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
* 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

逻辑结果一样，但执行的效率不同，优化器的作用就是决定选择使用哪个方案。

优化器阶段完成后，这个语句的执行方案就确定下来了。

### 执行器 ###

执行器阶段，开始执行语句。

开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：

1. 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

引擎扫描行数跟 rows_examined 并不是完全相同的。

### 小结 ###

如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？
	

## 02 | 日志系统：一条SQL更新语句是如何执行的？ ##

### 重要的日志模块：redo log ###

### 重要的日志模块：binlog ###

### 两阶段提交 ###

### 小结 ###

两个日志，即物理日志redo log和逻辑日志binlog。

## 03 | 事务隔离：为什么你改了我还看不见？ ##

事务就是要保证一组数据库操作，要么全部成功，要么全部失败。

### 隔离性与隔离级别 ###

ACID（Atomicity，Consistency，Isolation，Durability，即原子性、一致性、隔离性和持久性）

当数据库上有多个事务同时执行的时候=>可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题=>有了“隔离级别”的概念，去解决这些问题

#### 隔离级别 ####

隔离级别越高，效率越低=>需要找到平衡点

SQL标准的事务隔离级别：

1. 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。
2. 读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。
3. 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
4. 串行化（serializable）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

![7dea45932a6b722eb069d2264d0066f8](img/7dea45932a6b722eb069d2264d0066f8.png)

根据事务隔离级别的不同，V1、V2、V3返回值也会分别不同。

* 读未提交：V2、V3=2，B的事务还没提交，但做个变更就能被别的事务看到，所以V1也是2
* 读提交：V2、V3=2，事务 B 的更新在提交后才能被 A 看到，所以V1也是1
* 可重复读：事务在执行期间看到的数据前后必须是一致的，所以v1，v2=1，v3=2
* 串行化：则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。v1、v2值是1，v3的值是2

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。

* “读提交”隔离级别：在每个 SQL 语句开始执行的时候创建的
* “可重复读”隔离级别：在事务启动时创建的，整个事务存在期间都用这个视图

“读未提交”隔离级别：直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。

	show variables like 'transaction_isolation'

根据业务场景选择不同的隔离级别

### 事务隔离实现 ###

假设一个值从1被按顺序改成2、3、4，在回滚日志会有如下的记录：

![d9c313809e5ac148fc39feff532f0fee](img/d9c313809e5ac148fc39feff532f0fee.png)

回滚日志删除条件：系统判断，当前没有事务再需要用到这些回滚日志时，回滚日志会被删除。当系统里没有比这个回滚日志更早的 read-view 的时候会被正式清除。

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。（我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。）还有占用锁资源，拖垮整个库的问题。

### 事务的启动方式 ###

MySQL 的事务启动方式有以下几种：

1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。

在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

	select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) > 60

### 小结 ###

1. 介绍了 MySQL 的事务隔离级别的现象和实现
2. 根据实现原理分析了长事务存在的风险
3. 如何用正确的方式避免长事务

我给你留一个问题吧。你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？

## 04 | 深入浅出牵引（上） ##

