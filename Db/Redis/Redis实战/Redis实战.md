# Redis实战 #

## 第1章 初识Redis ##

### 1.1 Redis简介 ###

存储键（key）与5种不同类型的指之间的映射（mapping），可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性来扩展读性能，还可以使用客户端分片来扩展写性能。

#### 1.1.1 Redis与其他数据库和软件的对比 ####

Redis用作主存储（primary storage）和二级存储（secondary storage）时的用户和查询模式

Redis，memcached，MySQL，PostgreSQL，MongoDB

#### 1.1.2 附加特性 ####

Redis拥有两种不同形式的持久化方法，可以用小而紧凑的格式将存储在内存中的数据写入硬盘：第一种持久化方法为时间点转储（point-in-time dump），转储操作既可以在“指定时间段内有指定数量的写操作执行”这一条被满足时执行，又可以通过调用两条转储到硬盘到硬盘（dump-to-disk）命令中的任何一条来执行；第二条持久化方法将所有写入数据库的命令都写入一个只追加（append-only）文件里面，用户可以根据数据的重要车改年度，将只追加写入设置为从不同步（sync）、每秒同步一次或者每写入一个命令就同步一次。

提供故障转移（failover）支持，Redis实现了主从复制特性：执行复制的从服务器会连接上主服务器，接收主服务器发送的整个数据库的初始副本（copy）；之后主服务器执行的写命令，都会被发送给所有连接着的从服务器去执行，从而实时地更新从服务器的数据集。

#### 1.1.3 使用Redis的理由 ####

### 1.2 Redis数据结构简介 ###

STRING（字符串）、LIST（列表）、SET（集合）、HASH（散列）和ZSET（有序集合）

|结构类型|结构存储的值|结构的读写能力|
|--|--|--|
|STRING||
|LIST|一个链表|
|SET|包含字符串的无需收集器|
|HASH|包含键值对的无序散列表|
|ZSET(有序集合)|字符串成员（member）与浮点数分值（score）之间的有序映射|

#### 1.2.1 Redis的字符串（STRING） ####

GET、SET、DEL

#### 1.2.2 Redis中的列表（LIST） ####
linked-list

LPUSH、RPUSH、LPOP、RPOP、LINDEX、LRANGE

#### 1.2.3 Redis的集合（SET） ####

Redis的集合和列表都可以存储多个字符串，列表可以存储多个相同的字符串，而集合则通过使用散列表来保证自己存储的每个字符串都是各不相同的。

集合使用无序（unordered）方式存储元素。

SADD、SMEMBERS、SISMEMBER、SREM

#### 1.2.4 Redis的散列（HASH） ####

Redis的散列可以存储多个键值对之间的映射，散列存储的值既可以是字符串又可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作。散列在很多方法就像是一个微缩版的Redis，不少字符串命令都有相应的散列版本。

HSET、HGET、HGETALL、HDEL

#### 1.2.5 Redis的有序集合（ZSET有序集合） ####

有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同的；而有序集合的值则被称为分值（score），分值必须为浮点数。

有序集合是Redis里面唯一一个既可以根据成员访问元素，又可以根据分值以及分值的排列顺序来访问元素的结构。

	# 获取有序集合包含的所有元素时，多个元素会按照分值大小进行排序
	zrange zset-key 0 -1 withscores
	# 用户根据分值来获取有序集合中的一部分元素
	zrangebyscore zset-key 0 800 withscores

|命令|行为|
|--|--|
|ZADD|将一个带有给定分值的成员添加到有序集合里面|
|ZRANGE|根据元素在有序排列中所处的位置，从有序集合里面获取多个元素|
|ZRANGEBYSCORE|获取有序集合在给定分值范围内的所有元素|
|ZREM|如果给定成员存在于有序集合，那么移除这个成员|

### 1.3 你好 Redis ###

StackOverflow

#### 1.3.1 对文章进行投票 ####



## 第2章 使用Redis构建Web应用 ##

一个Web服务器对请求进行响应：

1. 服务器对客户端发来的请求（request）进行解析。
2. 请求被转发给预定义的处理器（handler）。
3. 处理器可能会从数据库中取出数据。
4. 处理器根据据取出的数据对模板（template）进行渲染（render）。
5. 处理器向客户端返回渲染后的内容作为对请求的响应（reponse）。

### 2.1 登录和cookie缓存 ###

思路：

1. 将使用一个散列来存储登录cookie令牌与已登录用户之间的映射。要检查一个用户是否已经登录。
2. 用户每次浏览页面的时候，程序员都会对用户存储在登录散列里面的信息进行更新，并将用户的令牌和当前时间撮添加到记录最近登录用户的有序集合里面；如果用户正在浏览的是一个商品页面，那么程序还会将这个商品添加到记录这个用户最近浏览过的商品的有序集合里面，并在被记录商品的数量超过25个时，对这个有序集合进行修剪。

### 2.2 使用Redis实现购物车 ###

每个用户的购物车都是一个散列，这个散列存储了商品ID与商品订购数量之间的映射。对商品数量进行验证的工作由Web应用程序负责，在商品发生变化时，对购物车进行更新。

### 2.3 网页缓存 ###



### 2.4 数据行缓存 ###

编写一个持续运行的守护进程函数，让这个函数将指定的数据行缓存到Redis里面，并不定期地对这些缓存进行更新。

程序是用了两个有序集合来记录应该在何时对缓存进行更新：第一个有序集合为调度（schedule）有序集合，它的成员为数据行的行ID，而分支则是一个时间戳；第二个有序集合为延时（delay）有序集合，它的成员也是数据行的行ID，而分值则记录了指定数据行的缓存需要每隔多少秒更新一次。

使用JSON而不是其他格式，嵌套多个结构。

为了让缓存函数定期地缓存数据行，首先需要将行IDhe给定的延迟值添加到延迟有序集合里面，然后再将行ID和当前时间的时间戳添加到调度有序集合里面。

### 2.5 网页分析 ###


### 2.6 小结 ###
降低数据库负载和Web服务器负载的方法

## 附录 ##

python redis客户度

	import redis
	
	conn = redis.Redis()
	print(conn.set("hello", "world"))
	print(conn.get("hello"))
