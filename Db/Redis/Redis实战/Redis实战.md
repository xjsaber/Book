# Redis实战 #

## 第1章 初识Redis ##

### 1.1 Redis简介 ###

存储键（key）与5种不同类型的指之间的映射（mapping），可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性来扩展读性能，还可以使用客户端分片来扩展写性能。

#### 1.1.1 Redis与其他数据库和软件的对比 ####

Redis用作主存储（primary storage）和二级存储（secondary storage）时的用户和查询模式

Redis，memcached，MySQL，PostgreSQL，MongoDB

#### 1.1.2 附加特性 ####

Redis拥有两种不同形式的持久化方法，可以用小而紧凑的格式将存储在内存中的数据写入硬盘：第一种持久化方法为时间点转储（point-in-time dump），转储操作既可以在“指定时间段内有指定数量的写操作执行”这一条被满足时执行，又可以通过调用两条转储到硬盘到硬盘（dump-to-disk）命令中的任何一条来执行；第二条持久化方法将所有写入数据库的命令都写入一个只追加（append-only）文件里面，用户可以根据数据的重要车改年度，将只追加写入设置为从不同步（sync）、每秒同步一次或者每写入一个命令就同步一次。

提供故障转移（failover）支持，Redis实现了主从复制特性：执行复制的从服务器会连接上主服务器，接收主服务器发送的整个数据库的初始副本（copy）；之后主服务器执行的写命令，都会被发送给所有连接着的从服务器去执行，从而实时地更新从服务器的数据集。

#### 1.1.3 使用Redis的理由 ####

### 1.2 Redis数据结构简介 ###

STRING（字符串）、LIST（列表）、SET（集合）、HASH（散列）和ZSET（有序集合）

|结构类型|结构存储的值|结构的读写能力|
|--|--|--|
|STRING||
|LIST|一个链表|
|SET|包含字符串的无需收集器|
|HASH|包含键值对的无序散列表|
|ZSET(有序集合)|字符串成员（member）与浮点数分值（score）之间的有序映射|

#### 1.2.1 Redis的字符串（STRING） ####

GET、SET、DEL

#### 1.2.2 Redis中的列表（LIST） ####
linked-list

LPUSH、RPUSH、LPOP、RPOP、LINDEX、LRANGE

#### 1.2.3 Redis的集合（SET） ####

Redis的集合和列表都可以存储多个字符串，列表可以存储多个相同的字符串，而集合则通过使用散列表来保证自己存储的每个字符串都是各不相同的。

集合使用无序（unordered）方式存储元素。

SADD、SMEMBERS、SISMEMBER、SREM

#### 1.2.4 Redis的散列（HASH） ####

Redis的散列可以存储多个键值对之间的映射，散列存储的值既可以是字符串又可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作。散列在很多方法就像是一个微缩版的Redis，不少字符串命令都有相应的散列版本。

HSET、HGET、HGETALL、HDEL

#### 1.2.5 Redis的有序集合（ZSET有序集合） ####

有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同的；而有序集合的值则被称为分值（score），分值必须为浮点数。

有序集合是Redis里面唯一一个既可以根据成员访问元素，又可以根据分值以及分值的排列顺序来访问元素的结构。

	# 获取有序集合包含的所有元素时，多个元素会按照分值大小进行排序
	zrange zset-key 0 -1 withscores
	# 用户根据分值来获取有序集合中的一部分元素
	zrangebyscore zset-key 0 800 withscores

|命令|行为|
|--|--|
|ZADD|将一个带有给定分值的成员添加到有序集合里面|
|ZRANGE|根据元素在有序排列中所处的位置，从有序集合里面获取多个元素|
|ZRANGEBYSCORE|获取有序集合在给定分值范围内的所有元素|
|ZREM|如果给定成员存在于有序集合，那么移除这个成员|

### 1.3 你好 Redis ###

StackOverflow

#### 1.3.1 对文章进行投票 ####

文章投票 article_vote() 

#### 1.3.2 发布并获取文章 ####

发布文章post_article()函数

获得文章get_articles()函数

#### 1.3.3 对文章进行分组 ####

对文章进行分组 add_remove_groups()函数

### 1.4 需求帮助 ###

### 1.5 小结 ###

Redis是一个可以用来解决问题的工具，它即拥有其他数据库不具备的数据结构，又拥有内存存储（使得redis的速度非常快）、远程（使得Redis可以与多个客户端和服务器进行连接）、持久化（使得服务器可以在重启之后仍然保持重启之前的数据）和可扩展性（通过主从复制和分片）等多个特性。

## 第2章 使用Redis构建Web应用 ##

一个Web服务器对请求进行响应：

1. 服务器对客户端发来的请求（request）进行解析。
2. 请求被转发给预定义的处理器（handler）。
3. 处理器可能会从数据库中取出数据。
4. 处理器根据据取出的数据对模板（template）进行渲染（render）。
5. 处理器向客户端返回渲染后的内容作为对请求的响应（reponse）。

### 2.1 登录和cookie缓存 ###

思路：

1. 将使用一个散列来存储登录cookie令牌与已登录用户之间的映射。要检查一个用户是否已经登录。
2. 用户每次浏览页面的时候，程序员都会对用户存储在登录散列里面的信息进行更新，并将用户的令牌和当前时间撮添加到记录最近登录用户的有序集合里面；如果用户正在浏览的是一个商品页面，那么程序还会将这个商品添加到记录这个用户最近浏览过的商品的有序集合里面，并在被记录商品的数量超过25个时，对这个有序集合进行修剪。

### 2.2 使用Redis实现购物车 ###

每个用户的购物车都是一个散列，这个散列存储了商品ID与商品订购数量之间的映射。对商品数量进行验证的工作由Web应用程序负责，在商品发生变化时，对购物车进行更新。

### 2.3 网页缓存 ###



### 2.4 数据行缓存 ###

编写一个持续运行的守护进程函数，让这个函数将指定的数据行缓存到Redis里面，并不定期地对这些缓存进行更新。

程序是用了两个有序集合来记录应该在何时对缓存进行更新：第一个有序集合为调度（schedule）有序集合，它的成员为数据行的行ID，而分支则是一个时间戳；第二个有序集合为延时（delay）有序集合，它的成员也是数据行的行ID，而分值则记录了指定数据行的缓存需要每隔多少秒更新一次。

使用JSON而不是其他格式，嵌套多个结构。

为了让缓存函数定期地缓存数据行，首先需要将行IDhe给定的延迟值添加到延迟有序集合里面，然后再将行ID和当前时间的时间戳添加到调度有序集合里面。

### 2.5 网页分析 ###


### 2.6 小结 ###
降低数据库负载和Web服务器负载的方法

## 第3章 Redis命令 ##

### 3.1 字符串 ###

* 字符串(byte string)
* 整数
* 浮点数

INCR、DECR、INCRBY、DECRBAY、INCRBYFLOAT

APPEND、GETRANGE、SETRANGE、GETBIT、SETBIT、BITCOUNT、BITOP

### 3.2 列表 ###

Redis的列表允许用户从序列的两端推入或者弹出元素，获取列表元素，以及执行各种常见的列表操作。

RPUSH、LPUSH、RPOP、LPOP、LINDEX、LRANGE、LTRIM

从语义上来说，列表的左端为开头，右端为结尾。有几个列表命令可以将元素从一个列表移动到另一个列表，或者阻塞（block）执行命令客户端直到有其他客户端给列表添加元素为止。

阻塞式的列表弹出命令以及在列表之间移动元素的命令BLPOP、BRPOP、RPOPLPUSH、BRPOPLPUSH

对于阻塞弹出命令和弹出并推入命令、最常见的用例就是消息传递（messaging）和任务队列(task queue)

### 3.3 集合 ###

Redis的集合以无序的方式来存储多个各不相同的元素，用户可以快速地对集合执行添加元素操作、移除元素操作以及检查一个元素是否存在于集合里。

SADD、SREM、SISMEMBER、SCARD（返回集合包含的元素数量）、SMEMBERS、SRANDMEMBER、SPOP、SMOVE

SDIFF、SDIFFSTORE、SINTER、SINTERSTORE、SUNION、SUNIONSTORE

### 3.4 散列 ###

Redis的散列可以让用户将多个键值对存储到一个Redis键里面。从功能来说，Redis为散列值提供了一些与字符串值相同的特性，使得散列非常适用于将一些相关的数据存储在一起。

最常用的散列命令：其中包括添加和删除键值对的命令、获取所有键值对的命令，以及对键值对的值进行自增或者自减操作的命令。

HMGET、HMSET、HDEL、HLEN

高级特性：HEXISTS、HKEYS、HVALS、HGETALL、HINCRBY、HINCRBYFLOAT

### 3.5 有序集合 ###

有序集合存储着成员与分值之间的映射，并且提供了分值处理命令，以及根据分值大小有序地获取（fetch）或扫描（scan）成员和分值的命令。

基础操作：
ZADD、ZREM、ZCARD、ZINCRBY、ZCOUNT、ZRANK、ZSCORE、ZRANGE

有序集合的范围型数据获取命令和范围型数据删除命令，以及并集命令和交集命令：
ZREVRANK、ZREVRANGE、ZRANGEBYSCORE、ZREVRANGEBYSCORE、ZREMRANGEBYRANK、ZREMRANGEBYSCORE、ZINTERSTORE、ZUNIONSTORE

除了使用逆序来处理有序集合之外，ZREV*命令的工作方式和相对应的非逆序命令的工作方式完全一样（逆序就是指元素按照分值从大到小地排列）。

并集和交集

* 交集：对两个输入有序集合执行交集运算并得到输出有序集合的过程，这次交集运算使用的是默认的聚合函数sum，所以输出有序集合成员的分值都是通过加法计算得出的。conn.zinterstore('zset-i', ['zset-1','zset-2'])
* 并集：使用聚合函数min执行并集运算的过程，min函数在多个输入有序集合都包含同一个成员的情况下，会将最小的那个分值设置为这个成员在输出有序集合的分值。conn.zunionstore('zset-u', ['zset-1', 'zset-2'], aggregate='min')

### 3.6 发布与订阅 ###

发布与订阅（又称pub/sub）的特点是订阅者（listener）负责订阅频道（channel），发送者（publisher）负责向频道发送二进制字符串消息（binary string message）。

Redis提供的发布与订阅命令：SUBSCRIBE、UNSUBSCRIBE、PUBLISH、PSUBSCRIBE、PUNSUBSCRIBE

发布订阅模式缺点：

1. 和Redis系统的稳定性有。
2. 和数据传输的可靠性有关。

PUBLISH命令和SUBSCRIBE命令，可能会丢失一小部分数据。

### 3.7 其他命令 ###

SORT，MULTI和EXEC

#### 3.7.1 排序 ####

SORT 根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果。

	conn.sort()

SORT不仅可以对列表进行排序，还可以对集合进行排序，然后返回一个列表形式的排序结果。

	# 根据字母表顺序对元素进行排序
	conn.sort('sort-input', alpha=True)
	# 对散列的域（field）用作权重，对sort-input列表进行排序
	conn.sort('sort-input', by='d-*->field')
	# 对散列的域（field）用作权重，对sort-input列表进行排序
	conn.sort('sort-input', by='d-*->field', get='d-*->field')

#### 3.7.2 基本的Redis事务 ####

WATCH、MULTI、EXEC、UNWATCH和DISCARD

**什么是Redis的基本事务**

Redis的基本事务（basic transaction）需要用到MULTI命令和EXEC命令。

Redis事务在Python客户端上面是由流水线（pipline）实现的：对连接对象调用pipeline()方法将创建一个事务。

#### 3.7.3 键的过期时间 ####

## 第4章 数据安全与性能保障 ##

### 4.1 持久化选项 ###

1. 快照（snapshotting）
2. 只追加文件（append-only file，AOF）

#### 4.1.1 快照持久化 ####

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同的服务器副本，还可以将快照留在原地以便重启服务器时使用。

**1.个人开发**

**2.对日志进行聚合计算**

**3.大数据**

当Redis存储的数据量只有几个GB的时候，使用快照来保存数据是没有问题的。如果Redis的内存占用量达到数十个GB，并且剩余的空闲内存并不多，或者Redis运行在虚拟机（virtual machine）上面，那么执行BGSAVE可能会导致系统长时间地停顿。

执行BGSAVE而导致的停顿时间有多长取决于Redis所在的系统：对于真实的硬件、VMWare虚拟机或者KVM虚拟机来说，Redis进程每占用一个GB的内存，创建该进程的子进程所需的时间就要增加10～20毫秒；而对于Xen虚拟机来说，根据配置的不同，Redis进程每占用一个GB的内存，创建该进程的子进程所需的时间就要增加200~300毫秒。

用户能够妥善处理快照持久化会带来的大量数据丢失，快照持久化对用户来说将是个不错的选择，但对于更多的应用来说，可以使用AOF持久化将存储在内存里面的数据尽快地保存到硬盘里面

#### 4.1.2 AOF持久化 ####

AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。Redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所继续的数据集。

文件同步

appendfsync选项及同步频率

|选项|同步频率|
|--|--|
|always|每个Redis写命令都要同步写入硬盘（严重降低Redis的速度）|
|everysec|每秒执行一次同步|
|no|让操作系统来决定何时进行同步|

appendfsync always选项

Redis处理命令的速度会受到硬盘性能的限制：转盘式硬盘（spinning disk）（每秒处理大约200个写命令）和固态硬盘（solid-state drive， SSD）（每秒处理大约几万个写命令）。

appendfsync everysec选项 

Redis每秒同步一次AOF文件时的性能和不适用任何持久化特性时的性能相差无几。

appendfsync no选项

不会对Redis的性能带来影响，但系统崩溃将导致使用这种选项的Redis服务器丢失不定数量的数据。如果用户的硬盘处理写入操作的速度不够快的话，那么当缓冲区被等待写入硬盘的数据填满时，Redis的写入操作将被阻塞，并导致Redis处理命令请求的速度变慢。不推荐使用。

AOF持久化缺陷，AOF文件的体积大小。

#### 4.1.3 重写/压缩AOF文件 ####

AOF持久化既可以将丢失数据的时间窗口降低至1秒（甚至不丢失任何数据），又可以在极短的时间内完成定期的持久化操作。体积不断增大的AOF文件甚至可能会用完硬盘的所有可用空间。

为了解决AOF文件体积不断增大的问题，用户可以向Redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写（rewrite）AOF文件，使AOF文件的体积变得尽可能地小。

BGREWRITEAOF、BGSAVE

AOF持久化、快照持久化，将数据持久化到硬盘上都是非常有必要的，但除了进行持久化之外，用户还必须对持久化所得的文件进行备份（最好时备份到多个不同的地方）。

### 4.2 复制 ###

复制（replication）是不可或缺的。复制可以让其他服务器拥有一个不断地更新数据副本，从而使得拥有数据副本的服务器可以用于处理客户端发送的读请求。

关系数据库通常会使用一个主服务器（master）向多个从服务器（slave）发送更新，并使用从服务器来处理所有读请求。Redis采用了通用的方法来实现自己的复制特性，并将其用作扩展性能的一种手段。

SUNIONSTORE命令的性能

在需要扩展读请求的时候，或者在需要写入临时数据的时候用户可以通过设置额外的Redis从服务器来保存数据集的副本。在接收到主服务器发送的数据初始副本（initial copy of the data）之后，客户端每次向主服务器进行写入时，从服务器都会实时地更新。

#### 4.2.1 对Redis的复制相关选项进行配置 ####


#### 4.2.2 Redis复制的启动过程 ####

从服务器连接主服务器时的步骤

|步骤|主服务器操作|从服务器操作|
|--|--|--|
|1|(等待命令进入)|连接（或者重连接）主服务器，发送SYNC命令|
|2|开始执行BGSAVE，并使用缓冲区记录BGSAVE之后执行的所有写命令|根据配置选项来决定是继续使用现有的数据（如果有的话）来处理客户端的命令请求，还是向发送请求的客户端返回错误|
|3|BGSAVE执行完毕，向从服务器发送快照问津啊，并在发送期间继续使用缓冲区记录被执行的写命令|丢失所有旧数据（如果有的话），开始载入主服务器发来的快照文件|
|4|快照文件发送完毕，开始向从服务器发送存储在缓冲区里面的写命令|完成对快照文件的解释操作，像往常一样开始接受命令请求|
|5|缓冲区存储的写命令发送完毕；从现在开始，每执行一个写命令，就向从服务器发送相同的写命令|执行主服务器发来的所有存储在缓冲区里面的写命令；并从现在开始，接收并执行主服务器传来的每个写命令|

主服务器只使用50%~65%的内存，留下30%~45%的内存用于执行BGSAVE命令和创建记录写命令的缓存区。

用户既可以通过配置选项SLAVEOF host port来将一个Redis服务器设置为从服务器，又可以通过向运行中的Redis服务器发送SLAVEOF命令来将其设置为从服务器。如果用户使用的是SLAVEOF配置选项，那么Redis在启动时首先会载入当前可用的任何快照文件或者AOF文件，然后连接主服务器并执行复制过程。如果用户使用的是SLAVEOF命令，那么Redis会立即尝试连接主服务器。

从服务器在进行同步时，会清空自己的所有数据。从服务器在与主服务器进行初始连接时，数据库中原有的所有数据都将丢失，并将替换成主服务器发来的数据。

*Redis都不支持主主复制*

#### 4.2.3 主从链 ####

## 第5章 使用Redis构建支持程序 ##

### 5.1 使用Redis来记录日志 ###

1. 将日志记录到文件里面，然后随着时间流逝不断地将一个又一个日志行添加到文件里面，并在一段时间之后创建新的日志文件。
2. syslog服务是第二种常用的日志记录方法， 这个服务运行在几乎所有Linux服务器和Unix服务器的514号TCP端口和UDP端口上面。 

#### 5.1.1 最新日志 ####

log_recent()

#### 5.1.2 常见日志 ####

### 5.2 计数器和统计数据 ###

#### 5.2.1 将计数器存储到Redis里面 ####

为了收集指标数据并进行监视和分析，将构建一个能够持续创建并维护计数器的工具，这个工具创建的每个计数器都有自己的名字（名字里带有网站点击量、销量或者数据库查询字样的计数器都是比较重要的计数器）。这些计数器会以不同的时间精度（如1秒、5秒、1分钟等）存储最新的120个数据样本。

**1.对计数器进行更新**

有序序列（order_sequence）

update_count()函数

get_count()函数

**1.对计数器进行更新**

**1.对计数器进行更新**

## 附录 ##

python redis客户度

	import redis
	
	conn = redis.Redis()
	print(conn.set("hello", "world"))
	print(conn.get("hello"))
