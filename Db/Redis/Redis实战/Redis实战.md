# Redis实战 #

# 第一部分 入门 #

## 第1章 初识Redis ##

### 1.1 Redis简介 ###

存储键（key）与5种不同类型的指之间的映射（mapping），可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性来扩展读性能，还可以使用客户端分片来扩展写性能。

#### 1.1.1 Redis与其他数据库和软件的对比 ####

Redis用作主存储（primary storage）和二级存储（secondary storage）时的用户和查询模式

Redis，memcached，MySQL，PostgreSQL，MongoDB

#### 1.1.2 附加特性 ####

Redis拥有两种不同形式的持久化方法，可以用小而紧凑的格式将存储在内存中的数据写入硬盘：第一种持久化方法为时间点转储（point-in-time dump），转储操作既可以在“指定时间段内有指定数量的写操作执行”这一条被满足时执行，又可以通过调用两条转储到硬盘到硬盘（dump-to-disk）命令中的任何一条来执行；第二条持久化方法将所有写入数据库的命令都写入一个只追加（append-only）文件里面，用户可以根据数据的重要车改年度，将只追加写入设置为从不同步（sync）、每秒同步一次或者每写入一个命令就同步一次。

提供故障转移（failover）支持，Redis实现了主从复制特性：执行复制的从服务器会连接上主服务器，接收主服务器发送的整个数据库的初始副本（copy）；之后主服务器执行的写命令，都会被发送给所有连接着的从服务器去执行，从而实时地更新从服务器的数据集。

#### 1.1.3 使用Redis的理由 ####

### 1.2 Redis数据结构简介 ###

STRING（字符串）、LIST（列表）、SET（集合）、HASH（散列）和ZSET（有序集合）

|结构类型|结构存储的值|结构的读写能力|
|--|--|--|
|STRING||
|LIST|一个链表|
|SET|包含字符串的无需收集器|
|HASH|包含键值对的无序散列表|
|ZSET(有序集合)|字符串成员（member）与浮点数分值（score）之间的有序映射|

#### 1.2.1 Redis的字符串（STRING） ####

GET、SET、DEL

#### 1.2.2 Redis中的列表（LIST） ####
linked-list

|命令|行为|
|--|--|
|LPUSH||
|RPUSH|将给定值推入列表的右端|
|LPOP|从列表的左端弹出一个值，并返回被弹出的值|
|RPOP||
|LINDEX|获取列表在给定位置上的单个元素|
|LRANGE|获取列表在给定范围上的所有值|

#### 1.2.3 Redis的集合（SET） ####

Redis的集合和列表都可以存储多个字符串，列表可以存储多个相同的字符串，而集合则通过使用散列表来保证自己存储的每个字符串都是各不相同的。

集合使用无序（unordered）方式存储元素。

|命令|行为|
|--|--|
|SADD|将给定元素添加到集合|
|SMEMBERS|返回集合包含的所有元素|
|SISMEMBER|检查给定元素是否妇女在于集合中|
|SREM|如果给定的元素存在与集合中|那么移除这个元素|

#### 1.2.4 Redis的散列（HASH） ####

Redis的散列可以存储多个键值对之间的映射，散列存储的值既可以是字符串又可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作。散列在很多方法就像是一个微缩版的Redis，不少字符串命令都有相应的散列版本。

|命令|行为|
|--|--|
|HSET|在散列里面关联起给定的键值对|
|HGET|获取指定散列键的值|
|HGETALL|获取散列包含的所有键值对|
|HDEL|如果给定键存在于散列里面，那么移除这个键|

#### 1.2.5 Redis的有序集合（ZSET有序集合） ####

有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同的；而有序集合的值则被称为分值（score），分值必须为浮点数。

有序集合是Redis里面唯一一个既可以根据成员访问元素，又可以根据分值以及分值的排列顺序来访问元素的结构。

	# 获取有序集合包含的所有元素时，多个元素会按照分值大小进行排序
	zrange zset-key 0 -1 withscores
	# 用户根据分值来获取有序集合中的一部分元素
	zrangebyscore zset-key 0 800 withscores

|命令|行为|
|--|--|
|ZADD|将一个带有给定分值的成员添加到有序集合里面|
|ZRANGE|根据元素在有序排列中所处的位置，从有序集合里面获取多个元素|
|ZRANGEBYSCORE|获取有序集合在给定分值范围内的所有元素|
|ZREM|如果给定成员存在于有序集合，那么移除这个成员|

### 1.3 你好 Redis ###

StackOverflow

#### 1.3.1 对文章进行投票 ####

文章投票 article_vote() 

#### 1.3.2 发布并获取文章 ####

发布文章post_article()函数

获得文章get_articles()函数

#### 1.3.3 对文章进行分组 ####

对文章进行分组 add_remove_groups()函数

Redis的ZINTERSTORE命令可以接受多个集合和多个有序集合作为输入，找出所有同时存在于集合和有序集合的成员，并以几种不同的方式来合并（combine）这些成员的分值（所有集合成员的分值都会被视为是1）。

在这个项目中，程序需要使用ZINTERSTORE命令选出相同成员中最大的那个分值来作为交集成员的分值：取决于所使用的排序选项，这些分值既可以是文章的评分，也可以是文章的发布时间。

### 1.4 需求帮助 ###

### 1.5 小结 ###

Redis是一个可以用来解决问题的工具，它即拥有其他数据库不具备的数据结构，又拥有内存存储（使得redis的速度非常快）、远程（使得Redis可以与多个客户端和服务器进行连接）、持久化（使得服务器可以在重启之后仍然保持重启之前的数据）和可扩展性（通过主从复制和分片）等多个特性。

## 第2章 使用Redis构建Web应用 ##

一个Web服务器对请求进行响应：

1. 服务器对客户端发来的请求（request）进行解析。
2. 请求被转发给预定义的处理器（handler）。
3. 处理器可能会从数据库中取出数据。
4. 处理器根据据取出的数据对模板（template）进行渲染（render）。
5. 处理器向客户端返回渲染后的内容作为对请求的响应（reponse）。

### 2.1 登录和cookie缓存 ###

思路：

1. 将使用一个散列来存储登录cookie令牌与已登录用户之间的映射。要检查一个用户是否已经登录。
2. 用户每次浏览页面的时候，程序员都会对用户存储在登录散列里面的信息进行更新，并将用户的令牌和当前时间撮添加到记录最近登录用户的有序集合里面；如果用户正在浏览的是一个商品页面，那么程序还会将这个商品添加到记录这个用户最近浏览过的商品的有序集合里面，并在被记录商品的数量超过25个时，对这个有序集合进行修剪。

|cookie类型|优点|缺点|
|--|--|--|
|签名cookie|验证cookie所需的一切信息都存储在cookie里面。cookie可以包含额外的信息（additional information），并且对这些信息进行签名也很容易|正确地处理签名很难。很容易忘记对数据进行签名，或者忘记验证数据的签名，从而造成安全漏洞|
|令牌cookie|添加信息非常容易。cookie的体积非常小，因此移动终端和速度较慢的客户端可以更快地发送请求|需要在服务器中存储更多信息。如果使用的是关系数据库，那么载入和存储cookie的代价可能会很高|
	
1. 使用一个散列来存储登录cookie令牌与已登录用户之间的映射。检查一个用户是否已经登录。 `check_token()函数`
2. 对令牌进行检查并不困难，因为大部分复杂的工作都是在更新令牌时完成的：用户每次浏览页面的时候，程序都会对用户存储在登录散列里面的信息进行更新，并将用户的令牌和当前时间戳添加到记录最近登录用户的有需集合里面；如果用户正在浏览的是一个商品页面，那么程序还会将这个商品添加到记录这个用户最近浏览过的商品的有序集合里面，并在被记录商品的数量超过25个时，对这个有序集合进行修剪。`update_token()函数`
3. 因为存储会话数据所需的内存会随着时间的推移而不断增加，所以我们需要定期清理旧的会话数据。`clean_sessions()函数`


ZCARD命令返回在指定的键存储在集合中的元素的数量。

### 2.2 使用Redis实现购物车 ###

使用cookie实现购物车——也就是将整个购物车都存储到cookie里面的做法非常常见，这种做法的一大优点是无须对数据库进行写入就可以实现购物车功能，而缺点则是长吁需要重新解析和验证（validate）cookie，确保cookie的格式正确，并且包含的商品都是真正可购买的商品。cookie购物车还有一个缺点：因为浏览器每次发送请求都会连cookie一起发送，所以如果购物车cookie的体积比较大，那么请求发送和处理的速度可能会有所降低。

	{"timestamp":1497061872253,"status":500,"error":"Internal Server Error","exception":"redis.clients.jedis.exceptions.JedisDataException","message":"value sent to redis cannot be null","path":"/login/check"}

1. 每个用户的购物车都是一个散列，这个散列存储了商品ID与商品订购数量之间的映射。对商品数量进行验证的工作由Web应用程序负责，在商品发生变化时，对购物车进行更新。
2. 接着，我们需要对之前的会话清理函数进行更新，让它在清理旧会话的同时，将旧会话对应用户的购物车也一并删除。

### 2.3 网页缓存 ###

所有的标准的Python应用框架都提供了在处理请求之前或者之后添加（layer）的能力，这些层被称为中间件（middleware）或者插件（plugin）。`cache_request()`

缓存函数可以让网站在5分钟之内无需再为它们动态地生成视图页面。取决于网页的内容有多复杂，这一改动可以将包含大量数据的页面的延迟值从20~50毫秒降低之查询一次Redis所需的时间：查询本地Redis的延迟值通常低于1毫秒，而查询位于同一个数据中心的Redis的延迟值通常低于5毫秒。
### 2.4 数据行缓存 ###

将原本由关系数据库和页面浏览器实现的登录和访客会话转移到了Redis上面实现；将原本由关系数据库实现的购物车也放到了Redis上面实现;还将所有页面缓存到了Redis里面。提升了网站的性能，降低了关系数据库的负载并减少了网站成本。

编写一个持续运行的守护进程函数，让这个函数将指定的数据行缓存到Redis里面，并不定期地对这些缓存进行更新。

程序是用了两个有序集合来记录应该在何时对缓存进行更新：第一个有序集合为调度（schedule）有序集合，它的成员为数据行的行ID，而分支则是一个时间戳；第二个有序集合为延时（delay）有序集合，它的成员也是数据行的行ID，而分值则记录了指定数据行的缓存需要每隔多少秒更新一次。

使用JSON而不是其他格式，嵌套多个结构。

Redis并不支持嵌套结构特性。

为了让缓存函数定期地缓存数据行，首先需要将行IDhe给定的延迟值添加到延迟有序集合里面，然后再将行ID和当前时间的时间戳添加到调度有序集合里面。`schedule_row_cache`函数。

负责缓存数据行的函数会尝试读取调度有序集合的第一个元素以及该元素的分值，如果调度有序集合没有包含任何元素，或者分值村粗话的时间戳所指定的时间尚未来临，那么函数会先休眠50毫秒，然后再重新进行检查。`cache_rows()`函数

通过组合使用调度函数和持续运行缓存函数,实现了一种重复进行调度的自动缓存机制,并且可以随心所欲地控制数据行缓存的更新频率:如果数据行记录的是特价促销商品的剩余数量,并且参与促销活动的用户非常多的话,那么我们最好每隔几秒更新一次数据行缓存;另一方面,如过数据并不经常改变,或者商品缺货是可以接受的,那么我们可以每分钟更新一次缓存。

### 2.5 网页分析 ###

每个用户都有一个相应的记录用户浏览商品历史的有序集合，尽管使用这些有序集合可以计算出用户最经常浏览的商品，但进行这种计算却需要耗费大量的时间。为了解决这个问题，需要修改下`update_token`函数。新添加的代码记录了所有商品的浏览次数，并根据浏览次数对商品进行了排序，被浏览得最多的商品将被放到有序集合的索引0位置上，并且具有整个有序集合最少的分值。

ZINTERSTORE命令可以组合起一个或多个有序集合，并将有序集合包含的每个分值都乘以一个给定的数值（用户可以为每个有序集合分别指定不同的相乘数值）。

删除所有排名再20000名之后的商品，并将删除之后剩余的所有商品的浏览次数减半。`rescale_viewed()`函数。通过记录商品的浏览次数，并定期对记录浏览次数的有序集合进行修剪和分值调整，建立起了一个持续更新的最常浏览商品排行榜。

使用新的方法来判断页面是否需要被缓存。`can_cache()`

如果想以最小的代价来存储更多页面，那么可以考虑先对页面进行压缩，然后再缓存到Redis里面；或者使用Edge Side Includes技术移除页面中的部分内容；又或者对模板进行提前优化（pre-optimize），移除所有非必要的空格字符。

### 2.6 小结 ###
降低数据库负载和Web服务器负载的方法。

在为应用程序创建新构建时，不要害怕回过头去重构已有的构建，因为就像本章展示的购物车cookie的例子和基于登录会话cookie实现网页分析的例子一样，已有的构件有时候需要进行一些细微的修改才能真正满足你的需求。

# 第二部分 核心概念 #

## 第3章 Redis命令 ##

### 3.1 字符串 ###

* 字符串(byte string)
* 整数
* 浮点数

用户可以通过给定一个任意的数值，对存储着整数或者浮点数的字符串执行自增（increment）或者自减(decrement)操作，在有需要的时候，Redis还有将整数转换成浮点数。

浮点数，基本的数值自增和自减操作，以及二进制位（bit）和子串（substring）处理命令。

INCR、DECR、INCRBY、DECRBAY、INCRBYFLOAT

|命令|用例和描述|
|--|--|
|INCR|INCR key-name——将键存储的值加上1|
|DECR|DECR key-name——将键存储的值减去1|
|INCRBY|INCRBY key-name amount——将健存储的值加上整数amount|
|DECRBY|DECRBY key-name amount——将健存储的值减去整数amount|
|INCRBYFLOAT|INCRBYFLOAT key-name amount——将键存储的值加上浮点数amount，这个命令在Redis2.6或以上的版本可用|

APPEND、GETRANGE、SETRANGE、GETBIT、SETBIT、BITCOUNT、BITOP

|命令|用例和描述|
|--|--|
|APPEND|APPEND key-name value——将值value追加到给定键key-name当前存储的值的末尾|
|GETRANGE|GETRANGE key-name start end——获取一个由偏移量start之偏移量end范围内所有字符组成的子串，包括start和end在内|
|SETRANGE|SETRANGE key-name offset value——将从start偏移量开始的子串设置为给定值|
|GETBIT|GETBIT key-name offset——将字节串看作是二进制位串（bit string），并返回位串中偏移量为offset的二进制位的值|
|SETBIT|SETBIT key-name offset value|
|BITCOUNT|BITCOUNT key-name [start end]|
|BITOP|BITOP operation des-key key-name [key-name ...]|

在使用SETRANGE或者SETBIT命令对字符串进行写入的时候，如果字符串当前的长度不能满足写入的要求，那么Redis会自动地使用空字节（null）来将字符串扩展至所需的长度，然后才能执行写入或者更新操作。

SETBIT 命令会返回二进制被设置之前的值。

Redis 通过使用子串操作和二进制位操作，配合WATCH命令、MULTI命令和EXEC命令，用户甚至可以自己动手去构建任何他们想要的数据结构。

### 3.2 列表 ###

Redis的列表允许用户从序列的两端推入或者弹出元素，获取列表元素，以及执行各种常见的列表操作。

|命令|用例和描述|
|--|--|
|RPUSH|RPUSH key-name value [value ...]——将一个或多个值推入列表的右端|
|LPUSH|LPUSH key-name value [value ...]——将一个或多个值推入列表的左端|
|RPOP|RPOP key-name——移除并返回列表最右端的元素|
|LPOP|LPOP key-name——移除并返回列表最左端的元素|
|LINDEX|LINDEX key-name offset——返回列表中偏移量为offset的元素|
|LRANGE|LRANGE key-name start end——返回列表从start偏移量到end偏移量范围内的所有元素，其中偏移量为start和偏移量和end的元素也会包含在被返回的元素之内|
|LTRIM|LTRIM key-name start end——对列表进行修剪，只保留从start偏移量到end偏移量范围内的元素，其中偏移量start和偏移量为end的元素也会被保留|

从语义上来说，列表的左端为开头，右端为结尾。有几个列表命令可以将元素从一个列表移动到另一个列表，或者阻塞（block）执行命令客户端直到有其他客户端给列表添加元素为止。

阻塞式的列表弹出命令以及在列表之间移动元素的命令BLPOP、BRPOP、RPOPLPUSH、BRPOPLPUSH

|命令|用例和描述|
|--|--|
|BLPOP|BLPOP key-name [key-name ...] timeout——从第一个非空列表中弹出位于最左端的元素，或者timeout秒之内阻塞并等待可弹出的元素出现|
|BRPOP|BRPOP key-name [key-name ...] timeout——从第一个非空列表中弹出位于最右端的元素，或者timeout秒之内阻塞并等待可弹出的元素出现|
|RPOPLPUSH|RPOPLPUSH source-key desy-key——从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素|
|BRPOPLPUSH|BRPOPLPUSH source-key dest-key timeout——从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素；如果source-key为空，那么在timeout秒之内阻塞并等待可弹出的元素出线|

对于阻塞弹出命令和弹出并推入命令、最常见的用例就是消息传递（messaging）和任务队列(task queue)

### 3.3 集合 ###

Redis的集合以无序的方式来存储多个各不相同的元素，用户可以快速地对集合执行添加元素操作、移除元素操作以及检查一个元素是否存在于集合里。

SADD、SREM、SISMEMBER、SCARD（返回集合包含的元素数量）、SMEMBERS、SRANDMEMBER、SPOP、SMOVE

SDIFF、SDIFFSTORE、SINTER、SINTERSTORE、SUNION、SUNIONSTORE

### 3.4 散列 ###

Redis的散列可以让用户将多个键值对存储到一个Redis键里面。从功能来说，Redis为散列值提供了一些与字符串值相同的特性，使得散列非常适用于将一些相关的数据存储在一起。

最常用的散列命令：其中包括添加和删除键值对的命令、获取所有键值对的命令，以及对键值对的值进行自增或者自减操作的命令。

HMGET、HMSET、HDEL、HLEN

高级特性：HEXISTS、HKEYS、HVALS、HGETALL、HINCRBY、HINCRBYFLOAT

### 3.5 有序集合 ###

有序集合存储着成员与分值之间的映射，并且提供了分值处理命令，以及根据分值大小有序地获取（fetch）或扫描（scan）成员和分值的命令。

基础操作：
ZADD、ZREM、ZCARD、ZINCRBY、ZCOUNT、ZRANK、ZSCORE、ZRANGE

有序集合的范围型数据获取命令和范围型数据删除命令，以及并集命令和交集命令：
ZREVRANK、ZREVRANGE、ZRANGEBYSCORE、ZREVRANGEBYSCORE、ZREMRANGEBYRANK、ZREMRANGEBYSCORE、ZINTERSTORE、ZUNIONSTORE

除了使用逆序来处理有序集合之外，ZREV*命令的工作方式和相对应的非逆序命令的工作方式完全一样（逆序就是指元素按照分值从大到小地排列）。

并集和交集

* 交集：对两个输入有序集合执行交集运算并得到输出有序集合的过程，这次交集运算使用的是默认的聚合函数sum，所以输出有序集合成员的分值都是通过加法计算得出的。conn.zinterstore('zset-i', ['zset-1','zset-2'])
* 并集：使用聚合函数min执行并集运算的过程，min函数在多个输入有序集合都包含同一个成员的情况下，会将最小的那个分值设置为这个成员在输出有序集合的分值。conn.zunionstore('zset-u', ['zset-1', 'zset-2'], aggregate='min')

### 3.6 发布与订阅 ###

发布与订阅（又称pub/sub）的特点是订阅者（listener）负责订阅频道（channel），发送者（publisher）负责向频道发送二进制字符串消息（binary string message）。

Redis提供的发布与订阅命令：SUBSCRIBE、UNSUBSCRIBE、PUBLISH、PSUBSCRIBE、PUNSUBSCRIBE

发布订阅模式缺点：

1. 和Redis系统的稳定性有。
2. 和数据传输的可靠性有关。

PUBLISH命令和SUBSCRIBE命令，可能会丢失一小部分数据。

### 3.7 其他命令 ###

SORT，MULTI和EXEC

#### 3.7.1 排序 ####

SORT 根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果。

	conn.sort()

SORT不仅可以对列表进行排序，还可以对集合进行排序，然后返回一个列表形式的排序结果。

	# 根据字母表顺序对元素进行排序
	conn.sort('sort-input', alpha=True)
	# 对散列的域（field）用作权重，对sort-input列表进行排序
	conn.sort('sort-input', by='d-*->field')
	# 对散列的域（field）用作权重，对sort-input列表进行排序
	conn.sort('sort-input', by='d-*->field', get='d-*->field')

#### 3.7.2 基本的Redis事务 ####

WATCH、MULTI、EXEC、UNWATCH和DISCARD

**什么是Redis的基本事务**

Redis的基本事务（basic transaction）需要用到MULTI命令和EXEC命令。

Redis事务在Python客户端上面是由流水线（pipline）实现的：对连接对象调用pipeline()方法将创建一个事务。

1. 移除竞争条件
2. 提高性能

#### 3.7.3 键的过期时间 ####

	
## 第4章 数据安全与性能保障 ##

### 4.1 持久化选项 ###

Redis提供了两种不同的持久化方法来将数据存储到硬盘里面。

1. 快照（snapshotting）：他可以将存在于某一时刻的所有数据都写入硬盘里面。
2. 只追加文件（append-only file，AOF）：他会在执行写命令时，将被执行的写命令复制到硬盘里面。

redis.windows.conf

redis.windows-service.conf

	# 快照持久化选项
	save 60 1000
	stop-writes-on-bgsave-error no
	rdbcompression yes
	dbfilename dump.rdb
如何命名硬盘上的快照文件、多久执行一次自动快照操作、是否对快照文件进行压缩，以及在创建快照失败后是否仍然继续执行写命令。		
	# AOF持久化选项
	appendonly no
	appendfsync everysec
	no-appendfsync-on-rewrite no
	auto-aof-rewrite-percentage 100
	auto-aof-rewrite-min-size 64mb

	dir ./
Redis是否使用AOF持久化、多久才将写入的内容同步到硬盘、在对AOF进行压缩（compaction）的时候能够执行同步操作，以及多久执行一次AOF压缩。
#### 4.1.1 快照持久化 ####

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同的服务器副本，还可以将快照留在原地以便重启服务器时使用。

根据配置，快照将被写入dbfilename选项指定的文件里面，并存储在dir选项指定的路径上面。如果在新的快照文件创建完毕之前，Redis、系统或者硬件这三者之中的任意一个崩溃了，那么Redis将丢失最近一次创建快照之后写入的所有数据。

* 1
* 2
* 3
* 4
* 5

**1.个人开发**

	save 900 1.
其中save选项告知Redis，应该根据这个选项提供的两个值来执行BGSAVE操作。在这个规则设置下，如果服务器距离上次成功生成快照超过了900秒，并且在此期间执行了至少一次写入操作，那么Redis就会自动开始一次新的BGSAVE。

把开发环境设置得尽量贴近生产环境，有助于判断快照是否生成得过于频繁或者过于稀少（过于频繁会浪费资源，而过去稀少则带有丢失大量数据的隐患）。

**2.对日志进行聚合计算**

一个Redis连接：一个存储日志文件的路径；待处理日志文件中各个行（line）的回调函数（callback）。这个函数可以在处理日志文件的同时，记录被处理日志文件的名字以及偏移量。

**3.大数据**

当Redis存储的数据量只有几个GB的时候，使用快照来保存数据是没有问题的。如果Redis的内存占用量达到数十个GB，并且剩余的空闲内存并不多，或者Redis运行在虚拟机（virtual machine）上面，那么执行BGSAVE可能会导致系统长时间地停顿。

执行BGSAVE而导致的停顿时间有多长取决于Redis所在的系统：对于真实的硬件、VMWare虚拟机或者KVM虚拟机来说，Redis进程每占用一个GB的内存，创建该进程的子进程所需的时间就要增加10～20毫秒；而对于Xen虚拟机来说，根据配置的不同，Redis进程每占用一个GB的内存，创建该进程的子进程所需的时间就要增加200~300毫秒。

用户能够妥善处理快照持久化会带来的大量数据丢失，快照持久化对用户来说将是个不错的选择，但对于更多的应用来说，可以使用AOF持久化将存储在内存里面的数据尽快地保存到硬盘里面

#### 4.1.2 AOF持久化 ####

AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。Redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所继续的数据集。

文件同步

appendfsync选项及同步频率

|选项|同步频率|
|--|--|
|always|每个Redis写命令都要同步写入硬盘（严重降低Redis的速度）|
|everysec|每秒执行一次同步|
|no|让操作系统来决定何时进行同步|

appendfsync always选项

Redis处理命令的速度会受到硬盘性能的限制：转盘式硬盘（spinning disk）（每秒处理大约200个写命令）和固态硬盘（solid-state drive， SSD）（每秒处理大约几万个写命令）。

appendfsync everysec选项 

Redis每秒同步一次AOF文件时的性能和不适用任何持久化特性时的性能相差无几。

appendfsync no选项

不会对Redis的性能带来影响，但系统崩溃将导致使用这种选项的Redis服务器丢失不定数量的数据。如果用户的硬盘处理写入操作的速度不够快的话，那么当缓冲区被等待写入硬盘的数据填满时，Redis的写入操作将被阻塞，并导致Redis处理命令请求的速度变慢。不推荐使用。

AOF持久化缺陷，AOF文件的体积大小。

#### 4.1.3 重写/压缩AOF文件 ####

AOF持久化既可以将丢失数据的时间窗口降低至1秒（甚至不丢失任何数据），又可以在极短的时间内完成定期的持久化操作。体积不断增大的AOF文件甚至可能会用完硬盘的所有可用空间。

为了解决AOF文件体积不断增大的问题，用户可以向Redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写（rewrite）AOF文件，使AOF文件的体积变得尽可能地小。

BGREWRITEAOF、BGSAVE

AOF持久化、快照持久化，将数据持久化到硬盘上都是非常有必要的，但除了进行持久化之外，用户还必须对持久化所得的文件进行备份（最好时备份到多个不同的地方）。

### 4.2 复制 ###

复制（replication）是不可或缺的。复制可以让其他服务器拥有一个不断地更新数据副本，从而使得拥有数据副本的服务器可以用于处理客户端发送的读请求。

关系数据库通常会使用一个主服务器（master）向多个从服务器（slave）发送更新，并使用从服务器来处理所有读请求。Redis采用了通用的方法来实现自己的复制特性，并将其用作扩展性能的一种手段。

SUNIONSTORE命令的性能

在需要扩展读请求的时候，或者在需要写入临时数据的时候用户可以通过设置额外的Redis从服务器来保存数据集的副本。在接收到主服务器发送的数据初始副本（initial copy of the data）之后，客户端每次向主服务器进行写入时，从服务器都会实时地更新。

#### 4.2.1 对Redis的复制相关选项进行配置 ####


#### 4.2.2 Redis复制的启动过程 ####

从服务器连接主服务器时的步骤

|步骤|主服务器操作|从服务器操作|
|--|--|--|
|1|(等待命令进入)|连接（或者重连接）主服务器，发送SYNC命令|
|2|开始执行BGSAVE，并使用缓冲区记录BGSAVE之后执行的所有写命令|根据配置选项来决定是继续使用现有的数据（如果有的话）来处理客户端的命令请求，还是向发送请求的客户端返回错误|
|3|BGSAVE执行完毕，向从服务器发送快照问津啊，并在发送期间继续使用缓冲区记录被执行的写命令|丢失所有旧数据（如果有的话），开始载入主服务器发来的快照文件|
|4|快照文件发送完毕，开始向从服务器发送存储在缓冲区里面的写命令|完成对快照文件的解释操作，像往常一样开始接受命令请求|
|5|缓冲区存储的写命令发送完毕；从现在开始，每执行一个写命令，就向从服务器发送相同的写命令|执行主服务器发来的所有存储在缓冲区里面的写命令；并从现在开始，接收并执行主服务器传来的每个写命令|

主服务器只使用50%~65%的内存，留下30%~45%的内存用于执行BGSAVE命令和创建记录写命令的缓存区。

用户既可以通过配置选项SLAVEOF host port来将一个Redis服务器设置为从服务器，又可以通过向运行中的Redis服务器发送SLAVEOF命令来将其设置为从服务器。如果用户使用的是SLAVEOF配置选项，那么Redis在启动时首先会载入当前可用的任何快照文件或者AOF文件，然后连接主服务器并执行复制过程。如果用户使用的是SLAVEOF命令，那么Redis会立即尝试连接主服务器。

从服务器在进行同步时，会清空自己的所有数据。从服务器在与主服务器进行初始连接时，数据库中原有的所有数据都将丢失，并将替换成主服务器发来的数据。

*Redis都不支持主主复制*

#### 4.2.3 主从链 ####

从服务器也可以拥有自己的从服务器，并由此形成主从链（master/slave chaining）

#### 4.2.4 检验硬盘写入 ####

为了验证主服务器是否已经将写数据发送至从服务器，用户需要在向主服务器写入真正的数据之后，再向主服务器写入一个唯一的虚构值（unique dummy value），然后通过检查虚构值是否存在于从服务器来判断写数据是否已经到达从服务器。

### 4.3 处理系统故障 ###

ACID是指原子性（atomicity）、一致性(consistency)、隔离性（isolation）和耐久性(durability)，如果一个数据库想要实现可靠的数据事务，那么它就必须保证ACID性质。

#### 4.3.1 验证快照文件和AOF文件 ####

	redis-check-aof
	redis-check dump
	可以在系统故障发生之后，检查AOF文件和快照文件的状态

校验和（checksum）和散列值（hash）

#### 4.3.2 更换故障主服务器 ####

假设A、B两台机器都运行着Redis，其中机器A的Redis为主服务器，而机器B的Redis为从服务器。不巧的是，机器A刚刚因为某个暂时无法修复的故障而断开了网络连接，因此用户决定将同样安装了Redis的机器C用作新的主服务器。

更换服务器的计划非常简单：首先向机器B发送一个SAVE命令，让它创建一个新的快照文件，接着将这个快照文件发送给机器C，并在机器C上面启动Redis。最后，让机器B成为机器C的从服务器。

### 4.4 Redis事务 ###

Redis的事务和传统关系数据库的事务并不相同。在关系数据库中，用户首先向数据库服务器发送BEGIN，然后执行各个相互一致（consistent）的写操作和读操作，最后，用户可以选择发送COMMIT来确认之前做的修改，或者发送ROLLBACK来放弃那些修改。

在多个事务同时处理同一个对象通场需要用到二阶提交（two-phase commit），所以如果事务不能以一致的形式读取数据，那么二阶提交将无法实现，从而导致一些原本可以成功执行的事务沦落至执行失败的地步。

延迟执行事务有助于提升性能

#### 4.4.1 定义用户信息和用户包裹 ####



#### 4.4.2 将商品放到市场上销售 ####

UNWATCH命令可以在WATCH命令执行之后、MULTI命令执行之前对连接进行重置（reset）；同样地，DISCARD命令也可以在MULTI命令执行之后、EXEC命令执行之前对连接进行重置。

list_item() 首先执行一些初始化步骤，然后对卖家的包裹进行监视，验证卖家想要销售的商品是否仍然存在于卖家的包裹当中，如果是的话，函数就会将被销售的商品添加到买卖市场里面，并从卖家的包裹中移除该商品。

#### 4.4.3 购买商品 ####

当买家的个人信息或商品买卖市场出现变化而导致WatchError异常出现时，程序将进行重试，其中最大重试时间为10秒

为什么Redis没有实现典型的枷锁功能？

因为加锁有可能会造成长时间的等待，所以Redis为了尽可能地减少客户端的等待时间，并不会在执行WATCH命令时对数据进行加锁。相反地，Redis只会在数据已经被其他客户端抢先修改了的情况下，通知执行了WATCH命令的客户端，这种做法被称为*乐观锁（optimistic locking）*，而关系数据库实际执行的加锁操作则称为*悲观锁（pressimistic locking）*。乐观锁在实际使用中同样非常有效，因为客户端永远不必花时间去等待第一个取得锁的客户端——他们只需要在自己的事务执行失败时进行重试就可以了。

### 4.5 非事务型流水线 ###

### 4.6 关于性能方法的注意事项 ###

性能测试程序redis-benchmark

redis-benchmark -c l -q 给定‘-q’选项可以让程序简化输出结果，给定'-c l'选项让程序只使用一个客户端来进行测试

|性能或者错误|可能的原因|解决方法|
|--|--|--|
|单个客户端的性能达到redis-benchmark的50%~60%|这是不使用流水线时的预期性能|无|
|单个客户端的性能达到redis-benchmark的25%~30%|对于每个命令或者每组命令都创建了新的连接|重用已有的Redis的连接|
|客户端返回错误“Cannot assign requested address”（无法分配指定的地址）|这是不使用流水线时的预期性能|重用已有Redis连接|

### 4.7 小结 ###

1. 使用复制和AOP持久化可以极大地保障数据安全；
2. 在多个客户端同时处理相同的数据时，可以使用WATCH、MULTI、EXEC等命令来防止数据出错

## 第5章 使用Redis构建支持程序 ##

### 5.1 使用Redis来记录日志 ###

1. 将日志记录到文件里面，然后随着时间流逝不断地将一个又一个日志行添加到文件里面，并在一段时间之后创建新的日志文件。
2. syslog服务是第二种常用的日志记录方法， 这个服务运行在几乎所有Linux服务器和Unix服务器的514号TCP端口和UDP端口上面。 

#### 5.1.1 最新日志 ####

log_recent()

#### 5.1.2 常见日志 ####

### 5.2 计数器和统计数据 ###

#### 5.2.1 将计数器存储到Redis里面 ####

为了收集指标数据并进行监视和分析，将构建一个能够持续创建并维护计数器的工具，这个工具创建的每个计数器都有自己的名字（名字里带有网站点击量、销量或者数据库查询字样的计数器都是比较重要的计数器）。这些计数器会以不同的时间精度（如1秒、5秒、1分钟等）存储最新的120个数据样本。

**1.对计数器进行更新**

有序序列（order_sequence）

update_count()函数

get_count()函数

**1.对计数器进行更新**

**1.对计数器进行更新**

## 第6章 使用Redis构建应用程序组件 ##

**1. 自动补全**

1. 自动补全通过使用联系人列表来记录用户最近联系过的100个人，并尝试尽可能地减少实现自动补全所需的内存。
2. 自动补全为更多联系人列表提供了更好的性能和可扩展性，但实现这些列表所花费的内存也会更多

#### 6.1.1 自动补全最近联系人 ####

为了尽可能减少存储联系人给内存带来的消耗，使用Redis的列表进行存储元素。列表占用的内存最少。可惜的是列表提供的功能并不足以让我们在Redis内部完成自动补全操作，因此实际的自动补全操作将会放到Redis之外的Python里面执行。*这样做法使得程序可以尽量减少Redis存储和更新用户最近联系人列表所需的内存数量。*

### 6.2 分布式锁 ###

对于能够被多个线程访问的共享内存数据结构（shared-memory data structure）来说，先是获取锁（acquire），然后执行操作，最后释放锁（release）。

Redis使用WATCH命令来代替对数据进行加锁，因为WATCH只会在数据被其他客户端抢先修改了的情况下通知执行了这个命令的客户端，而不会阻止其他客户端对数据进行修改，所以这个命令被称为乐观锁（optimistic locking）。

使用Redis构建锁，锁的范围就是Redis本身；Redis提供的SETNX命令确实具有具体的加锁功能，但它的功能并不完整，并且也不具备分布式锁常见的一些高级特性，所以需要自己动手构建分布式锁。

#### 6.2.1 锁的重要性 ####
锁
购物过程：当玩家在市场上购买商品的时候，程序首先需要使用WATCH去监视市场以及买家的个人信息散列，在得知买家现有的钱数以及商品的售价之后，程序会验证买家是否有足够的钱来购买指定的商品：如果买家有足够的钱，那么程序会将买家支付的钱转移给卖家，接着将商品添加到买家的包裹里面，并从市场里面移除已被售出的商品；相反如果有其他玩家对市场进行了改动，引发WATCH错误，程序将重新购买。

#### 6.2.2 简易锁 ####

Redis用户都对锁（lock）、加锁（locking）及锁超时（lock timeouts）。

* 持有锁的进程因为操作时间过长而导致锁被自动释放
* 一个持有锁并打算执行长时间操作的进程已经崩溃，但其他想要获取锁的进程不知道哪个进程持有着锁，也无法检测出持有锁的进程已经崩溃，只能白白地浪费时间等待锁被释放。
* 

#### 6.2.3 使用Redis构建锁 ####

对数据进行排他性访问，程序首先要做的就是获取锁。SETNX命令天生就适合用来实现锁的获取功能，这个命令只会在健不存在的情况下为键设置值，而锁要做的就是将一个随机生成的128位UUID设置为键的值，并使用这个值来防止锁被其他进程取得。

它会使用SETNX命令，尝试在代表锁不存在的情况下，为键设置一个值，以此来获取锁；在获取锁失败的时候，函数在给定的时限内进行重试，直到成功获取锁或者超过给定的时限为止（默认的重试时限为10秒）

release_lock()函数包含的无限循环只会在极小数情况下用到——函数之所以包含这个无限循环，主要是因为之后介绍的锁实现会支持超时限制特性。
#### 6.2.4 粗粒度锁 ####

如何实现与WATCH命令粒度相同的锁——这种锁可以吧整个市场都锁住。

使用多个细粒度锁也有引发死锁的危险，一不小心就回导致程序不发正常运行。

#### 6.2.5 带有超时限制特性的锁 ####

多个客户端在同一时间内设置的超时时间基本上都是相同的，所以即使有多个客户端同时为同一个锁设置超时时间，锁的超时时间也不会产生太大的变化。

### 6.3 计数信号量 ###

多个客户端同时访问相同的信息时，计数信号量就是完成这项任务的最佳工具。

计数信号量是一种锁，他可以让用户限制一项资源最多能够同时被多少个进程访问，通常用于限定能够同事使用的资源数量。

计数信号量和其他种类的锁一样，都需要被获取和释放。客户端首先需要获取信号量，然后执行操作，最后释放信号量。计数信号量和其他锁的区别在于，当客户端获取锁失败的时候，客户端通常会选择进行等待；而当客户端获取计数信号量失败的时候，客户端通常会选择立即返回失败结果。

#### 6.3.1 构建基本的计数信号量 ####

构建计数信号量时要考虑的事情和构建其他类型的锁时要考虑的事情大部分都是相同的，比如判断是哪个客户端取得了锁，如何处理客户端在获得锁之后崩溃的情况，以及如何处理锁超时的问题。

使用Redis来实现超时限制特性通常有两种方法可选。一种是像之前构建分布式锁那样，使用EXPIRE命令，而另一种则是使用有序集合。为了将多个信号量持有者的信息存储到同一个结构里面，这次我们将使用有序集合来构建计数信号量。

程序将为每个尝试获取信号量的进程生成一个唯一标识符，并将这个标识符用作有序集合的成员，而成员对应的分值则是进程尝试获取信号量的Unix时间戳。

进程在尝试获取信号量时生成一个标识符，并使用当前时间戳作为分值，将标识符添加到有序集合里面。接着进程会检查自己的标识符在有序集合中的排名。如果排名低于可获取的信号量总数（成员的排名从0开始计算），那么表示进程成功地取得了信号量。反之，则表示进程未能取得信号量，它必须从有序集合里面移除自己的标识符。

#### 6.3.2 公平信号量 ####

acquire_fair_semaphore()

release_fair_semaphore()

#### 6.3.3 刷新信号量 ####

公平信号量区分开了超时有序集合和信号量拥有者有序集合，所以程序只需对超时有序集合进行更新，就可以立即刷新信号量的超时时间了。

#### 6.3.4 消除竞争条件 ####

给个信号量实现的优缺点：

* 如果你对于使用系统时钟没有意见，也不需要对信号量进行率先你，并且能够接受信号量的数量偶尔超过限制，那么可以对我们给出的第一个信号量实现。
* 如果你只信任差距在一两秒之间的系统时钟，但仍然能够接受信号量的数量偶尔超过限制，那么可以使用第二个信号量实现。
* 如果你希望信号量一直都具有正确的行为，那么可以使用带锁的信号量实现来保证正确性。

信号量通常还用于限制针对数据库的并发请请求数量，从而降低执行单个查询所需的时间。

### 6.4 任务队列 ###

#### 6.4.1 先进先出队列 ####

#### 6.4.2 延迟任务 ####



## 第7章 基于搜索的应用程序 ##

### 7.1 使用Redis进行搜索 ###

#### 7.1.1 基本搜索原理 ####

为了获得比扫描文档更快的搜索速度，我们需要对文档进行预处理，这个预处理步骤通常被称为建索引（indexing），而我们要创建的结构则被称为反向索引（inverted indexes）。

反向索引是互联网上绝大部分搜索引擎索使用的底层结构。

**1.基本索引操作**

为了给文档构建索引集合，程序首先需要对文档包含的单词进行处理。从文档里面提取单词的过程通常被称为语法分析（parsing）和标记化（tokenization），这个过程可以产生出一系列用于标识文档的标记（token），标记有时候又被称为单词（word）。

标记化的一个常见的附加步骤，就是移除内容中的非用词（stop word）。

**2.基本搜索操作**



**3.分析并执行搜索**

如果用户只是单纯地给出了一些单词，那么搜索程序只需要直接执行一个intersect()调用就可以了。如果用户在某个单词的前面加上了一个减号（-），那么就表示拥护不希望包含这个单词的文档出现在搜索结果里面，搜索程序就需要使用difference()移除相应的文档。如果用户在某个单词的前面加上了一个加号（+），那么就表示这个单词是前一个单词的同义词，搜索程序首秀按会收集各个同义词组并对它们执行union()操作，然后再执行高层次的intersect()调用（如果带+号的单词前面有带-号的单词，那么程序会略过那些带-号的单词，并把最先遇到的不带-号的单词看作是同义词）。

## 第8章 构建简单的社交网站 ##

主页时间线（home timeline）、正在关注列表（following list）以及关注者列表（follower list）这些由状态消息或者用户组成的序列进行介绍。

### 8.1 用户和状态 ###

#### 8.1.1 用户信息 ####

当一个新用户进行注册的时候，程序需要做的就是根据用户指定的用户名以及当时的时间戳，创建一个正在关注数量、关注者数量、已发布状态消息数量都被设置为0的对象。

创建新用户的函数除了会对存储用户信息的散列进行初始化之外，还会对用户的用户名进行加锁，这个加锁操作是必须的，它可以防止多个请求（request）在同一时间内使用相同的用户名来创建新用户。对用户名进行加锁之后，程序会检查这个用户名是否已经被其他用户抢先占用了，如果这个用户名尚未被占用的话，那么程序会为这个用户生成一个独一无二的ID，并将用户名与用户ID进行关联，最后将这个用户信息存储到新创建的散列里面。

#### 8.1.2 状态消息 ####

### 8.2 主页时间线 ###

首先看到的是他们自己的主页时间线，这个时间线是一个列表，它由用户以及用户正在关注的人所发布的状态消息组成。

主页时间线，用户的个人时间线（profile timeline）

* 主页时间线可以包含其他人发布的状态消息
* 个人时间线只会包含用户自己发布的状态消息。

### 8.3 关注者列表和正在关注列表 ###

用户的主页时间线和个人时间线都是由有序集合存储的，这些有序集合存储着状态消息的ID以及状态消息发布时的时间戳。用户正在关注列表以及关注者列表同样由有序集合存储，其中有序集合的成员为用户ID，而分值则记录了用户开始关注某人或者被某人关注时的时间戳。

当用户开始关注或者停止关注另一个用户的时候，程序就需要对这两个用户的正在关注有序集合以及关注者有序集合进行更新，并修改他们在用户信息散列里面记录的关注数量和被关注数量。如果用户执行的是关注操作，那么程序在对以上提到的有序集合和散列进行更新之后，还需要被关注用户的个人时间线里面，复制一些状态消息ID到执行关注操作的用户的主页时间线里面，从而使得用户在关注另一个用户之后，可以立即看见被关注用户所发布的状态消息。

### 8.4 状态消息的发布与删除 ###

8.8 delete_status

在删除状态消息并对用户已发布状态消息数量进行更新的同事，delete_status()函数还会从用户的主页时间线和个人时间线里面移除被删除的状态消息。

其他特性

## 8.5 流API ##

广播（broadcast）简单的事件（event），然后由负责进行数据分析的事件监听器（event listener）来接收处理这些事件。

### 8.5.1 流API提供的数量 ###

## 附录 ##

python redis客户度

	import redis
	
	conn = redis.Redis()
	print(conn.set("hello", "world"))
	print(conn.get("hello"))
。