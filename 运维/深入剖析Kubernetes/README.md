# 深入剖析Kubernetes #

课前必读

## 开篇词 | 打通“容器技术”的任督二脉 ##

从过去以物理机和虚拟机为主体的开发运维环境，向以容器为核心的基础设施的转变过程，并不是一次温和的改革，而是涵盖了对网络、存储、调度、操作系统、分布式原理等各个方面的容器化理解和改造。

四大模块：

1. “白话”容器技术基础
2. Kubernetes 集群的搭建与实践
3. 容器编排与 Kubernetes 核心特性剖析
4. Kubernetes 开源社区与生态

### 精选留言 ###

#### 1 ####

如果拿汽车来做比:
Docker好比汽车引擎，
Dockerfile相当于汽车蓝图，
Docker image(镜像)就是汽车样板，
Docker container(容器)类似于汽车的零部件，
Docker Registry可以看作是4s店，
Docker Compose就像老司机,
Docker Volume就像是汽车的油箱, 如果把容器间内的io数据流比喻成汽油,
Docker Swarm(或者K8s)就是交通枢纽。

#### 2 ####

您提到: kubernetes更关注容器与编排，在资源管理方面优势不大。但正确的姿势，是用好kubernetes 可扩展能力，让它跟yarn等一起都发挥出真正的实力。国内阿里和蚂蚁在这一块走得不错。
强烈跪求讲一下如何弥补k8s的资源管理缺点，与yarn结合 这方面的知识与经验！！！

## 01 | 预习篇.小鲸鱼大事记（一）：初出茅庐 ##

PaaS 项目被大家接纳的一个主要原因，就是它提供了一种名叫“应用托管”的能力。 

## 02 | 预习篇.小鲸鱼大事记（二）：崭露头角 ##

## 03 | 预习篇.小鲸鱼大事记（二）：群雄并起 ##

## 04 | 预习篇.小鲸鱼大事记（二）：尘埃落定 ##

## 容器技术概念入门篇 ##

## 05 | 白话容器基础（一）：从进程说开去 ##

容器本身没有价值，有价值的是“容器编排”。

1. 操作系统从“程序”中发现输入数据保存在一个文件中，所以这些数据就会被加载到内存中待命。时，操作系统又读取到了计算加法的指令，这时，它就需要指示 CPU 完成加法操作。而 CPU 与内存协作进行加法计算，又会使用寄存器存放数值、内存堆栈保存执行的命令和变量。同时，计算机里还有被打开的文件，以及各种各样的 I/O 设备在不断地调用中修改自己的状态。
2. 一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这**样一个程序运行起来后的计算机执行环境的总和，就是我们今天的主角：进程**。

*容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。*

对于 Docker 等大多数 Linux 容器来说，*Cgroups 技术*是用来制造约束的主要手段，而 *Namespace 技术*则是用来修改进程视图的主要方法。

1. 创建一个容器`$ docker run -it busybox /bin/sh`
2. 物理机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。
3.  Linux 里面的 Namespace 机制：使docker内的程序看不到它前面的其他进程，对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如PID=1。可实际上，它在宿主机的操作系统里还是原来第100进程。（Namespace）

	int pid = clone(main-function, stack_size, SIGCHLD, NULL); 系统调用就会为我们创建一个新的进程，并且返回它的进程号pid。

我们还可以多次执行上面的clone()，创建多个PID Namespace，而每个Namespace里的应用进程，都会认为自己是当前容器里的第1号进程，他们即看不到宿主机里真正的进程空间，也看不到其他PID Namespace里的具体情况。

*Linux 容器最基本的实现原理*。

*容器，其实是一种特殊的进程*。

### 总结 ###

跟真实存在的虚拟机不同，在使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。

这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程，只能看到各自 Mount Namespace 里挂载的目录和文件，只能访问到各自 Network Namespace 里的网络设备。

## 06 | 白话容器基础（二）：隔离与限制 ##

Namespace技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。（但对于宿主机来说）

*“敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细粒度的资源管理平台上大行其道的重要原因。*

有利有弊，基于Linux Namespace的隔离机制相比于虚拟化技术可能会出现：隔离不彻底

### 隔离不彻底 ###

1. 既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。意味着如果你要在 Windows 宿主机上运行 Linux 容器，或者在低版本的 Linux 宿主机上运行高版本的 Linux 容器，都是行不通的。
2. 在Linux内核中，有很多资源和对象是不呢功能被Namespace化的，最典型的例子就是：时间。

### 容器的“限制”问题 ###

虽然第 100 号进程表面上被隔离了起来，但是它所能够使用到的资源（比如 CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的。当然，这个 100 号进程自己也可能把所有资源吃光。这些情况，显然都不是一个“沙盒”应该表现出来的合理行为。

*Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。*

Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。

### 总结 ###

1. 介绍了容器使用 Linux Namespace 作为隔离手段的优势和劣势，对比了 Linux 容器跟虚拟机技术的不同，进一步明确了“容器只是一种特殊的进程”这个结论。
2. 其他的Namspace的操作
3. 通过 Linux Cgroups 实现资源的限制，并通过一系列简单的实验，模拟了 Docker 项目创建容器限制的过程

一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。

*容器是一个“单进程”模型*，


## 07 | 白话容器基础（三）：深入理解容器镜像 ##

Linux 容器最基础的两种技术：Namespace 和 Cgroups。Namespace 的作用是“隔离”，它让应用进程只能看到该 Namespace 内的“世界”；而 Cgroups 的作用是“限制”，它给这个“世界”围上了一圈看不见的墙。如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改，在容器里部署应用的时候，“什么能做，什么不能做”，就是用户必须考虑的一个问题。





**容器里的进程看到的文件系统又是什么样子的呢？**



实际上，Mount Namespace正是基于对chroot的不断改良才被发明出来的，它也是Linux操作系统里的第一个Namespace。

需要明确的是，rootfs知识一个操作系统所包含的文件、配置和目录，并不

### Kuberneters容器运行时 ###

### 总结 ###

通过结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。还有 chroot 和 pivot_root 这两个系统调用切换进程根目录的能力。通过结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。当然，这个功能的实现还必须感谢 chroot 和 pivot_root 这两个系统调用切换进程根目录的能力。

通过“分层镜像”的设计，以 Docker 镜像为核心，而且，由于容器镜像的操作是增量式的，这样每次镜像拉取、推送的内容，比原本多个完整的操作系统的大小要小得多；而共享层的存在，可以使得所有这些容器镜像需要的总空间，也比每个镜像的总和要小。

### 思考题 ###

1. 既然容器的 rootfs（比如，Ubuntu 镜像），是以只读方式挂载的，那么又如何在容器里修改 Ubuntu 镜像的内容呢？（提示：Copy-on-Write）
2. 除了 AuFS，你知道 Docker 项目还支持哪些 UnionFS 实现吗？你能说出不同宿主机环境下推荐使用哪种实现吗？

## 08 | 白话容器基础（四）：重新认识Docker容器 ##

分别从 Linux Namespace 的隔离能力、Linux Cgroups 的限制能力，以及基于 rootfs 的文件系统三个角度，为你剖析了一个 Linux 容器的核心实现原理。

	备注：之所以要强调 Linux 容器，是因为比如 Docker on Mac，以及 Windows Docker（Hyper-V 实现），实际上是基于虚拟化技术实现的，跟我们这个专栏着重介绍的 Linux 容器完全不同。

### 总结 ###

介绍了如何使用 Linux Namespace、Cgroups，以及 rootfs 的知识，对容器进行了一次庖丁解牛似的解读。

## 09 | 从容器到容器云：谈谈Kubernetes的本质 ##

一个“容器”，实际上是一个由 Linux Namespace、Linux Cgroups 和 rootfs 三种技术构建出来的进程的隔离环境。

从这个结构中我们不难看出，一个正在运行的 Linux 容器，其实可以被“一分为二”地看待：

1. 一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；
2. 一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。

在整个“开发 - 测试 - 发布”的流程中，真正承载着容器信息进行传递的，是容器镜像，而不是容器运行时。

*容器就从一个开发者手里的小工具，一跃成为了云计算领域的绝对主角；而能够定义容器组织和管理规范的“容器编排”技术，则当仁不让地坐上了容器技术领域的“头把交椅”*最具代表性的容器编排工作：

* Docker 公司的 Compose+Swarm 组合
* Google 与 RedHat 公司共同主导的 Kubernetes 项目

*首先，Kubernetes 项目要解决的问题是什么？*

* 对于大多数用户来说，他们希望 Kubernetes 项目带来的体验是确定的：现在我有了应用的容器镜像，请帮我在一个给定的集群上把这个应用运行起来。
* 还希望 Kubernetes 能给我提供路由网关、水平扩展、监控、备份、灾难恢复等一系列运维能力。

*Kubernetes 项目最主要的设计思想是，从更宏观的角度，以统一的方式来定义任务之间的各种关系，并且为将来支持更多种类的关系留有余地。*



## 10 | Kubernetes一键部署利器：kubeadm ##

*要真正发挥容器技术的实力，就不能仅仅局限于对Linux容器本身的钻研和使用。*这些知识更适合作为你的技术储备，以便在需要的时候可以帮你更快地定位问题，并解决问题。*如何使用这些技术来“容器化”你的应用。*

对于Cassandra这样的分布式，单单使用容器运行起来是没用的，要把 Cassandra 应用容器化的关键，在于如何处理好这些 Cassandra 容器之间的编排关系。比如，哪些 Cassandra 容器是主，哪些是从？主从容器如何区分？它们之间又如何进行自动发现和通信？Cassandra 容器的持久化数据又如何保持，等等。

反复强调 Kubernetes 项目的主要原因：这个项目体现出来的容器化“表达能力”，具有独有的先进性和完备性。这就使得它不仅能运行 Java Web 与 MySQL 这样的常规组合，还能够处理 Cassandra 容器集群等复杂编排问题。所以，对这种编排能力的剖析、解读和最佳实践，将是本专栏最重要的一部分内容。

目前，各大云厂商最常用的部署的方法，是使用 SaltStack、Ansible 等运维工具自动化地执行这些步骤。但即使这样，这个部署过程依然非常繁琐。因为，SaltStack 这类专业运维工具本身的学习成本，就可能比 Kubernetes 项目还要高。 

Kubernetes的功能那么多，这样一键部署出来的集群，能用于生产环境吗？

*kubeadm。*

### kubeadm的工作原理 ###

### 总结 ###

kubeadm 这个部署工具的工作原理和使用方法，使用它一步步地部署一个完整的 Kubernetes 集群。

## 13 | 为什么我们需要Pod？ ##

Pod，是Kubernetes项目中最小的API对象。Pod，是Kubernetes项目的原子调度单位。

Namespace做隔离，Cgroups做限制，rootfs做文件系统。为什么Kubernetes项目又突然搞出一个Pod来呢？

容器的本质是进程。

已知rsyslogd由三个进程组成：一个imklog模块，一个imuxsock模块，一个rsyslogd自己的main函数主进程。这三个进程一定要运行再同一个机器上。

容器的“单进程模型”，并不是指容器里职能进行“一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里PID=1的进程就是应用本身，其他的进程都是这个PID=1进程的子进程。

	docker run main 
	docuer run imklog
	docker run imuxsock

Pod是Kubernetes里的原子调度单位。Kubernetes项目的调度器，是统一按照Pod而非容器的资源需求进行计算的。

容器设计模式，Pod的实现原理

1. 关于Pod最重要的一个事实是：它知识一个逻辑概念

Pod里的所有容器，共享的是同一个Network Namspace，并且可以声明共享同一个Volume。

对于Pod里的容器A和容器B来说：

* 可以直接使用localhost进行通信；
* 看到的网络设备跟Infra容器看到的完全一样；
* 一个Pod只有一个IP地址，也就这个Pod的Network Namespace对应的IP地址；
* 其他的网络资源，都是一个Pod一份，并且被该Pod中的所有容器共享；
* Pod的生命周期只跟Infra容器一致，而与容器A和B无关。

将来如果你要为Kubernetes开发一个网络插件时，应该重点考虑的是如何配置这个Pod的Network Namespace，而不是每一个用户容器如何使用你的网络配置，这是没有意义的。

## 45 | 幕后英雄：SIG-Node与CRI ##

