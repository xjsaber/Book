# 深入剖析Kubernetes #

课前必读

## 开篇词 | 打通“容器技术”的任督二脉 ##

从过去以物理机和虚拟机为主体的开发运维环境，向以容器为核心的基础设施的转变过程，并不是一次温和的改革，而是涵盖了对网络、存储、调度、操作系统、分布式原理等各个方面的容器化理解和改造。

四大模块：

1. “白话”容器技术基础
2. Kubernetes 集群的搭建与实践
3. 容器编排与 Kubernetes 核心特性剖析
4. Kubernetes 开源社区与生态

### 精选留言 ###

#### 1 ####

如果拿汽车来做比:
Docker好比汽车引擎，
Dockerfile相当于汽车蓝图，
Docker image(镜像)就是汽车样板，
Docker container(容器)类似于汽车的零部件，
Docker Registry可以看作是4s店，
Docker Compose就像老司机,
Docker Volume就像是汽车的油箱, 如果把容器间内的io数据流比喻成汽油,
Docker Swarm(或者K8s)就是交通枢纽。

#### 2 ####

您提到: kubernetes更关注容器与编排，在资源管理方面优势不大。但正确的姿势，是用好kubernetes 可扩展能力，让它跟yarn等一起都发挥出真正的实力。国内阿里和蚂蚁在这一块走得不错。
强烈跪求讲一下如何弥补k8s的资源管理缺点，与yarn结合 这方面的知识与经验！！！

## 01 | 预习篇.小鲸鱼大事记（一）：初出茅庐 ##

PaaS 项目被大家接纳的一个主要原因，就是它提供了一种名叫“应用托管”的能力。 

## 02 | 预习篇.小鲸鱼大事记（二）：崭露头角 ##

## 03 | 预习篇.小鲸鱼大事记（二）：群雄并起 ##

## 04 | 预习篇.小鲸鱼大事记（二）：尘埃落定 ##

## 容器技术概念入门篇 ##

## 05 | 白话容器基础（一）：从进程说开去 ##

容器本身没有价值，有价值的是“容器编排”。

1. 操作系统从“程序”中发现输入数据保存在一个文件中，所以这些数据就会被加载到内存中待命。时，操作系统又读取到了计算加法的指令，这时，它就需要指示 CPU 完成加法操作。而 CPU 与内存协作进行加法计算，又会使用寄存器存放数值、内存堆栈保存执行的命令和变量。同时，计算机里还有被打开的文件，以及各种各样的 I/O 设备在不断地调用中修改自己的状态。
2. 一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这**样一个程序运行起来后的计算机执行环境的总和，就是我们今天的主角：进程**。

*容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。*

对于 Docker 等大多数 Linux 容器来说，*Cgroups 技术*是用来制造约束的主要手段，而 *Namespace 技术*则是用来修改进程视图的主要方法。

1. 创建一个容器`$ docker run -it busybox /bin/sh`
2. 物理机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。
3.  Linux 里面的 Namespace 机制：使docker内的程序看不到它前面的其他进程，对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如PID=1。可实际上，它在宿主机的操作系统里还是原来第100进程。（Namespace）

	int pid = clone(main-function, stack_size, SIGCHLD, NULL); 系统调用就会为我们创建一个新的进程，并且返回它的进程号pid。

我们还可以多次执行上面的clone()，创建多个PID Namespace，而每个Namespace里的应用进程，都会认为自己是当前容器里的第1号进程，他们即看不到宿主机里真正的进程空间，也看不到其他PID Namespace里的具体情况。

*Linux 容器最基本的实现原理*。

*容器，其实是一种特殊的进程*。

### 总结 ###

跟真实存在的虚拟机不同，在使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。

这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程，只能看到各自 Mount Namespace 里挂载的目录和文件，只能访问到各自 Network Namespace 里的网络设备。

## 06 | 白话容器基础（二）：隔离与限制 ##

Namespace技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。（但对于宿主机来说）

*“敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细粒度的资源管理平台上大行其道的重要原因。*

有利有弊，基于Linux Namespace的隔离机制相比于虚拟化技术可能会出现：隔离不彻底

1. 既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。
2. 在Linux内核中，有很多资源和对象是不呢功能被Namespace化的，最典型的例子就是：时间。

## 07 | 白话容器基础（三）：深入理解容器镜像 ##

Namespace和Cgroups

实际上，Mount Namespace正是基于对chroot的不断改良才被发明出来的，它也是Linux操作系统里的第一个Namespace。

需要明确的是，rootfs知识一个操作系统所包含的文件、配置和目录，并不

## Kuberneters容器运行时 ##

## 总结 ##

## 08 | 白话容器基础（四）：重新认识Docker容器 ##

分别从 Linux Namespace 的隔离能力、Linux Cgroups 的限制能力，以及基于 rootfs 的文件系统三个角度，为你剖析了一个 Linux 容器的核心实现原理。

	备注：之所以要强调 Linux 容器，是因为比如 Docker on Mac，以及 Windows Docker（Hyper-V 实现），实际上是基于虚拟化技术实现的，跟我们这个专栏着重介绍的 Linux 容器完全不同。

### 总结 ###

介绍了如何使用 Linux Namespace、Cgroups，以及 rootfs 的知识，对容器进行了一次庖丁解牛似的解读。

## 09 | 从容器到容器云：谈谈Kubernetes的本质 ##

一个“容器”，实际上是一个由 Linux Namespace、Linux Cgroups 和 rootfs 三种技术构建出来的进程的隔离环境。

一个正在运行的Linux容器，其实可以被“一分为二”地看待：

1. 一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；
2. 一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。



## 10 | Kubernetes一键部署利器：kubeadm ##

*要真正发挥容器技术的实力，就不能仅仅局限于对Linux容器本身的钻研和使用。*这些知识更适合作为你的技术储备，以便在需要的时候可以帮你更快地定位问题，并解决问题。*如何使用这些技术来“容器化”你的应用。*

对于Cassandra这样的分布式，单单使用容器运行起来是没用的，要把 Cassandra 应用容器化的关键，在于如何处理好这些 Cassandra 容器之间的编排关系。比如，哪些 Cassandra 容器是主，哪些是从？主从容器如何区分？它们之间又如何进行自动发现和通信？Cassandra 容器的持久化数据又如何保持，等等。

反复强调 Kubernetes 项目的主要原因：这个项目体现出来的容器化“表达能力”，具有独有的先进性和完备性。这就使得它不仅能运行 Java Web 与 MySQL 这样的常规组合，还能够处理 Cassandra 容器集群等复杂编排问题。所以，对这种编排能力的剖析、解读和最佳实践，将是本专栏最重要的一部分内容。

目前，各大云厂商最常用的部署的方法，是使用 SaltStack、Ansible 等运维工具自动化地执行这些步骤。但即使这样，这个部署过程依然非常繁琐。因为，SaltStack 这类专业运维工具本身的学习成本，就可能比 Kubernetes 项目还要高。 

Kubernetes的功能那么多，这样一键部署出来的集群，能用于生产环境吗？

*kubeadm。*

### kubeadm的工作原理 ###

## 13 | 为什么我们需要Pod？ ##

Pod，是Kubernetes项目中最小的API对象。Pod，是Kubernetes项目的原子调度单位。

Namespace做隔离，Cgroups做限制，rootfs做文件系统。为什么Kubernetes项目又突然搞出一个Pod来呢？

容器的本质是进程。

已知rsyslogd由三个进程组成：一个imklog模块，一个imuxsock模块，一个rsyslogd自己的main函数主进程。这三个进程一定要运行再同一个机器上。

容器的“单进程模型”，并不是指容器里职能进行“一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里PID=1的进程就是应用本身，其他的进程都是这个PID=1进程的子进程。

	docker run main 
	docuer run imklog
	docker run imuxsock

Pod是Kubernetes里的原子调度单位。Kubernetes项目的调度器，是统一按照Pod而非容器的资源需求进行计算的。

容器设计模式，Pod的实现原理

1. 关于Pod最重要的一个事实是：它知识一个逻辑概念

Pod里的所有容器，共享的是同一个Network Namspace，并且可以声明共享同一个Volume。

对于Pod里的容器A和容器B来说：

* 可以直接使用localhost进行通信；
* 看到的网络设备跟Infra容器看到的完全一样；
* 一个Pod只有一个IP地址，也就这个Pod的Network Namespace对应的IP地址；
* 其他的网络资源，都是一个Pod一份，并且被该Pod中的所有容器共享；
* Pod的生命周期只跟Infra容器一致，而与容器A和B无关。

将来如果你要为Kubernetes开发一个网络插件时，应该重点考虑的是如何配置这个Pod的Network Namespace，而不是每一个用户容器如何使用你的网络配置，这是没有意义的。

## 45 | 幕后英雄：SIG-Node与CRI ##

