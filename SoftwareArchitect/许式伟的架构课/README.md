# 许式伟的架构课 #

开篇词

## 开篇词 | 怎样成长为优秀的软件架构师？ ##

那怎么才能成长为优秀的软件架构师？软件架构师和软件工程师最根本的差别又在哪里？我认为关键在于四个字：掌控全局。

基础平台篇

## 01 | 架构设计的宏观视角 ##

### 为什么需要建立宏观视角？ ###

**我们的整个专栏内容也会从基础架构开始讲起，最后逐步过渡到业务架构，到最终完成一个完整应用程序的设计过程。**

从基础架构开始，逐渐来解剖一个应用程序的整体构成

### 应用程序的基础架构 ###

#### 我们想学习一个程序的基础架构，其实就是弄清楚电脑的工作原理，以及程序的运行原理。 ####

所有的电脑都可以统一看作由“**中央处理器 + 存储 + 一系列的输入输出设备**”构成。

中央处理器，也就是我们平常说的 CPU，负责按指令执行命令；存储负责保存数据，包括我们要执行的命令，也是以数据形式保存在存储中的。

每次在打开电脑的电源后，中央处理器都会从存储的某个固定位置处开始读入数据（也就是指令），并且按指令执行命令，执行完一条指令就会继续执行下一条指令。电脑就这样开始工作了。

**那这么简单的话，为何电脑能够完成这么多复杂而多样化的工作？**这整个过程，在我看来主要依赖两点。

1. **第一是可编程性。**大体来说，中央处理器（CPU）的指令分为如下这几类。
	* 计算类，也就是支持我们大家都熟知的各类数学运算，如加减乘除、sin/cos 等等。
	* I/O 类，（从存储读写数据）从输入输出设备读数据、写数据。
	* 指令跳转类，在满足特定条件下跳转到新的当前程序执行位置。
2. **第二是开放设计的外部设备支持。**虽然我们电脑可以连接非常非常多种类的外部设备

从上面可以看出，**电脑的 CPU 是一个非常简洁的模型，它只读入和写出数据，对数据进行计算**。

#### 有了这个基础的计算机体系之后，我们就可以编写软件了。 ####

1. 第一个问题是**直接用机器指令编写软件太累，而且这些机器指令像天书一样没人看得懂，没法维护**。
	* 编程语言 + 编译器：编译器负责把我们人类容易理解的语言，转换为机器可以理解的机器指令，这样一来就大大解放了编写软件的门槛。
2. 我们遇到的第二个问题，**就是多个软件在同一个电脑上怎么共处。多个软件大家往同一个存储地址写数据冲突怎么办？一起往打印机去发送打印指令怎么办？有的软件可能偷偷搞破坏怎么办？**
	* **操作系统**，它首先要解决的是软件治理的问题。操作系统其次解决的是基础编程接口问题。

基础架构解决的是与业务无关的一些通用性的问题，这些问题往往无论你具体要做什么样的应用都需要面对。而且，基础架构通常以独立的软件存在，所以也称为基础软件。

### 完整的程序架构是怎样的？ ###

### 结语 ###

**可能有人看到今天的内容心里会有些担心：“原来架构师要学这么多东西，看来我离成为架构师好远。”**

**而架构能力的提升，本质上是对你的知识脉络（全身经络）的反复梳理与融会贯通的过程。**

这就像你没有从事云计算行业，但是你仍然需要理解云计算的本质，需要驾驭云计算。你也不必去做出一个浏览器，但是你需要理解它们的思考方式，因为你在深度依赖于它们。

## 02 | 大厦基石：无生有，有生万物 ##

### 解剖架构的关键点是什么？ ###

**我们应该如何去分析架构设计中涉及的每一个零部件。换一句话说，当我们设计或分析一个零部件时，我们会关心哪些问题。**

1. 第一个问题，是需求。

2. 第二个问题，是规格。 

### 为“解决一切的问题”而生 ###

### 结语 ###

我们近距离地去解剖了整个信息世界地基：冯·诺依曼体系结构。

冯·诺依曼体系结构的不凡之处在于，它想“解决一切可以用‘计算’来解决的问题”。

为了实现这个目标，冯·诺依曼引入了三类基础零部件：中央处理器、存储、输入输出设备。所有计算机都可以看做由 “中央处理器 + 存储 + 一系列的输入输出设备” 构成。

## 03 | 汇编：编程语言的诞生 ##

## 04 | 编程语言的进化 ##

## 05 | 思考题解读：如何实现可自我迭代的计算机 ##

## 06 | 操作系统进场 ##

## 10 | 输入和输出设备：交互的演进 ##

### 交互的演进 ###

1. 打孔机 + 打印机
2. 键盘 + 显示器

| 时期 | 输入设备 | 输出设备 |
| --- | --- | --- |
| “史前”时期 | 打孔卡 | 打印机 |
| 字符界面时期 | 键盘 | 显示器 |
| 图形界面时期 | 键盘+鼠标 | 显示器+音箱 |
| 移动时期 | 触摸屏+麦克风 | 触摸屏+内置扬声器 |
| IoT萌芽期（纯语音） | 麦克风 | 内置扬声器 |
| 拟真交互（可能的未来） | 摄像头+麦克风 | VR |

人机交互在往越来越自然的方向发展。所谓自然，就是越来越接近于两个人直接的面对面沟通。

### 输入设备 ###

输入设备：键盘、鼠标、麦克风、摄像头

#### 键盘 ####

键盘从功能上来说，有两个不同的能力：

1. 输入文本
2. 触发命令

#### 鼠标 ####

#### 麦克风 ####

交互方式不管怎么变化，其核心需要实现的都是这样的两大能力：输入文本和触发命令，这一点是不变的。

#### 摄像头 ####

### 输出设备 ###

输出设备主要负责向用户反馈信息。比如：显示器（显卡）、音箱（声卡）、打印机。

#### 显示器 ####

显示器经历了CRT到液晶屏多代更新，但从操作系统的软件治理角度来看，显示器没有发生实质性的变化。

* 窗口系统
* 绘制子系统

**窗口系统**

**绘制子系统**

在操作系统里面，往往有一个独立的子系统（通常叫 GDI）与之对应。这里我们简单罗列一下 GDI 子系统会涉及哪些东西。

* 2D图形相关。包含 Path(路径)、Brush(画刷)、Pen(画笔) 等概念。
* 3D图形相关。包含 Model(模型)、Material(材质)、Lighting(光照) 等概念。
* 文本相关。包含 Font(字体) 等概念。而字体又分点阵字体和 TrueType 字体。TrueType 字体的优势是可以自由缩放。今天我们见到的大部分字体都是 TrueType 字体。
* 图像处理相关。包含 Bitmap(位图) 对象及常见图像格式的编解码器 (Encoder/Decoder)。

视窗软件：窗口系统结合输入设备对应的事件管理系统、绘制 (GDI) 系统。

操作系统往往还提供了一些通用的界面元素，通常我们称之为控件 (Control)。常见的控件有如下这些：

* 静态文本 (Label)；
* 按钮 (Button)；
* 单选框 (RadioBox)；
* 复选框 (CheckBox)；
* 输入框 (Input，也叫 EditBox/EditText)；
* 进度条 (ProgressBar)；等等。

如果你希望一份代码多平台使用，在这方面就需要谨慎处理。

#### 音箱 ####

#### 打印机 ####

### 结语 ###

事实上输入意图的理解越来越难了，因为交互在朝着自然（Nature）和智能（Intelligence）的方向发展。我们不可能让每一个软件都自己去做输入意图的理解（今天的现状是每个软件自己做），在未来，必然将由操作系统来实现智能交互的基础架构。

## 11 | 多任务：进程、线程与协程 ##

### 多任务与执行体 ###

我们先从物理层面看。最早期的 CPU 基本上都是单核的，也就是同一时间只能执行一条指令。

物理层面的多任务，有两个方法：**一个是多颗 CPU，一个是单颗 CPU 多个核心**。

但如果我们实际就只有一个单核的 CPU，是否就没办法实现多任务呢？

当然可以。方法是把 CPU 的时间切成一段段时间片，每个时间片只运行某一个软件。这个时间片给软件 A，下一个时间片给软件 B。因为时间片很小，我们会感觉这些软件同时都在运行。这种分时间片实现的多任务系统，我们把它叫分时系统。

分时系统的原理说起来比较简单，把当前任务状态先保存起来，把另一个任务的状态恢复，并把执行权交给它即可。这里面涉及的问题有：

* 任务是什么，怎么抽象任务这样一个概念；
* 任务的状态都有什么？怎么保存与恢复；
* 什么时机会发生任务切换？

从今天的现实看，任务的抽象并不是唯一的。大部分操作系统提供了两套：进程和线程。有的操作系统还会提供第三套叫协程（也叫纤程）。

所谓**执行体**，是指可被 CPU 赋予执行权的对象，它至少包含下一个执行位置（获得执行权后会从这里开始执行）以及其他的运行状态。

从 CPU 的角度，执行程序主要依赖的是内置存储：寄存器和内存（RAM），它们构成执行体的上下文。

1. 先看**寄存器**。寄存器的数量很少且可枚举，我们直接通过寄存器名进行数据的存取。（软件 A 切换到软件 B 的时候，要把软件 A 所有用到的寄存器先保存起来（以便后续轮到软）
2. 我们再看**内存（RAM）**。CPU 在实模式和保护模式下的内存访问机制完全不同，我们分别进行讨论。
	1. 在实模式下，多个执行体同在一个内存地址空间，相互并无干扰（非恶意情况下）。
	2. 在保护模式下，不同任务可以有不同的地址空间，它主要通过不同的地址映射表来体现。
		* 怎么切换地址映射表？也是寄存器。

执行体的上下文，就是一堆寄存器的值。要切换执行体，只需要保存和恢复一堆寄存器的值即可。

### 进程与线程 ###

![bf0720da6789e599daf672e1db04058a.jpg](img/bf0720da6789e599daf672e1db04058a.jpg)

进程是操作系统从安全角度来说的隔离单位，不同进程之间基于最低授权的原则。

在创建一个进程这个事情上，用的是 fork（分叉）语义。所谓 fork，就是先 clone 然后再分支，父子进程各干各的。这样创建进程很讨巧，不用传递一堆的参数，使用上非常便利。但我认为从架构设计的角度，这是 UNIX 操作系统设计中最糟糕的 API，没有之一。

为什么进程 fork 是糟糕的？这是因为：进程是操作系统最基本的隔离单元，我们怕的就是摘不清楚，但是 fork 偏偏要藕断丝连。

线程的出现，则是因为操作系统发现同一个软件内还是会有多任务的需求，这些任务处在相同的地址空间，彼此之间相互可以信任。

早期操作系统中没有线程的概念，也不会有人想到要搞两套执行体。所以进程实际上承担了一部分来自线程的需求：我需要父进程的环境。

### 协程与 goroutine ###

协程并不是操作系统内核提供的，它有时候也被称为用户态线程。这是因为协程是在用户态下实现的。

答案是因为实现高性能的网络服务器的需要。对于常规的桌面程序来说，**进程 + 线程绰绰有余**。 但对于一个网络服务器，我们可以用下面这个简单的模型看它：

对网络服务器来说，大量的来自客户端的请求包和服务器的返回包，都是网络 IO；在响应请求的过程中，往往需要访问存储来保存和读取自身的状态，这也涉及本地或网络 IO。

如果这个网络服务器有很多客户，那么整个服务器就充斥着大量并行的 IO 请求。

操作系统提供的标准网络 IO 有以下这些成本：

* 系统调用机制产生的开销；
* 数据多次拷贝的开销（数据总是先写到操作系统缓存再到用户传入* * 的内存）；
* 因为没有数据而阻塞，产生调度重新获得执行权，产生的时间成本；
* 线程的空间成本和时间成本（标准 IO 请求都是同步调用，要想 IO 请求并行只能使用更多线程）。

### 架构师的批判性思维 ###

多任务的需求非常复杂。

为了满足需要，人们不只发明了三套执行体：进程、线程和协程，还发明了各种五花八门的执行体间的通讯机制。

* 对 CPU 而言，统一的、接口一致的输入输出设备
* 到了操作系统这里，它需要依据每一种设备的需求特性，抽象出对应的更加用户友好的使用接口。

### 结语 ###

多任务，以及多任务代带来的复杂需求，由此介绍了进程、线程和协程等三套执行体的设计。

## 12 | 进程内协同：同步、互斥与通讯 ##

考虑到进程内的执行体有两类：用户态的协程（以 Go 语言的 goroutine 为代表）、操作系统的线程，我们对这两类执行体的协同机制做个概要。

![575d31c0ebf3f4a6148a211387bdae1b.jpg](img/575d31c0ebf3f4a6148a211387bdae1b.jpg)

### 原子操作 ###

首先让我们看一下原子操作。需要注意的是，原子操作是 CPU 提供的能力，与操作系统无关。这里列上只是为了让你能够看到进程内通讯的全貌。

原子操作的每一个操作都是原子的，不会中途被人打断，这个原子性是 CPU 保证的，与执行体的种类无关，无论 goroutine 还是操作系统线程都适用。

### 执行体的互斥 ###

互斥体也叫锁。锁用于多个执行体之间的互斥访问，避免多个执行体同时操作一组数据产生竞争。

	func (m *Mutex) Lock()
	func (m *Mutex) Unlock()

锁的使用范式比较简单：在操作需要互斥的数据前，先调用 Lock，操作完成后就调用 Unlock。

那么锁的问题在哪里？锁的最大问题在于不容易控制。

1. 锁 Lock 了但是忘记 Unlock 后是灾难性的，因为相当于服务器挂了，所有和该锁相关的代码都不能被执行。
2. 锁不容易控制的另一个表现是锁粒度的问题。（**不要在锁里面执行费时操作**）

#### 在锁的最佳编程实践中 ####

在锁的最佳编程实践中，如果明确一组数据的并发访问符合 “绝大部分情况下是读操作，少量情况有写操作” ，这种 “读多写少” 特征，那么应该用读写锁。

所谓读写锁，是把锁里面的操作分为读操作和写操作两种，对应调用不同的互斥操作。

读操作：
	
	mutex.RLock()
	defer mutex.RUnlock()
	doReadOnlyThings

写操作，代码就是和普通锁一样

	mutex.Lock()
	defer mutex.Unlock()
	doWriteThings

整体来说，读写锁的特性是：

* 读操作不阻止读操作，阻止写操作；
* 写操作阻止一切，不管读操作还是写操作。

### 执行体的同步 ###

同步的一个最常见的场景是：把一个大任务分解为 n 个小任务，分配给 n 个执行体并行去做，等待它们一起做完。这种同步机制我们叫 “等待组”。

其使用界面上大概是这样的：

	func (wg *WaitGroup) Add(n int)
	func (wg *WaitGroup) Done()
	func (wg *WaitGroup) Wait()



## 13 | 进程间的同步互斥、资源共享与通讯 ##

## 14 | IP网络：连接世界的桥梁 ##

### 数据的封包过程 ###

网络协议是计算机与计算机远程沟通的数据格式。

网络协议有 OSI 模型，它把网络协议分成了七层结构，从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

![6059e45af9f2ff757fa64df2ec48212a.png](img/6059e45af9f2ff757fa64df2ec48212a.png)

1. 第一步，分批次。从物理网络视角看，数据并不是流（stream），而是一个个大小有明确限制的数据包。
2. 第二步，套上信封，写好寄件单位的部门（源端口号）、收件单位的部门（目标端口号）、批次编号。
	* 端口号：方便知道由谁（哪个应用程序软件）来负责收件
	* 批次编号：是为了防止寄丢了，寄丢了就得重新传一份该批次编号的东西。
	* 传输层主要解决传输可靠性的问题。传输层有两套协议（两种信封），TCP协议和UDP协议。UDP 协议不保证对方一定收到，信封上就没写批次编号。
3. 第三步，再套上一层信封，上面写上寄件单位地址（源 IP 地址）、收件单位地址（目标 IP 地址）。定义信封的格式，叫IP协议。
	* IP 协议最核心的意义是标准化，解决跨物流公司传输的问题。
4. 再套上一层信封，这层我们叫它数据链路层。
	* 数据链路层的信封格式（网络协议）非常多样化。
	* 当信件从一个物流公司转到另一个物流公司做交接的时候，这一层信封拆掉，重新换上新的信封。
5. 写完了特定物流公司所需要的信息，信件就可以进入数字物流系统（物理层）去流转了。

### 网络协议 ###

协议的用途：

1. 首先是 DNS 协议。主要负责 “域名” => “IP 地址” 的查询。
2. 其次是 DHCP 协议。DHCP 全称叫动态主机配置协议（Dynamic Host Configuration Protocol），主要负责计算机接入网络时的初始化。计算机刚开始就只有网卡的 MAC 地址，通过 DHCP 可以给它分配 IP 地址，并得到默认网关地址（这很重要，不知道网关就上不了网）和 DNS 服务器的地址。
3. 然后是 ARP 协议。ARP 全称叫地址解析协议（Address Resolution Protocol），它服务于现在局域网中最流行的以太网协议。
4. 然后是 RARP 协议。RARP 全称叫反向地址转换协议（Reverse Address Resolution Protocol）。
5. 然后是 ICMP 协议。ICMP 全称叫互联网控制报文协议（Internet Control Message Protocol），它能够检测网路的连线状况，以保证连线的有效性。
	* ping 
	* traceroute
	* 基于这个协议实现，用来判断和定位网络问题。
6. 最后是 IGMP 协议。IGMP 全称叫互联网组管理协议（Internet Group Management Protocol），它负责 IP 组播（Multicast）成员管理。


## 15 | 可编程的互联网世界 ##



## 16 | 安全管理：数字世界的守护 ##

## 17 | 架构：需求分析（上） ##




桌面开发篇

## 20 | 桌面开发的宏观视角 ##

### 命令行交互 ###



服务端开发篇

## 34 | 服务端开发的宏观视角 ##

### 服务端的发展史 ###



### 服务端程序的需求 ###

#### 1. 规模 ####

* 桌面程序是为单个用户服务的，所以它关注点是用户交互体验的不断升级。
* 服务端程序是被所有用户所共享，为所有用户服务的。一台物理的机器资源总归是有限的，能够服务的用户数必然存在上限，所以一个服务端程序在用户规模到达一定程度后，需要分布式化，跑在多台机器上以服务用户。

#### 2. 连续服务时长 ####

* 桌面程序是为单个用户服务的，用户在单个桌面程序的连续使用时长通常不会太长。
* 但是服务端程序不同，它通常都是 7x24 小时不间断服务的。当用户规模达到一定基数后，每一秒都会有用户在使用它，不存在关闭程序这样的概念。

#### 3. 质量要求。 ####

* 每个桌面程序的实例都是为单个用户服务的，有一亿的用户就有一亿个桌面程序的实例。
* 但是服务端程序不同，不可能有一亿个用户就跑一亿个，每个用户单独用一个，而是很多用户共享使用一个程序实例。

这意味着两者对程序运行崩溃的容忍度不同。

* 一个桌面程序实例运行崩溃，它只影响一个用户。
* 但一个服务端程序实例崩溃，可能影响几十万甚至几百万的用户。

所以，服务端程序必须是多实例的。单个程序实例的临时不可用状态，要做到用户无感知。

### 服务端开发的体系架构 ###

相比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类：

* 负载均衡（Load Balance）；
* 数据库或其他形式的存储（DB/Storage）。

### 结语 ###

就像桌面的领域特征是强交互，以事件为输入，GDI 为输出一样，服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。

这些领域特征直接导致了服务端开发的体系架构和桌面必然是如此的不同。

## 35 | 流量调度和负载均衡 ##

比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类：

* 负载均衡（Load Balance）；
* 数据库或其他形式的存储（DB/Storage）。

为什么会需要负载均衡（Load Balance）？今天我们就聊一下有关于流量调度与负载均衡的那些事情。

什么是 “流量调度”？我们首先要了解这样几个常见的服务端程序运行实例（进程）相关的概念：

* 连接数；
* IOPS；
* 流量，入向流量和出向流量。

一个基本的服务端程序的服务请求，通常是由一个请求包（Request）和一个应答包（Response）构成。这样一问一答就是一次完整的服务。

连接数，有时候也会被称为并发数，指的是同时在服务中的请求数。也就是那些已经发送请求（Request），但是还没有收完应答（Response）的请求数量。

IOPS，指的是平均每秒完成的请求（一问一答）的数量。它可以用来判断服务端程序的做事效率。

流量分入向流量和出向流量。入向流量可以这么估算：

* 平均每秒收到的请求包（Request）数量 * 请求包平均大小。

同样的，出向流量可以这么估算：

* 平均每秒返回的应答包（Response）数量 * 应答包平均大小。

不考虑存在无效的请求包，也就是存在有问无答的情况（但实际生产环境下肯定是有的）的话，那么平均每秒收到的请求包（Request）数量、平均每秒返回的应答包（Response）数量就是 IOPS。故此：

* 入向流量 ≈ IOPS * 请求包平均大小
* 出向流量 ≈ IOPS * 应答包平均大小

所谓流量调度，就是把海量客户并发的请求包按特定策略分派到不同的服务端程序实例的过程。

### DNS 流量调度 ###

一个域名通过 DNS 解析到多个 IP，每个 IP 对应不同的服务端程序实例。这样就完成了流量调度。这里我们没有用到常规意义的负载均衡（Load Balance）软件，但是我们的确完成了流量调度。

#### 第一个问题，是升级不便 ####

#### 第二个问题，是流量调度不均衡。 ####

### 网络层负载均衡 ###

在网络层（IP 层）做负载均衡。负载均衡软件 LVS（Linux Virtual Server）就工作在这一层。

LVS 支持三种调度模式。

* 




服务治理篇

架构思维篇

软件工程篇

延展阅读

结束语

## 结束语 | 放下技术人的身段，用极限思维提升架构能力 ##

传统的架构图书往往从架构思维开始。但是，我认为它们错了。这里面最关键的问题在于：

*架构并不是 “知识点”。*

架构思维的确非常非常重要。但是，熟读架构思维并不足以让人成为一名优秀的架构师。

武功招式可以精确传授，是 “知识点”，掌握了就是掌握了，理论上可以做到分毫不差。但是，架构不是武功招式。它更像内功，它不是 0 和 1，没有清晰的掌握和没有掌握这样泾渭分明的区别。

### 在架构能力上，没有最好，只有更好。 ###

这是为什么我们的架构课并不是从架构思维开始，而是采用双线结构。它基本上围绕着以下两个脉络主线来展开内容：

* 如何从零开始一步步构建出整个信息世界；
* 在整个信息世界的构建过程中，都用了哪些重要的架构思维范式，以及这些范式如何去运用于你平常的工程实践中。

这两大脉络相辅相成。

1. 通过还原信息世界的构建过程，剥离出了整个信息世界的核心骨架，这也是最真实、最宏大的架构实践案例。
2. 结合这个宏大的架构实践来谈架构思维，避免因对架构思维的阐述过于理论化而让人难以理解。
3. 架构就是对业务系统的正交分解。因此，整个信息科技的演化过程，自然而然形成了分层：基础架构 + 业务架构。

基础架构的产生是对业务架构不断深入理解的过程。越来越多的共性需求从业务架构抽离出来，成为信息科技的基础设施。

作为架构师，我们需要坚持对业务进行正交分解的信念，要坚持不断地探索各类需求的架构分解方法。这样的思考多了，我们就逐步形成了各种各样的架构范式。

这些架构范式，并不仅仅是一些架构思维，而是 “一个个业务只读、接口稳定、易于组合的模块 + 组合的方法论”，它们才是架构师真正的武器库。

这个武器库包含哪些内容？

1. 首先，它应该包括信息科技形成的基础架构：
	1. 其一，基础平台。包括：冯·诺依曼体系、编程语言、操作系统。
	2. 其二，桌面开发平台。包括：窗口系统、GDI 系统、浏览器与小程序。当然我们也要理解桌面开发背后的架构逻辑，MVC 架构。
	3. 其三，服务端开发平台。包括：负载均衡、各类存储中间件。服务端业务开发的业务逻辑比桌面要简单得多。服务端难在如何形成有效的基础架构，其中大部分是存储中间件。
	4. 其四，服务治理平台。主要是以容器技术为核心的 DCOS（数据中心操作系统），以及围绕它形成的整个服务治理生态。这一块还在高速发展过程中，最终它将让服务端开发变得极其简单。
2. 架构师需要放下技术人的身段，学会 “共情”。与用户共情，理解用户的所思所想。与开发人员共情，理解技术人的所思所想。与公司共情，理解公司的发展诉求。
3. 实践对架构能力不可或缺。
	1. 要提升架构能力，首先得做到规格为先，而不是实现为先。不要动不动问怎么实现的。要首先谈这个规格合不合理，是否存在多余的依赖。进一步来说，要多去谈这个函数（或软件实体）的业务范畴合不合理，是否应该换一个切分的姿势。
	2. 其实 review 自己的代码也是一种极佳的架构能力的提升手段。对自己刚刚写完的代码，去 review 它，从中找出问题。如此反复训练，就能实现自我能力的提升。
	3. 很多人追逐实现新的业务系统，通过做新系统来找到满足感。但是实际上对架构师来说，恰恰是反复打磨既有系统是更加锻炼人的。如果你一年前实现的系统今天仍然很满意，那就需要警醒，因为这一年你在原地踏步。

### 在架构能力上，没有最好，只有更好。 ###

架构没有最好，只有更好。在极有限的上机时间里，在没有电脑的情况下，我们只能选择把更多的逻辑装进脑子里。

这个过程还可以更进一步。我们不断训练自己对不同业务领域的架构范式的理解。直至最终，我们头脑中可以装得下整个信息科技的骨架。

到那时，单就架构能力而言，你就是最顶级的架构师了。