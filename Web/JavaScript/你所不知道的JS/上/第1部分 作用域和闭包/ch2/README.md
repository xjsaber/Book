# 第二章 词法作用域 #

作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫作动态作用域，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。

## 2.1 词法阶段 ##

大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。

	function foo(a) {
		var b = a * 2;
		function bar(c) {
			console.log(a, b, c);
		}
		bar(b * 3);
	}
	foo(2); //2, 4, 12
1. 包含这整个全局作用域，其中只有一个标识符：foo。
2. 包含着foo所创建的作用域，其中有三个标识符：a、bar和b。
3. 包含着baar所创建的作用域，其中只有一个标识符：c。

作用域气泡由其对应的作用域块代码写在哪里决定的，它们是逐级包含的。

**查找**

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息查找标识符的位置。

引擎执行 console.log(..) 声明，并查找 a 、 b 和 c 三个变量的引
用。它首先从最内部的作用域，也就是 bar(..) 函数的作用域气泡开始查找。引擎无法在这里找到 a ，因此会去上一级到所嵌套的 foo(..) 的作用域中继续查找。在这里找到了 a ，因此引擎使用了这个引用。对 b 来讲也是一样的。而对 c 来说，引擎在 bar(..) 中就找到了它。

如果 a 、 c 都存在于 bar(..) 和 foo(..) 的内部， console.log(..) 就可以直接使用 bar(..)中的变量，而无需到外面的 foo(..) 中查找。

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

词法作用域查找只会查找一级标识符，比如 a 、 b 和 c 。如果代码中引用了 foo.bar.baz ，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。

## 2.2 欺骗词法 ##

欺骗词法作用域会导致性能下降。

### 2.2.1 eval ###

JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。

根据这个原理来理解 eval(..) ，它是如何通过代码欺骗和假装成书写时（也就是词法期）代码就在那，来实现修改词法作用域环境的，这个原理就变得清晰易懂了。

在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

	function foo(str, a) {
		eval( str ); // 欺骗！
		console.log( a, b );
	}
	var b = 2;
	foo( "var b = 3;", 1 ); // 1, 3

eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b ，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b ，并遮蔽了外部（全局）作用域中的同名变量。

当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b ，但是永远也无法找到外部的 b 。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。

默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改。技术上，通过一些技巧（已经超出我们的讨论范围）可以间接调用 eval(..) 来使其运行在全局作用域中，并对全局作用域进行修改。但无论何种情况， eval(..) 都可以在运行期修改书写期的词法作用域。

在严格模式的程序中， eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

setTimeout(..) 、setInterval(..)和new Function(..)类似 

在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

### 2.2.2 with ###

JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with 关键字。

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

	var obj = {
		a: 1,
		b: 2,
		c: 3
	};
	// 单调乏味的重复 "obj"
	obj.a = 2;
	obj.b = 3;
	obj.c = 4;
	// 简单的快捷方式
	with (obj) {
		a = 3;
		b = 4;
		c = 5;
	}

尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。

eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。

### 2.2.3 性能 ###

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

最悲观的情况是如果出现了 eval(..) 或 with ，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

## 2.3 小结 ##

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

JavaScript 中有两个机制可以“欺骗”词法作用域： eval(..) 和 with 。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认
为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。