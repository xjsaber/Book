第一部分 作用域和闭包

# 第1章 作用域是什么 #

存储变量当中的值，并且能在之后对这个值进行访问或修改。

事实上，正是这种存储和访问变量的值的能力将*状态*带给了程序。



## 1.1 编译原理 ##

JavaScript事实上是一门编译语言。

**\* 分词/词法分析（Tokenizing/Lexing）**

这个过程会将字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。

	var a = 2。

这段程序通常会被分解成：var、 a、 =、 2 、 ；。空格是否会被当成词法单元，取决于空格在这门语言中是否具有意义。

*分词（tokenizing）和词法分析（Lexing）之间的区别非常微妙。主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分，调用的是有状态的解析规则，那么这个过程被称为词法分析。*

**\* 解析/语法分析(Parsing)**

这个过程将词法单元流（数组）转换成一个由元素逐级前套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。var a = 2；的抽象语法树中可能有个叫作VariableDeclaration的顶级节点，接下来是一个叫作Idetifier（它的值是a）的子节点，以及一个叫作AssignmentExpression的子节点。AssignmentExpression节点有一个叫作NumbericLiteral（它的值是2）的子节点。

**\* 代码生成**

将AST转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。

简单来说就是有某种方法可以将var a = 2;的AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值存储在a中。

1. JavaScript引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript的编译过程不是发生在构建之前的。
2. 对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript引擎用尽了各种方法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。

任何 JavaScript 代码片段在执行前都要进行编译**（通常就在执行前）**。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。

### 1.2 理解作用域 ###

#### 1.2.1 演员表 ####

	var a = 2;

* 引擎

从头到尾负责整个JavaScript程序的编译及执行过程

* 编译器

负责语法分析及代码生成等脏活累活。

* 作用域

负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

#### 1.2.2 对话 ####

引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一
作则由引擎在运行时处理。

	var a = 2;

编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。

1. 遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

#### 1.2.3 编译器有话说 ####

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。

LHS和RHS，是一个赋值操作的左侧和右侧。当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。**RHS 理解成 retrieve his source value（取到它的源值），这意味着“得到某某的值”。**

	console.log(a);

其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值。相应地，需要查找并取得a的值，这样才能将值传递给console.log(..)。相比之下，例如：a = 2；这里对a的引用则是LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。

LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意外着就是“=赋值操作符的左侧或右侧”。

	function foo(a) {
		console.log(a); // 2
	}
	foo(2);

最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把它给我”。并且 (..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值！

代码中隐式的 a = 2操作可能很容易被忽略掉。这个操作发生在2被当做参数传递给foo(..)函数时，2会被分配给参数a。为了给参数a（隐式地）分配值，需要进行一次LHS查询。

这里还有对a机型RHS引用，并且将得到的值传给了console.log(..)。console.log(..)本身也需要一个引用才能执行，因此会对console对象进行RHS查询，并且检查得到的值中是否有一个叫作log的方法。

### 1.2.4 引擎和作用域的对话 ###

	function foo(a) {
		console.log(a); // 2
	}
	foo(2);
	
1. foo RHS 
2. a = 2 LHS
3. console RHS
4. a RHS

### 1.2.5 小测验 ###

	function foo(a) {
		var b = a;
		return a + b;
	}
	
	var c= foo(2);

foo(RHS)，参数a（LHS），b=a对a进行RHS，并对b进行LHS。return a + b(对a和b进行RHS)。var c = ...(对c进行LHS)

## 1.3 作用域前套 ##

作用域是根据名称查找变量的一套规则。实际情况中，通常需要同事顾及几个作用域。

当一个块或函数前套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层前套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

	function foo(a) {
		console.log( a + b );
	}
	var b = 2;
	foo( 2 ); // 4

对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成。

*引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都
会停止。*

## 1.4 异常 ##

区分LHS和RHS，在变量中没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

	function foo(a) {
		console.log( a + b );
		b = a;
	}
	foo(2);

第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。

如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。值得注意的是， ReferenceError 是非常重要的异常类型。

相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。

ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。

如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 1.5 小结 ##

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。*如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询*。

赋值操作符会导致 LHS 查询。 ＝ 操作符或调用函数时传入参数的操作都会导致关联作用域 的赋值操作。

JavaScript引擎首先会在代码执行之前对其进行编译，在这个过程中，像var a = 2这样的声明会被分解称两个独立的步骤：

1.	首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行钱进行。


2.	接下来，a = 2会查询（LHS查询）变量a并对其进行赋值。

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。
