# 第三章 函数作用域和块作用域 #

作用域包含了一系列的“气泡”，每一个都可以作为容器，其中包含了标识符（变量、函数）的定义。这些气泡互相嵌套并且整齐地排列成蜂窝型，排列的结构是在写代码时定义的。

## 3.1 函数中的作用域 ##

JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。

**1. 需要研究一下函数作用域及其背后的一些内容**

	function foo(a) {
		var b = 2;
		
		// 一些代码
		function bar () {
			//...
		}
		// 更多的代码
		var c = 3;
	}

**查找**

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息查找标识符的位置。

引擎执行 console.log(..) 声明，并查找 a 、 b 和 c 三个变量的引
用。它首先从最内部的作用域，也就是 bar(..) 函数的作用域气泡开始查找。引擎无法在这里找到 a ，因此会去上一级到所嵌套的 foo(..) 的作用域中继续查找。在这里找到了 a ，因此引擎使用了这个引用。对 b 来讲也是一样的。而对 c 来说，引擎在 bar(..) 中就找到了它。

如果 a 、 c 都存在于 bar(..) 和 foo(..) 的内部， console.log(..) 就可以直接使用 bar(..)中的变量，而无需到外面的 foo(..) 中查找。

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

词法作用域查找只会查找一级标识符，比如 a 、 b 和 c 。如果代码中引用了 foo.bar.baz ，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。

## 3.2 隐藏内部实现 ##

对函数的传统认知就是先声明一个函数，然后在向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。

实际上的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段片段中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。

有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。

这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴露过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。

	function doSomething(a) {
		b = a + doSomethingElse( a * 2 );

		console.log( b * 3 );
	}

	function doSomethingElse(a) {
		return a - 1;
	}

	var b;
	doSomething( 2 ); //15

在这个代码片段中，变量b和函数doSomethingElse(..)应该是doSomething(..)内部具体实现的“私有”内容。给予外部作用域对b和doSomethingElse(..)的“访问权限”不仅没有必要，而且可能是“危险”的。

更“合理”的设计会将这些私有的具体内容隐藏在doSomething(..)内部。

良好的编码习惯：

	function doSomething(a) {
		function doSomethingElse(a) {
			return a - 1;
		}
		var b;
		b = a + doSomethingElse( a * 2 );
		console.log( b * 3 );
	}
	doSomething( 2 ); // 15

**规则冲突**

“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

1. 全局命名空间

变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名控件）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。

	var MyReallyCoolLibrary = {
		awesome: "stuff",
		doSomething: function() {
			//..
		},
		doAnotherThing: function() {
			//..
		}
	}

2. 模块管理

另外一种避免冲突的方法和现代的模块机制很接近，就是从众多模块管理器中条线一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而不是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

## 3.3 函数作用域 ##
	
在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。

	var a = 2;
	function foo() {
		var a = 3;
		console.log(a); // 3
	}
	foo();
	console.log(a); // 2

1. 必须声明一个具名函数 foo() ，意味着 foo 这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。
2. 必须显式地通过函数名（ foo() ）调用这个函数才能运行其
中的代码。

	var a = 2;
	(function foo() { // <-- 添加这一行
		var a = 3;
		console.log(a); // 3
	})(); // <-- 以及这一行
	console.log(a); // 2	

1. 包装函数的声明以（function...而不仅是以function...开始。函数会被当作函数表达式而不是一个标准的函数声明来处理。

区分函数声明和表达式最简单的方法是看function关键字出现在生命中的位置（不仅仅是一行代码，而是整个生命中的位置）。如果function是声明中的第一个次，那么就是一个函数声明，否则就是一个函数表达式。

1. 片段中 foo 被绑定在所在作用域中，可以直接通过
foo() 来调用它。
2. 片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。

*(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。 foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。*

### 3.3.1 匿名和具名 ###

	setTimeout( function() {
		console.log("I waited 1 second!");
	}, 1000);

这叫做匿名函数表达式，因为function()..没有名称标识符。函数表达式可以是匿名的,而函数声明则不可以省略函数名——在JavaScript的语法中这是非法的。

匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

为了避免这些问题，可以指定一个函数名可以有效解决。行内函数表达式非常强大且游泳——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。

	setTimeout( function timeoutHandler() {
		console.log("I waited 1 second!");
	}, 1000);

### 3.3.2 立即执行函数表达式 ###

	var a = 2;

	(function foo() {
		var a = 3;
		console.log(a); //3
	})();
	console.log(a); //2

由于函数被包含在一对()括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如(function foo(){..})。第一个()将函数变成表达式，第二个（）执行了这个函数。

## 3.4 块作用域 ##

### 3.4.1 with ###

with不仅是一个难于理解的结构，同时也是块作用域的一个例子（块作用域的一种形式），用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。

### 3.4.2 try/catch ###

JavaScript 的 ES3 规范中规定 try / catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。

### 3.4.3 let ###

let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。

	var foo = true;
	if (foo) {
		let bar = foo * 2;
		bar = something( bar );
		console.log( bar );
	}
	console.log( bar ); // ReferenceError
用let将变量附加在一个已经存在的块作用域上的行为是隐式的。

使用let进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。

	{
		console.log( bar ); // ReferenceError!
		let bar = 2;
	}

**1. 垃圾收集**

另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。

	function process(data) {
		// 在这里做点有趣的事情
	}
	var someReallyBigData = {..};
	process( some ReallyBigData );
	var btn = document.getElementById("my_button");
	btn.addEventListener("click", function click(evt) {
		console.log("button clicked");
	}, /*capturingPhase=*/false );

click函数的点击回调并不需要someReallyBigData变量。理论上这意味着当process(..)执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于click函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体实现）。

块作用域可以让引擎清楚地知道没有必要继续保存someReallyBigData了。

**2.let循环**

for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

### 3.4.4 const ###

const，可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

## 3.5 小结 ##

函数是JavaScript中最常见的作用域单元。

块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。从 ES3 开始， try/catch 结构在 catch 分句中具有块作用域。在 ES6 中引入了 let 关键字（ var 关键字的表亲），用来在任意代码块中声明变量。 if (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块
中。

