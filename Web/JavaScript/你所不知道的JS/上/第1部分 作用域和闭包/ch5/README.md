# 第5章 作用域闭包 #

## 5.1 启示 ##

JavaScript中闭包无处不在，你只需要能够识别并拥抱它。

闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

## 5.2 实质问题 ##

	function foo() {
		var a = 2;

		function bar() {
			console.log(a);
		}
		bar();
	}
	foo();

这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数bar() 可以访问外部作用域中的变量 a 。

函数 bar() 具有一个涵盖 foo() 作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域）。也可以认为 bar() 被封闭在
了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。

但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是如何工作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易理解。

	function foo() {
		var a = 2;
		function bar() {
			console.log( a );
		}
		return bar;
	}
	var baz = foo();
	baz(); // 2 —— 朋友，这就是闭包的效果。

函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。

在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz() ，实际上只是通过不同的标识符引用调用了内部的函数 bar() 。

bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。

在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。

无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

	function foo() {
		var a = 2;
		function baz() {
		console.log( a ); // 2
	}
		bar( baz );
	}
	function bar(fn) {
		fn(); // 妈妈快看呀，这就是闭包！
	}

把内部函数 baz 传递给 bar ，当调用这个内部函数时（现在叫作 fn ），它涵盖的 foo() 内部 作用域的闭包就可以观察到了，因为它能够访问 a 。

	var fn;
	function foo() {
		var a = 2;
		function baz() {
			console.log( a );
		}
		fn = baz; // 将 baz 分配给全局变量
	}
	function bar() {
		fn(); // 妈妈快看呀，这就是闭包！
	}
	foo();
	bar(); // 2

## 5.3 现在我懂了 ##

	function wait(message) {
		setTimeout( function timer() {
			console.log( message );
		}, 1000 );
	}
	wait( "Hello, closure!" );

将一个内部函数（名为 timer ）传递给 setTimeout(..) 。 timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。

wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失， timer 函数依然保有 wait(..)作用域的闭包。

无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一
级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

## 5.4 循环和闭包 ##

	for (var i=1; i<=5; i++) {
		setTimeout( function timer() {
			console.log( i );
		}, i*1000 );
	}
输出6。

1. 这个循环的终止条件是 i 不再 <=5 。条件首次成立时 i 的值是
6。因此，输出显示的是循环结束时 i 的最终值。
2. 延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0) ，所有的回调函数依然是在循
环结束后才会被执行，因此会每次输出一个 6 出来。

缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i 。

当然所有函数共享一个 i 的引用。循环结构让我们误以为背后还有更复杂的
机制在起作用，但实际上没有。如果将延迟函数的回调重复定义五次，完全不使用循环，那它同这段代码是完全等价的。

## 5.6 小结 ##

当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。

模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

