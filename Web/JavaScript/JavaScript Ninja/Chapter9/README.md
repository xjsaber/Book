# 第9章 忍者点金术：运行时代码求值 #
本章涵盖以下内容。
* 运行时代码求值是如何工作的
* 代码求值的不同技术
* 在应用程序中代码求值
* 函数反编码
* 命名空间
* 压缩与混淆

## 9.1 代码求值机制 ##

* eval()函数
* 函数构造器
* 定时器
* <script\>元素

### 9.1.1 用eval()方法进行求值 ###
eval()方法可能在运行时进行代码求值的最常用方式了，作为定义在全局作用域内的eval（）方法，该方法将在当前上下文内，执行所传入字符串形式的代码。执行返回结果则是最后一个表达式的执行结果。

#### 基本功能 ####
* 该方法将执行传入代码的字符串。
* 在调用eval()方法的作用域内进行代码求值。


#### 求值结果 ####
eval()方法将返回传入字符串中最后一个表达式的执行结果。
任何不是简单变量、原始值、赋值语言的内容都需要在外面包装一个括号，以便返回正确的结果。

### 9.1.2 用函数构造器进行求值 ###
JavaScript中的所有函数都是Function的实例。可以用过像functionname(...){...}这样的语法创建命名函数，或者省略名称创建匿名函数。
但是，也可以直接使用Function构造器来实例化函数，如：

	var add = new Function("a", "b", "return a + b;");
	assert(add(3,4) === 7, "Function created and working!");
Function构造器可变参数列表的最后一个参数，始终是要创建函数的函数体内容。前面的参数则表示函数的形参名称。

	var add = function(a, b) {return a + b;}
两种代码在功能是等同的，但
1. 采用Function构造器在函数体由运行时的字符串所提供，
2. 使用Function构造器创建函数的时候，不会创建闭包。在不想承担任何不相关闭包的开销时，这可能是件好事。

### 9.1.3 用定时器进行求值 ###
可以让代码字符串进行求值，而且是异步。我们通常给定时器传递一个内联函数或函数引用。这是setTimeout()和setInterval()方法推荐使用的方式，但是这些方法也可以接受字符串的传入，从而在定时器触发的时候进行求值。
	
	var tick = window.setTimeout('alert("H1!")', 100);

### 9.1.4 全局作用域内的求值操作 ###
求值执行的作用域就是调用eval()时的作用域，我们通常希望代码字符串在全局作用域内进行求值，而不是当前执行作用域。

	(function(){
		eval("var test = 5;");
	})();
	assert(test === 5, "Variable created in global scope");


### 9.1.5 安全的代码求值 ###


## 9.2 函数反编译 ##
将函数反编译成字符串

## 9.3 代码求值实战 ##
了解在**何时何地**，我们**可以**或**应该**在代码中使用它。
### 9.3.1 JSON转化 ###
运行时求值的最广泛使用方式是将JSON字符转换为JavaScript对象表示法。由于JSON数据仅仅是JavaScript语言的一个子集，它是完全能够被求值为JavScript代码。

Douglas Crockford的函数在实际求值之前，执行一些重要的预处理操作。
* 防范一些可能在某些浏览器上引起问题的Unicode字符。
* 防范恶意显示的非JSON内容，包括赋值运算符和new操作符。
* 确保只包含了符合JSON规范的字符。

### 9.3.2 导入有命名空间的代码 ###
使用命名空间化的代码防止污染当前上下文——通常是全局上下文。考虑到在JavaScript语言中没有简单或支持的方法。大多数时候，我们不得不使用类似的如下的代码：
	
	var DOM = base2.DOM;
	var JSON = base2.JSON;
	//etc
每当一个新类或模块添加到base2包的时候，构造可执行代码的字符串，对其进行求值，可以将产生的函数引入到当前上下文中。



