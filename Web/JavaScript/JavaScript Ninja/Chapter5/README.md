# 第5章 闭包 #
本章涵盖一下内容。
* 闭包是什么，它们是如何工作的
* 利用闭包简化开发
* 利用闭包提高性能
* 利用闭包解决常见的作用域问题

## 5.1 闭包是如何工作的 ##
闭包（closure）是一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域。换句话说，闭包可以让函数访问所有的变量和函数，只要这些变量和函数存在于该函数声明时的作用域内就行。

* 内部函数的参数是包含在闭包中的。
* 作用域之外的所有变量，即便是函数声明之后的那些声明，也都包含在闭包中。
* 相同的作用域内，尚未声明的变量不能进行提前引用。

## 5.2 使用闭包 ##

### 5.2.1 私有变量 ###
闭包的一种常见用法是封装一些信息作为“私有变量”——也就是说，限制这些变量的作用域。


### 5.2.2 回调（callback）与计时器（timer）###
闭包的最常见情形，是在处理回调或使用计数器的时候。在这两种情况下，函数都是在后期未指定的时间进行异步调用，在这种函数内部，我们经常需要访问外部数据。

*使用$符号作为变量的后缀或前缀，是一个jQuery约定，用于表明该变量引用的是jQuery对象。*

## 5.3 绑定函数上下文 ##
	
	var button = {
        /**
         * 声明一个对象保存button的状态，用于跟踪button是否被单击过
         */
        clicked: false,
        /**
         * 定义一个方法作为click事件处理程序。由于它是一个对象方法，所以在函数内部使用this获取该对象
         */
        click: function () {
            this.clicked = true;
            assert(button.clicked, "The button has been clicked");
        }
    };
代码测试之所以会失败，是因为click函数的上下文不是我们所期待的button对象。
但在本示例中，浏览器的事件处理系统认为函数调用的上下文是事件的目标元素，所以才导致其上下文是<button\>元素，而不是button对象。

通过使用匿名函数、apply()和闭包，我们可以强制让特定的函数在调用时都使用特定所需的上下文。
## 5.4 偏应用函数 ##
函数可以接受任意数量的参数。

### 4.4.1 使用apply()支持可变参数 ###
在JavaScript中，Math对象有两个名为min()和max()的方法，但有一定的局限性。
call()和apply()方法是作为所有函数的方法存在的——甚至是内置的JavaScript函数，

### 4.4.2 函数重载 ###

#### 检测并遍历参数 ####

对arguments列表进行切片（slice）和取舍（dice）

#### 函数重载方式 ####

#### 函数的length属性 ####
如果声明一个接收单个参数的函数，那这个函数的length属性值就应该是1.验证下面的代码：
	
	function makeNinja(name){}
	function makeSamurai(name, rank){}
	assert(makeNinja.length == 1, "Only expecting a single argument");
	assert(makeSamurai.length == 2, "Two arguments expected");
* 通过其length属性，可以知道声明了多少命名参数。
* 通过arguments.length， 可以知道在调用时传入了多少参数。
#### 利用参数个数进行函数重载 ####
1. 根据传入参数的类型执行不同的操作。
2. 可以通过某些特定参数是否存在来进行判断。
3. 通过传入参数的个数进行判断。

## 5.5 函数重载 ##

### 5.5.1 缓存记忆 ###

## 5.6 即时函数 ##
* 匿名函数让我们能够创建更小的执行单元，而不是创建大量命令式语句的函数。
* 通过研究递归函数，我们学到了对函数进行引用的不同方式，其中包括以下几类。
通过名称进行引用
作为一个方法进行引用（通过对象的属性名称）
通过内联名称进行引用。
通过arguments的callee属性进行引用。
* 函数可以拥有属性，并且这些属性可以用来保持任何我们想使用的信息，包括以下几类。
在函数属性中保存其他函数，以便稍后进行引用或调用。
使用函数属性创建缓存（记忆）
* 函数调用时，通过控制传递函数上下文，我们在当前对象上执行该对象没有的方法。利用这种技术，可以利用像Array和Math上已有的方法，在自定义数据上进行传递。
* 基于所传递参数的不同（函数重载），函数可以执行不同的操作。通过检查arguments列表，我们可以根据其传入参数的个数或类型，决定我们要做的事情。
* 通过在对象上调用typeof操作符，判断其结果是不是function，可以判断该对象是不是函数的一个实例。但这种方式也有跨浏览器的问题。 

### 5.6.2 循环 ###
        for (var i = 0; i < divs.length; i++){
            divs[i].addEventListener("click", function () {
                alert("divs #" + i + "was clicked.");
            }, false);
        }

函数绑定之后，闭包抓取的变量被更新了。这意味着，每个绑定的函数处理程序都会显示其最后的值。
闭包记住的是变量的引用（reference）——而不是闭包创建时刻该变量的值。

	    for (var i = 0; i < divs.length; i++)( function (n) {
        divs[n].addEventListener("click", function () {
                alert("divs #" + n + " was clicked.");
            }, false);
        })(i)
通过在for循环内加入即时函数（替换前一个示例中的代码块），我们可以将正确的值传递给即时函数（也就是说内部函数的闭包），进而让处理程序也得到正确的值。

### 5.6.3 类库包装 ###
	(function(){
		var jQuery = window.jQuery = function(){
			//Initialize
		};
		//...
	})()
这里两次赋值，这是有意这么做的。首先jQuery构造器（作为一个匿名函数）赋值给了window.jQuery，这样就将其作为一个全局变量了。

尽管如此，也不能保证全局的jQuery变量就会**一直存在**，处于我们控制之外的代码可能会改变或删除该jQuery变量。为了避免这个问题，我们将其赋值给了一个**局部变量jQuery**，**强制将其保持在即时函数的作用域内**。

在即时函数创建的世界中，名称jQuery的意义就是我们所希望的，因为类库需要的所有函数的变量都进行了很好的封装，从而在如何使用方面，为最终用户提供了很大的灵活性。

另一种方式如下所示：
	var jQuery = (function(){
		function jQuery(){
		//Initialize
		}
		//...
		return jQuery;
	})

## 5.7 总结 ##
* 私有变量的定义和回调的使用
* 强制设置函数上下文、偏应用函数、重载函数、即时函数
