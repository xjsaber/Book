# 第6章 原型与面向对象 #
本章涵盖一下内容。
* 利用函数实现构造器
* 探索原型
* 利用原型实现对象的扩展
* 避免常见的问题
* 构造可继承的类

原型虽然是定义对象的一种很方便的方式，但它的本质依然是函数特性。
作为JavaScript中的一个方便方式，使用原型所定义的属性和功能会自动应用到对象的实例上。一旦进行了定义，原型的属性就汇实例化对象的属性，从而作为复杂对象创建的概览。

换句话说，原型类似于经典面向对象语言中的类（classes）。实际上，JavaScript原型的主要用途就是使用一种类风格（classical style）的面向对象和继承技术进行编码。
## 6.1 实例化和原型 ##
所有的函数在初始化的时候时候都有一个prototype属性，该属性的初始值是一个空对象。

### 6.1.1 对象实例化 ###

var 0 = {};
0.name = 'Saito';
o.occupation = 'marksman';
o.cyberizationLevel = 20;
但是，对于有面向对象编程背景的开发人员来说，根本用不了封装和类构造器的概念：声明一个函数，并将对象初始化到已知的初始状态。

#### 原型作为对象概览 ####
一个使用new操作符，一个不使用new操作符，

#### 实例属性 ####
使用new 操作符将函数作为构造器进行调用的时候，其上下文被定义为新对象实例。意味着，除了通过原型给函数附加属性的形式以外，还可以在构造器函数内通过this参数初始化值。
#### 协调引用 ####
在对象创建时，不仅仅是简单复制属性那么简单。事实上的属性并没有复制到其他地方，而是附加到新创建的对象上了，并可以和对象自身的属性引用一起协调运行。
如下是这一过程的简要描述。
1. 在引用对象的一个属性时，首先检查该对象本身是否拥有该属性，如果有，则直接返回，如果没有……
2. 则，再查看对象的原型（prototype），检查该原型上是否有所要的属性，如果有，则直接返回，如果没有……
3. 则，该值是undefined。

JavaScript中的每个独享，都有一个名为constructor的隐式属性，该属性引用的是创建该对象的构造器。由于prototype是构造器的一个属性，所以每个对象都有一种方式可以找到自己的原型。

### 6.1.2 通过构造器判断对象类型 ###

## 5.2 使用闭包 ##

### 5.2.1 私有变量 ###
闭包的一种常见用法是封装一些信息作为“私有变量”——也就是说，限制这些变量的作用域。


### 5.2.2 回调（callback）与计时器（timer）###


## 5.3 绑定函数上下文 ##
	
	var obj = {};
	var fn = function(){};
	assert(obj && fn, "Both the object and function exist.");

### 4.3.1 函数存储 ###

### 4.3.2 自记忆函数 ###
优点
* 在函数调用获取之前计算结果的时候，最终用户享有性能优势。
* 发生在幕后，完全无缝，最终用户和页面开发人员都无需任何特殊操作或为此作任何额外的初始化工作。
缺点
* 为了提高性能，任何类型的缓存肯定会牺牲掉内存
* 纯粹主义者可能认为缓存这个问题不应该与业务逻辑放在一起，一个函数或方法应该只做一件事，并把它做好。
* 很难测试或测量一个算法的性能，就像本例这样。

缓存记忆DOM元素

### 4.3.3 伪造数组方法 ###
Array（构造器）上已经存在可以进行集合处理的方法。

    var elems = {
	    /**
	     * 保存元素的个数。如果我们要假装成是数组。那就需要保存元素项的个数
	     */
	    length: 0,
	    /**
	     * 实现将元素添加到集合的方法。Array的原型中的一个方法可以做到
	     * @param elem 元素
	     */
	    add: function (elem) {
	        Array.prototype.push.call(this, elem);
	    },
	    /**
	     * 实现一个gather()方法，根据id值查找元素
	     * @param id 元素的id
	     */
	    gather: function (id) {
	        this.add(document.getElementById(id));
	    }
	};
方法是通过其函数上下文操作自身数组的。但在这里，我们避开该方法，通过call()方法将我们的对象扮演成上下文，强制其作为push()方法的上下文。push()将会增加length属性的值（会认为它是数组的length属性），然后给对象添加一个数字属性，并将其引用到传入的元素上。
add()方法期望接收一个用于存储的元素引用。
gather()用于根据id值查找对应的元素，并将其添加到存储中。

## 4.4 可变长度的参数列表 ##
函数可以接受任意数量的参数。

### 4.4.1 使用apply()支持可变参数 ###
在JavaScript中，Math对象有两个名为min()和max()的方法，但有一定的局限性。
call()和apply()方法是作为所有函数的方法存在的——甚至是内置的JavaScript函数，

### 4.4.2 函数重载 ###

#### 检测并遍历参数 ####

对arguments列表进行切片（slice）和取舍（dice）

#### 函数重载方式 ####

#### 函数的length属性 ####
如果声明一个接收单个参数的函数，那这个函数的length属性值就应该是1.验证下面的代码：
	
	function makeNinja(name){}
	function makeSamurai(name, rank){}
	assert(makeNinja.length == 1, "Only expecting a single argument");
	assert(makeSamurai.length == 2, "Two arguments expected");
* 通过其length属性，可以知道声明了多少命名参数。
* 通过arguments.length， 可以知道在调用时传入了多少参数。
#### 利用参数个数进行函数重载 ####
1. 根据传入参数的类型执行不同的操作。
2. 可以通过某些特定参数是否存在来进行判断。
3. 通过传入参数的个数进行判断。

## 4.5 函数判断 ##

## 4.6 总结 ##
* 匿名函数让我们能够创建更小的执行单元，而不是创建大量命令式语句的函数。
* 通过研究递归函数，我们学到了对函数进行引用的不同方式，其中包括以下几类。
通过名称进行引用
作为一个方法进行引用（通过对象的属性名称）
通过内联名称进行引用。
通过arguments的callee属性进行引用。
* 函数可以拥有属性，并且这些属性可以用来保持任何我们想使用的信息，包括以下几类。
在函数属性中保存其他函数，以便稍后进行引用或调用。
使用函数属性创建缓存（记忆）
* 函数调用时，通过控制传递函数上下文，我们在当前对象上执行该对象没有的方法。利用这种技术，可以利用像Array和Math上已有的方法，在自定义数据上进行传递。
* 基于所传递参数的不同（函数重载），函数可以执行不同的操作。通过检查arguments列表，我们可以根据其传入参数的个数或类型，决定我们要做的事情。
* 通过在对象上调用typeof操作符，判断其结果是不是function，可以判断该对象是不是函数的一个实例。但这种方式也有跨浏览器的问题。 

### 5.6.2 循环 ###
        for (var i = 0; i < divs.length; i++){
            divs[i].addEventListener("click", function () {
                alert("divs #" + i + "was clicked.");
            }, false);
        }

函数绑定之后，闭包抓取的变量被更新了。这意味着，每个绑定的函数处理程序都会显示其最后的值。
闭包记住的是变量的引用（reference）——而不是闭包创建时刻该变量的值。

	    for (var i = 0; i < divs.length; i++)( function (n) {
        divs[n].addEventListener("click", function () {
                alert("divs #" + n + " was clicked.");
            }, false);
        })(i)
通过在for循环内加入即时函数（替换前一个示例中的代码块），我们可以将正确的值传递给即时函数（也就是说内部函数的闭包），进而让处理程序也得到正确的值。

### 5.6.3 类库包装 ###
	(function(){
		var jQuery = window.jQuery = function(){
			//Initialize
		};
		//...
	})()
这里两次赋值，这是有意这么做的。首先jQuery构造器（作为一个匿名函数）赋值给了window.jQuery，这样就将其作为一个全局变量了。

尽管如此，也不能保证全局的jQuery变量就会**一直存在**，处于我们控制之外的代码可能会改变或删除该jQuery变量。为了避免这个问题，我们将其赋值给了一个**局部变量jQuery**，**强制将其保持在即时函数的作用域内**。

在即时函数创建的世界中，名称jQuery的意义就是我们所希望的，因为类库需要的所有函数的变量都进行了很好的封装，从而在如何使用方面，为最终用户提供了很大的灵活性。

另一种方式如下所示：
	var jQuery = (function(){
		function jQuery(){
		//Initialize
		}
		//...
		return jQuery;
	})

## 5.7 总结 ##
* 私有变量的定义和回调的使用
* 强制设置函数上下文、偏应用函数、重载函数、即时函数
