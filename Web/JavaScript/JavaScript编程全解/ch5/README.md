# 第5章 变量与对象 #

## 5.1 变量的声明 ##


## 5.2 变量与引用 ##

### 5.2.1 函数的参数（值的传递） ###

	function no_swap(a, b){}

	//一个能够交换两个参数的值的函数
	function swap(a, b) {
		return [b, a];
	}
### 5.2.2 字符串与引用 ###

### 5.2.3 对象与引用相关的术语总结 ###


## 5.3 变量与属性 ##
全局变量（以及全局函数名）是全局对象的属性。全局对象是从程序进行一开始就存在的对象。

## 5.4 变量的查找 ##
从代码的角度来看，（作为右值）写出变量名以对该值进行获取的操作，或者写在赋值表达式左侧以作为赋值对象进行查询的操作，都被称为对变量名称的查找。

## 5.5 对变量是否存在的校验 ##
如果试图读取没有被声明的变量，则会引起ReferenceError异常，这是一种错误，必须对代码进行修正。

	var a = a || 7; //一种习惯用法。如果变量a已经具有某值，则使用变量a的值
## 5.6 对象的定义 ##

### 5.6.1 抽象数据类型与面向对象 ###

### 5.6.2 实例间的协作关系与面向对象 ###

### 5.6.3 JavaScript的对象 ###
再JavaScript中，一切都是对象。对象之间的协作（消息收发）通过属性访问（以及方法的调用）来实现。而对象之间的的共性，则是通过继承同一个对象的性质的方式来实现。JavaScript通过基于原型的形式来实现继承。

## 5.7 对象的生成 ##

### 5.7.1 对象字面量 ###

* 作为singleton模式的用法
* 作为多值数据的用法（函数的参数或返回值等）。
* 用于替代构造函数来生成对象。

### 5.7.2 构造函数与new表达式 ###
构造函数是用于生成对象的函数。

	// 构造函数（类的定义）
	function MyClass(x, y) {
		this.x = x;
		this.y = y;
	}

* 构造函数本身和普通的函数声明形式相同
* 构造函数通过new表达式来调用
* 调用构造函数的new表达式的值是（被新生成的）对象的引用
* 通过new表达式调用的构造函数内的this引用引用了（被新生成的）对象。

### 5.7.3 构造函数与类的定义 ###
通过new表达式调用普通的函数并生成一个对象，是一种不容易理解的语言特性。

* 由于所有的实例都是赋值了同一个方法所定义的实体，所以效率（内存效率与执行效率）低下。
* 无法对属性值进行访问控制（private或public等）

## 5.8 属性访问 ##
生成的对象可以通过属性来访问。对于对象的引用可以使用点运算符（.）或中括号运算符（[]）来访问其属性。

### 5.8.1 属性值的更新 ###
在赋值表达式的左侧书写属性访问表达式能够实现对属性值的改写。

### 5.8.2 点运算符与中括号运算符在使用上的区别 ###

通常用点运算符，不过，中括号运算符的通用性更高

* 使用了不能作为标识符的属性名的情况。
* 将变量的值作为属性名使用的情况。
* 将表达式的求值结果作为属性名使用的情况。

### 5.8.3 属性的枚举 ###
属性可以分为直接属性以及继承于原型的属性。for in 语句和 for each in语句都会枚举继承于原型的属性。


## 5.9 作为关联数组的对象 ##

### 5.9.1 关联数组 ###
首先对于关联数组相关的术语进行整理。将数值作为键的值的数据结构通常称为数组。

关联数组的操作方式
关键数组是元素的集合，其元素为键与值的配对。

### 5.9.2 作为关联数组的对象的注意点 ###
作为关联数组的对象有一些和原型继承相关的注意点。

## 5.10 属性的属性 ##

## 5.11 垃圾回收 ##

## 5.12 不可变对象 ##

### 5.12.1 不可变对象的定义 ###

### 5.12.2 不可变对象的作用 ###

### 5.12.3 实现不可变对象的方式 ###

## 5.13 方法 ##

## 5.14 this引用 ##

* 在最外层代码中，this引用引用的是全局对象。
* 在函数内，this引用根据函数调用方式的不同而有所不同。

| --:|:-- |
| 构造函数调用 | 所生成的对象 |
| 方法调用 | 接收方对象 |
| apply或是call调用 | 由apply或call的参数指定的对象 |
| 其他方式的调用 | 全局对象 |

### 5.14.2 this引用的注意点 ###
其他的接收方对象调用某个函数，或是在没有接收方对象的情况下，this引用的操作是不同的。

在方法内部调用方法的情况

	// 从doit方法内调用doit2方法时，必须通过this引用，以this/doit2()的方式实现
	js > var obj = {
		x: 3,
		doit: function() { print('doit is called.' + this.x); this.doit2(); },
		doit2: function() { print('doit2 is called.' + this.x);}
	};
	js> obj.doit();
	doit is called. 3
	doit2 is called. 3

## 5.15 apply与call ##
在Function对象中包含apply与call这两种方法，通过它们调用的函数的this引用，可以指向任意特定对象。也就是说，可以理解位它们能够显式地指定接收方对象。

	js> function f() { print(this.x); }
	js> var obj = { x: 4 };
	js> f.apply(obj); //通过apply调用函数f。函数内地this引用引用了对象obj
	js> f.call(obj); //通过call调用函数f。
	// 将接收方对象指定为另一个对象并进行方法调用
	js> var obj = {
		x: 3,
		doit: function() { print('method is called.' = this.x); }
	};
	js> var obj2 = { x: 4};
	js> obj.doit.apply(obj2); //通过apply调用obj doit方法。方法内地this引用引用了对象obj2
	

## 5.16 原型继承 ##

	//
	function MyClass(x, y) {
		this.x = x;
		this.y = y;
	}
	MyClass.prototype.show = function() {
		print(this.x, this.y);
	}