# 深入剖析Kubernetes #

## 课前必读 ##

## 开篇词 | 打通“容器技术”的任督二脉 ##

## 01 | 预习篇.小鲸鱼大事记（一）：初出茅庐 ##

## 02 | 预习篇.小鲸鱼大事记（二）：崭露头角 ##

## 03 | 预习篇.小鲸鱼大事记（二）：群雄并起 ##

## 04 | 预习篇.小鲸鱼大事记（二）：尘埃落定 ##

## 容器技术概念入门篇 ##

## 05 | 白话容器基础（一）：从进程说开去 ##

容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。Cgroups技术是用来制造约束的主要手段，而Namespace技术则是用来修改进程视图的主要方法。

	docker run -it busybox /bin/sh

使docker内的程序看不到它前面的其他进程，对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如PID=1。可实际上，它在宿主机的操作系统里还是原来第100进程。（Namespace）

	int pid = clone(main-function, stack_size, SIGCHLD, NULL); 系统调用就会为我们创建一个新的进程，并且返回它的进程号pid。

我们还可以多次执行上面的clone()，创建多个PID Namespace，而每个Namespace里的应用进程，都会认为自己是当前容器里的第1号进程，他们即看不到宿主机里真正的进程空间，也看不到其他PID Namespace里的具体情况。

还有其他Namespace，

所以说，容器，其实是一种特殊的进程而已

### 总结 ###

## 06 | 白话容器基础（二）：隔离与限制 ##

Namespace技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。（但对于宿主机来说）

有利有弊，基于Linux Namespace的隔离机制相比于虚拟化技术可能会出现：隔离不彻底

1. 既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。
2. 在Linux内核中，有很多资源和对象是不呢功能被Namespace化的，最典型的例子就是：时间。



