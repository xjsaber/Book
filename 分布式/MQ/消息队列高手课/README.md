# 消息队列高手课 #

# 课前必读 #

## 开篇词|优秀的程序员，你的技术栈中不能只有“增删改查” ##

## 预习|怎样更好地学习这门课？ ##

# 基础篇 #

## 01 | 为什么需要消息队列 ##

## 02 | 该如何选择消息队列 ##

## 03 | 消息模型：主题和队列有什么区别？ ##

## 04 | 如何利用事务消息实现分布式事务？ ##

## 05 | 如何确保消息不会丢失？ ##

### 检测消息丢失的方法 ###

#### 我们可以利用消息队列的有序性来验证是否有消息丢失。 ####

### 确保消息可靠传递 ###

* 生产阶段：在这个阶段，从消息在Producer创建出来，经过网络传输发送到Broker端
* 存储阶段：在这个阶段，消息在Broker端存储，如果是集群，消息会在这个阶段被复制到其他的副本中。
* 消费阶段：在这个阶段，Consumer从Broker上拉去消息，经过网络传输发送到Consumer。

#### 1. 生产阶段 ####

**你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。**

#### 2. 存储阶段 ####

**如果对消息的可靠要求非常高，可以通过配置Broker参数来避免因为宏机丢消息**。

#### 3. 消费阶段 ####

不要在接收到消息后就立即发送消费确认

## 06 | 如何处理消费过程中的重复消息？ ##

### 消息重复的情况必然存在 ###

* At most once:至多一次。允许丢数据
* At least once：至少一次。不允许丢数据
* Exactly once：恰好一次

## 07 | 消息积压了该如何处理？ ##

### 优化性能来避免消息积压 ###

在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能。

#### 1. 发送端优化 ####

如果说，你的代码发送消息的性能上不去，你需要优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的。

#### 2. 消费端性能优化 ####




### 消息积压了该如何处理？ ###

内置了监控的功能，只需要通过监控数据。如果是单位时间发送的消息增多。唯一的方法是通过扩容消费端的实例来提升总体消费水平。

如果段时间没有足够的服务器资源进行扩容 -> 将系统降级，通过关闭一些重要的业务，减少发送方发送的数据量，最低限度让系统正常运转。

监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，需要检查一下你的消费端，是不是消费失败导致的一条消息反复消费这种情况比较多。

### 小结 ###

1. 是如何在消息队列的收发两端优化系统性能，提前预防消积压。
2. 当系统发生消息积压了之后，该如何处理。

优化消息收发性能，预防消息积压的方法有两种：

1. 增加批量
2. 增加开发

在发送端两种方法都可以使用，在消费端需要注意的是，增加并发需要同步扩容分区数量。

## 08 | 答疑解惑（一）：网关如何接收服务端的秒杀结果？ ##

# 进阶篇 #

## 09 | 学习开源代码该如何入手？ ##

### 通过文档来了解开源项目 ###

最佳的方式就是先看它的文档。

以kafka为例子，如果完全不了解这个项目：

1. 首先去查看[QuickStart](http://kafka.apache.org/documentation/#quickstart)，快速吧环境搭起来
	* 对这个项目有个感性的认识
	* 后续深入学习的时候“跑”一些例子
2. 看一下它的[Introduction](http://kafka.apache.org/documentation/#introduction)，了解项目用到的基本概念或者名词，比如Topic、Producer、Consumer、Partition
3. 有些开源项目会单独有一个 Basic Concepts 文档来讲这些基础概念
4. 看一下它的使用场景、功能特性以及相关的生态系统的介绍。在 Kafka 中功能相关的内容在[Use cases](http://kafka.apache.org/documentation/#uses)和[EcoSystem](https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem)两篇文章中，有些项目中会有类似名为 Features 的文档介绍功能和特性。
5. 对这个项目的整体应该会有一个比较全面的了解了，比如说：
	* 这个项目是干什么的？
	* 能解决哪些问题？
	* 适合在哪些场景使用？
	* 有哪些功能？
	* 如何使用？
6. 接下来就可以去深入学习它的实现原理了，它背后的这篇论文就是整个项目的灵魂，对于 Kafka 来说，它的灵魂是这篇博文：[The Log: What every software engineer should know about real-time data’s unifying abstraction](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)，对应的中文译稿在这里：《[日志：每个软件工程师都应该知道的有关实时数据的统一抽象](https://www.kancloud.cn/kancloud/log-real-time-datas-unifying/58708)》。

### 用以点带面的方式来阅读源码 ###

**带着问题去读源码，最好是带着问题的答案去读源码。**

* RocketMQ的消息是怎么写到文件里的？
* Kafka的Coordinator是怎么维护消息位置的？

确定问题后，先不要着急看源代码，而是应该先找一下是否有对应的实现文档，一般来说，核心功能都会有专门的文档来说明它的实现原理，比如在 Kafka 的文档中，[DESIGN](http://kafka.apache.org/documentation/#design)和[IMPLEMENTATION](http://kafka.apache.org/documentation/#implementation)两个章节中，介绍了 Kafka 很多功能的实现原理和细节。一些更细节的非核心的功能不一定有专门的文档来说明，但是我们可以去找一找是否有对应的 Improvement Proposal。（Kafka 的所有 Improvement Proposals 在[这里](https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals)。）

Improvement Proposal——它是描述一个新功能的文档，一般开源项目需要增加一个新的功能或者特性的时候，都会创建一个 Improvement Proposal，一般标题都是"xIP- 新功能名称"，其中 IP 就是 Improvement Proposal 的缩写，x 一般就是这个开源项目的名称的首字母，比如 Kafka 中 Improvement Proposal 的标题就都是以 KIP 来开头。

每个 Improvement Proposal 都是有固定格式的，一般要说明为什么需要增加这个功能，会对系统产生那些影响和改变，还有我们最关心的设计和实现原理的简述。

读完讲解的文档再去看源代码，不只是带着问题去读，而是带着答案去读源码，不仅仅是更容易理解源代码，还可以把更多的精力放在一些实现细节上，这样阅读源码的效果会更好。

### 小结 ###

学习它的代码，最佳的切入点是去读它的官方文档，这些文档里面，最重要的灵魂就是项目背后的那篇论文，它一般是这个开源项目的理论基础。

最佳的方式带着问题去阅读，最好是带着问题的答案去读，这样难度低、周期短、收获快。不要想着一定要从总体上去全面掌握一个项目的所有项目源代码。

### 思考题 ###

带着问题和答案去读源码”的方法，去读一点源码。然后，最重要的是，把主要的流程用流程图或者时序图画出来，把重点的算法、原理用文字写出来。

## 10 | 如何使用异步设计提升系统性能？ ##

对于开发者来说，异步是一种程序设计的思想，使用异步模式设计的程序可以显著减少线程等待，从而在高吞吐量的场景中，极大提升系统的整体性能，显著降低时延。像消息队列这种需要超高吞吐量和超低时延的中间件系统，在其核心流程中，一定会大量采用异步的设计思想。

### 异步设计如何提升系统性能？ ###

#### 1. 同步实现的性能瓶颈 ####

采用同步实现的方式，整个服务器的所有线程大部分时间都没有在工作，而是在等待。

#### 2. 采用异步实现解决等待问题 ####

* OnDebit()
* OnAllDone()

整个异步实现的语义相当于：

1. 异步从 accountFrom 的账户中减去相应的钱数，然后调用 OnDebit 方法；
2. 在 OnDebit 方法中，异步把减去的钱数加到 accountTo 的账户中，然后执行 OnAllDone 方法；
3. 在 OnAllDone 方法中，调用 OnComplete 方法。

区别只是在线程模型由同步顺序调用改为了异步调用和回调。

### 简单实用的异步框架：CompletableFuture ###

Java 中比较常用的异步框架有 Java8 内置的[CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)和 ReactiveX 的[RxJava](https://github.com/ReactiveX/RxJava)，我个人比较喜欢简单实用易于理解的 CompletableFuture，但是 RxJava 的功能更加强大。

### 小结 ###

当我们要执行一项比较耗时的操作时，不去等待操作结束，而是给这个操作一个命令：“当操作完成后，接下来去执行什么。”

使用异步编程模型，虽然并不能加快程序本身的速度，但可以减少或者避免线程等待，只用很少的线程就可以达到超高的吞吐能力。

使用异步模型，代码可读性和可维护性会下降

异步性能虽好，但一定不要滥用，只有类似在像消息队列这种业务逻辑简单并且需要超高吞吐量的场景下，或者必须长时间等待资源的地方，才考虑使用异步模型。如果系统的业务逻辑比较复杂，在性能足够满足业务需求的情况下，采用符合人类自然的思路且易于开发和维护的同步模型是更加明智的。

### 思考题 ###

#### 1. 没有攷虑失败如果第一次失败，第二次成功 ####

#### 2. OnComplete()方法是在什么线程中运行的 ####

主线程

## 11 | 如何实现高性能的异步网络传输？ ##

### 理想的异步网络框架应该是什么样的？ ###

## 12 | 序列化与反序列化：如何通过网络传输结构化的数据？ ##

## 33 | 动手实现一个简单的RPC框架（三）：客户端 ##

序列化和网络传输部分

在PRC框架中，最关键的就是理解“桩”的实现原理，桩是RPC框架在客户端的服务代理，它的远程服务具有相同的方法签名，或者说是实现了相同的接口，客户端在调用RPC框架提供的服务时，实际调用的就是“桩”提供的方法，在桩的实现方法中，它会发请求到服务端获取调用结果并返回给调用方。

在RPC框架的客户端中，最关键的部分，也就是如何来生成和实现这个桩。

### 如何来动态地生成桩 ###



