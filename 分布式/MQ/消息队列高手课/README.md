# 消息队列高手课 #

# 课前必读 #

## 开篇词|优秀的程序员，你的技术栈中不能只有“增删改查” ##

JMQ

### 底层技术知识，给你深入解决业务问题的能力 ###

在使用消息队列的过程中，你会遇到很多问题，比如选择哪款消息队列更适合你的业务系统？如何保证系统的高可靠、高可用和高性能？如何保证消息不重复、不丢失？如何做到水平扩展？

*从职业发展，保持市场竞争力的角度来看，掌握一些底层技术，深耕个人技术栈的深度，实现从“用轮子”到“造轮子”的技术提升，也是一个非常明智的选择。*

ActiveMQ ->  RocketMQ、Kafka -> Pulsar

### 课程设置 ###

* *基础篇*，以讲解消息队列的使用方法和最佳实践为主，包括消息队列基础知识、技术选型、高级功能等，给出消息队列应用过程中常见问题的解决策略。
* *进阶篇*，探讨消息队列的实现原理
* *案例篇*：
	* 一起用消息队列和流计算框架来实现一个流计算任务；
	* 一起来实现一个最简单的 RPC 框架 

### 写在最后 ###

其中每一个知识点不仅是中间件开发人员必须掌握的，而且是各大厂面试题中的常考内容。





## 预习|怎样更好地学习这门课？ ##

# 基础篇 #

## 01 | 为什么需要消息队列 ##

## 02 | 该如何选择消息队列 ##

## 03 | 消息模型：主题和队列有什么区别？ ##

## 04 | 如何利用事务消息实现分布式事务？ ##

## 05 | 如何确保消息不会丢失？ ##

### 检测消息丢失的方法 ###

#### 我们可以利用消息队列的有序性来验证是否有消息丢失。 ####

### 确保消息可靠传递 ###

* 生产阶段：在这个阶段，从消息在Producer创建出来，经过网络传输发送到Broker端
* 存储阶段：在这个阶段，消息在Broker端存储，如果是集群，消息会在这个阶段被复制到其他的副本中。
* 消费阶段：在这个阶段，Consumer从Broker上拉去消息，经过网络传输发送到Consumer。

#### 1. 生产阶段 ####

**你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。**

#### 2. 存储阶段 ####

**如果对消息的可靠要求非常高，可以通过配置Broker参数来避免因为宏机丢消息**。

#### 3. 消费阶段 ####

不要在接收到消息后就立即发送消费确认

## 06 | 如何处理消费过程中的重复消息？ ##

### 消息重复的情况必然存在 ###

* At most once:至多一次。允许丢数据
* At least once：至少一次。不允许丢数据
* Exactly once：恰好一次

## 07 | 消息积压了该如何处理？ ##

### 优化性能来避免消息积压 ###

在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能。

#### 1. 发送端优化 ####

如果说，你的代码发送消息的性能上不去，你需要优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的。

#### 2. 消费端性能优化 ####




### 消息积压了该如何处理？ ###

内置了监控的功能，只需要通过监控数据。如果是单位时间发送的消息增多。唯一的方法是通过扩容消费端的实例来提升总体消费水平。

如果段时间没有足够的服务器资源进行扩容 -> 将系统降级，通过关闭一些重要的业务，减少发送方发送的数据量，最低限度让系统正常运转。

监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，需要检查一下你的消费端，是不是消费失败导致的一条消息反复消费这种情况比较多。

### 小结 ###

1. 是如何在消息队列的收发两端优化系统性能，提前预防消积压。
2. 当系统发生消息积压了之后，该如何处理。

优化消息收发性能，预防消息积压的方法有两种：

1. 增加批量
2. 增加开发

在发送端两种方法都可以使用，在消费端需要注意的是，增加并发需要同步扩容分区数量。

## 08 | 答疑解惑（一）：网关如何接收服务端的秒杀结果？ ##

# 进阶篇 #

## 09 | 学习开源代码该如何入手？ ##

### 通过文档来了解开源项目 ###

最佳的方式就是先看它的文档。

以kafka为例子，如果完全不了解这个项目：

1. 首先去查看[QuickStart](http://kafka.apache.org/documentation/#quickstart)，快速吧环境搭起来
	* 对这个项目有个感性的认识
	* 后续深入学习的时候“跑”一些例子
2. 看一下它的[Introduction](http://kafka.apache.org/documentation/#introduction)，了解项目用到的基本概念或者名词，比如Topic、Producer、Consumer、Partition
3. 有些开源项目会单独有一个 Basic Concepts 文档来讲这些基础概念
4. 看一下它的使用场景、功能特性以及相关的生态系统的介绍。在 Kafka 中功能相关的内容在[Use cases](http://kafka.apache.org/documentation/#uses)和[EcoSystem](https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem)两篇文章中，有些项目中会有类似名为 Features 的文档介绍功能和特性。
5. 对这个项目的整体应该会有一个比较全面的了解了，比如说：
	* 这个项目是干什么的？
	* 能解决哪些问题？
	* 适合在哪些场景使用？
	* 有哪些功能？
	* 如何使用？
6. 接下来就可以去深入学习它的实现原理了，它背后的这篇论文就是整个项目的灵魂，对于 Kafka 来说，它的灵魂是这篇博文：[The Log: What every software engineer should know about real-time data’s unifying abstraction](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)，对应的中文译稿在这里：《[日志：每个软件工程师都应该知道的有关实时数据的统一抽象](https://www.kancloud.cn/kancloud/log-real-time-datas-unifying/58708)》。

### 用以点带面的方式来阅读源码 ###

**带着问题去读源码，最好是带着问题的答案去读源码。**

* RocketMQ的消息是怎么写到文件里的？
* Kafka的Coordinator是怎么维护消息位置的？

确定问题后，先不要着急看源代码，而是应该先找一下是否有对应的实现文档，一般来说，核心功能都会有专门的文档来说明它的实现原理，比如在 Kafka 的文档中，[DESIGN](http://kafka.apache.org/documentation/#design)和[IMPLEMENTATION](http://kafka.apache.org/documentation/#implementation)两个章节中，介绍了 Kafka 很多功能的实现原理和细节。一些更细节的非核心的功能不一定有专门的文档来说明，但是我们可以去找一找是否有对应的 Improvement Proposal。（Kafka 的所有 Improvement Proposals 在[这里](https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals)。）

Improvement Proposal——它是描述一个新功能的文档，一般开源项目需要增加一个新的功能或者特性的时候，都会创建一个 Improvement Proposal，一般标题都是"xIP- 新功能名称"，其中 IP 就是 Improvement Proposal 的缩写，x 一般就是这个开源项目的名称的首字母，比如 Kafka 中 Improvement Proposal 的标题就都是以 KIP 来开头。

每个 Improvement Proposal 都是有固定格式的，一般要说明为什么需要增加这个功能，会对系统产生那些影响和改变，还有我们最关心的设计和实现原理的简述。

读完讲解的文档再去看源代码，不只是带着问题去读，而是带着答案去读源码，不仅仅是更容易理解源代码，还可以把更多的精力放在一些实现细节上，这样阅读源码的效果会更好。

### 小结 ###

学习它的代码，最佳的切入点是去读它的官方文档，这些文档里面，最重要的灵魂就是项目背后的那篇论文，它一般是这个开源项目的理论基础。

最佳的方式带着问题去阅读，最好是带着问题的答案去读，这样难度低、周期短、收获快。不要想着一定要从总体上去全面掌握一个项目的所有项目源代码。

### 思考题 ###

带着问题和答案去读源码”的方法，去读一点源码。然后，最重要的是，把主要的流程用流程图或者时序图画出来，把重点的算法、原理用文字写出来。

## 10 | 如何使用异步设计提升系统性能？ ##

对于开发者来说，异步是一种程序设计的思想，使用异步模式设计的程序可以显著减少线程等待，从而在高吞吐量的场景中，极大提升系统的整体性能，显著降低时延。像消息队列这种需要超高吞吐量和超低时延的中间件系统，在其核心流程中，一定会大量采用异步的设计思想。

### 异步设计如何提升系统性能？ ###

#### 1. 同步实现的性能瓶颈 ####

采用同步实现的方式，整个服务器的所有线程大部分时间都没有在工作，而是在等待。

#### 2. 采用异步实现解决等待问题 ####

* OnDebit()
* OnAllDone()

整个异步实现的语义相当于：

1. 异步从 accountFrom 的账户中减去相应的钱数，然后调用 OnDebit 方法；
2. 在 OnDebit 方法中，异步把减去的钱数加到 accountTo 的账户中，然后执行 OnAllDone 方法；
3. 在 OnAllDone 方法中，调用 OnComplete 方法。

区别只是在线程模型由同步顺序调用改为了异步调用和回调。

### 简单实用的异步框架：CompletableFuture ###

Java 中比较常用的异步框架有 Java8 内置的[CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)和 ReactiveX 的[RxJava](https://github.com/ReactiveX/RxJava)，我个人比较喜欢简单实用易于理解的 CompletableFuture，但是 RxJava 的功能更加强大。

### 小结 ###

当我们要执行一项比较耗时的操作时，不去等待操作结束，而是给这个操作一个命令：“当操作完成后，接下来去执行什么。”

使用异步编程模型，虽然并不能加快程序本身的速度，但可以减少或者避免线程等待，只用很少的线程就可以达到超高的吞吐能力。

使用异步模型，代码可读性和可维护性会下降

异步性能虽好，但一定不要滥用，只有类似在像消息队列这种业务逻辑简单并且需要超高吞吐量的场景下，或者必须长时间等待资源的地方，才考虑使用异步模型。如果系统的业务逻辑比较复杂，在性能足够满足业务需求的情况下，采用符合人类自然的思路且易于开发和维护的同步模型是更加明智的。

### 思考题 ###

#### 1. 没有攷虑失败如果第一次失败，第二次成功 ####

#### 2. OnComplete()方法是在什么线程中运行的 ####

主线程

## 11 | 如何实现高性能的异步网络传输？ ##

### 理想的异步网络框架应该是什么样的？ ###

## 12 | 序列化与反序列化：如何通过网络传输结构化的数据？ ##

## 14 | 内存管理：如何避免内存溢出和频繁的垃圾回收？ ##

### 自动内存管理机制的实现原理 ###

内存管理，主要包括申请内存和内存回收两个部分

申请内存：

1. 计算要创建对象所需要占用的内存大小；
2. 在内存中找一块儿连续并且是空闲的内存空间，标记为已占用；
3. 把申请的内存地址绑定到对象的引用上，这时候对象就可以使用了

内存回收：

1. 先是找出所有可以回收的对象
2. 将对应的内存标记为空闲
3. 整理内存碎片

具体算法采用是“标记-清除”算法或是它的变种算法，分为标记和清除两个阶段：

* 标记阶段：GC Root开始
* 清除结点

*垃圾回收完成后，还需要进行内存碎片整理，将不连续的空闲内存移动到一起，以便空出足够的连续内存空间供后续使用。*

### 为什么在高并发下程序会卡死？ ###

### 高并发下的内存管理技巧 ###

垃圾回收是不可控的，而且是无法避免的。可以通过一些方法来降低垃圾回收的频率，减少进程暂停的时长。



## 加餐 | JMQ的Broker是如何异步处理消息的？ ##

*设计和实现*消息队列的高手，具体分为基础篇、进阶篇和案例篇。

* 基础篇：讲解消息队列的原理和一些使用方法，让大家学会使用消息队列。
* 进阶篇：讲解实现消息队列必备的技术知识，通过分析源码讲解消息队列的实现原理。=》能够掌握到设计、实现消息队列所必备的知识和技术（设计所有高性能、高可靠的分布式系统基础）
* 案例篇：为什么我们要开发一个 RPC 框架，而不是一个消息队列=》能做到真正理解原理，掌握知识和技术，并且能融会贯通，灵活地去使用。

### JMQ的Broker是如何异步处理消息的？ ###

设计流程时，是如何来将异步的设计落地的。

消息生产的流程需要完成的功能：

![a7589a7b4525e107f9b82de133bc43ba.jpg](img/a7589a7b4525e107f9b82de133bc43ba.jpg)

1. 生产者发送一批消息给Broker的主节点；
2. Broker收到消息之后，会对消息做一系列的解析、检查等处理；
3. 把消息复制给所有的Broker从节点，并且需要把消息写入到磁盘中；
4. 主节点收到大多数从节点的复制成功确认后，给生产者回响应告知消息发送成功。

#### 重要的优化： ####

* 使用异步设计，把刷盘和复制这两部分比较慢的操作从流程中分离出去异步执行；
* 使用了一个写缓存Jounal Cache将一个写磁盘的操作，转换成了一个写内存的操作，来提升数据写入的性能
* 流程处理使用No-Lock（避免了线程因为等待锁导致的阻塞）
* 回复响应等待资源的操作，异步放在其他线程，避免在主线程中执行

一个接收请求写入数据并回响应的流程，涉及的技术包括：*异步的设计、缓存设计、锁的正确使用、线程协调、序列化和内存管理*。需要对这些技术有深入的理解，并合理地使用，才能在确保逻辑正确、数据准确的前提下，做到极致的性能。

*掌握的程度*

* 不止可以轻松地讲JVM内存结构，也知道怎么用jstat、jmap、jstack这些工具来查看虚拟机的状态
* 还需要了解到实际应用场景，如分析一个内存溢出的问题程序和源代码，并改正。
* 学以致用

### 两大爷的思考题 ###



### 思考题 ###



23 | RocketMQ

24 | ZooKeeper

## 33 | 动手实现一个简单的RPC框架（三）：客户端 ##

序列化和网络传输部分

在PRC框架中，最关键的就是理解“桩”的实现原理，桩是RPC框架在客户端的服务代理，它的远程服务具有相同的方法签名，或者说是实现了相同的接口，客户端在调用RPC框架提供的服务时，实际调用的就是“桩”提供的方法，在桩的实现方法中，它会发请求到服务端获取调用结果并返回给调用方。

在RPC框架的客户端中，最关键的部分，也就是如何来生成和实现这个桩。

### 如何来动态地生成桩 ###





异