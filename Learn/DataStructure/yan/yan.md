# 数据结构（C语言版）（第2版） #

## 第1章 绪论 ##

### 1.1 什么是数据结构 ###

### 1.2 基本概念和术语 ###

#### 1.2.1 数据、数据元素、数据项和数据对象 ####

* 数据
* 数据元素
* 数据项
* 数据对象

#### 1.2.2 数据结构 ####

1. 逻辑结构
2. 存储结构

#### 1.2.3 数据类型和抽象数据类型 ####

1. 数据类型
2. 抽象数据类型

ADT

### 1.3 抽象数据类型的表示和实现 ###

（1） 预定义常量和类型：

	//函数结果状态代码
	#define TRUE 1
	#define FALSE 0
	#define OK 1
	#define ERROR 0
	#define INFEASIBLE -1
	#define OVERFLOW -2
	// Status是函数的类型，其值是函数结果状态代码
	typedef int Status;

（2） 数据结构的表示（存储结构）用类型定义（typedef）描述；数据元素类型约定为ElemType，由用户在使用该数据类型时自行定义。

（3）基本操作的算法都用如下格式的函数来描述
（4）内存的动态分配与释放

使用new和delete动态分配和释放内存空间：

	分配空间 指针变量=new数据类型；
	释放空间 delete指针变量；

（5）赋值语句：
（6）原则语句：
（7）循环语句
（8）结束语句

	函数结束语句 return 表达式;
			    return;
	case 结束语句 break;
	异常结束语句 exit(异常代码);

（9）输入输出语句

	输入语句 cin>>变量1>>...>>变量n;
	输出语句 cout<<表达式1<<...<<表达式n;
	输入语句 scanf([格式串]，变量1，...，变量n);
	输出语句 printf([格式串]，变量1，...，变量n);

（10）基础函数

	求最大值
	求最小值										

	求最大值 max(表达式，...，表达式n)
	求最小值 min(表达式，...，表达式n)
	求绝对值 abs(表达式)
	求不足整数值 floor表达式)
	求进位整数值 ceil(表达式)
	判定文件结束 eof(文件变量)或eof
	判定行结束 eoln(文件变量)或eoln

(11) 逻辑运算约定

与运算&&: 对于A&&B，当A的值为0时，不再对B求值。
与运算||: 对于A||B，当A的值为非0时，不再对B求值。

> elemtype必须是具体的数值类型，比如int,double......书上的一般是伪码，不能直接当程序运行的
> elemtype在VC中没有这种类型，所以在使用它之前对其定义如 
> typedef int ElemType将ElemType定义为整型的数据类型
> typedef int Status
> 数据结构里讲的Status都是它。
> overflow
>       一般用于exit的参数中，比如创建指针时，一般判断一下内存是否分配成功，不成功一般调 
>      用exit(overflow);
>  
> infeasible 其意思是不可行的，一般在某个判断中，如果什么什么不可行，就会return infeasible
> 例如：求后继元素时，如果是最后一个元素，则求其后继是不可行的，此时就会return infeasible
> 数据结构中error，overflow旳返回值这个没有特别的规定，可以根据程序的意图，或自己的习惯来定义。比如经常将error=0，overflow=-1

### 1.4 算法和算法分析 ###

#### 1.4.1 算法 ####

1. 有穷性 
2. 确定性 
3. 可行性 
4. 输入 
5. 输出

#### 1.4.2 算法设计的要求 #### 

1. 正确性
2. 可读性
3. 健壮性
4. 高效性：效率与低存储量需求，时间复杂度和空间复杂度

#### 1.4.3 算法的时间复杂度 ####

衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。

1. 问题规模和语句频度
2. 算法的时间复杂度定义
3. 算法的时间复杂度分析举例

#### 1.4.4 算法的存储空间需求 ####

空间复杂度（space complexity）作为算法所需存储空间的量度，记作S(n)=O(f(n))  

### 1.5 小结 ###

1. 数据结构的定义
2. 数据结构包括两个方面的内容：数据的逻辑结构和存储结构。同一逻辑结构采用不同的存储方法，可以得到不同的存储结构。
	* 逻辑结构是从具体问题抽象出来的数学模型，从逻辑关系上描述数据，它与数据的存储无关。
	* 存储结构是逻辑结构在计算机中的存储表示，有两类存储结构：顺序存储结构和链式存储结构。
3. 抽象数据类型
4. 算法是为了解决某类问题而规定的一个有限长的操作序列。
5. 算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，以考察算法的时间和空间效率。  

## 第2章 线性表 ##

### 2.1 线性表的类型定义和特点 ###

**线性表**是最常用且最简单的一种数据结构。

	ADT List {
		InitList(&L)，
		操作结果：构造一个空的线性表L
		DestoryList(&L)，
		初始条件：线性表L已存在
		操作结果：销毁线性表L
		ClearList(&L)
		初始条件：线性表L已存在
		操作结果：将L重置为空表
		ListEmpty(L)
		初始条件：线性表L已存在
		操作结果：若L为空表，则返回true，否则返回false
		ListDelete(&L, i)
		初始条件：线性表L已存在且非空，且l<=i<=ListLength(L)
		操作结果：删除L的第i个数据元素，L的长度减1。
		TraverseList(L)
		初始条件：线性表L已存在
		操作结果：对线性表L进行遍历，在遍历过程中对L的每个结点访问一次
	}

算法2.2
GetElem和ListInsert这两个操作的执行时间和表长无关，LocateElem的执行时间和表长成正比。·

### 2.2 案例引入 ###

线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。

### 2.3 线性表的类型定义 ###

	ADT LIST {
		InitList(&L)
		DestoryList(&L)
		ClearList(&L)
		ListEmpty(&L)
		ListLength(L)
		GetElem(L, i, &e)
		LocateElem(L, e)
		PriorElem(L, cur_e, &pre_e)
		NextElem(L, cur_e, &next_e)
		ListInsert(&L, i, e)
		ListDelete(&L, i)
		TraverseList(L)
	}

### 2.4 线性表的顺序表示和实现 ###

#### 2.4.1 线性表的顺序存储表示 ####

线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性的表的数据元素，这种表示也称作线性表的顺序存储结构。

	#define MAXSIZE 100
	typedef struct
	{
		ElemType *elem;
		int length;
	} SqList;

#### 2.4.2 顺序表中基本操作的实现 ####

**1. 初始化**

顺序表的初始化操作就是构造一个空的顺序表

1. 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址
2. 将表的当前长度设为0

**2.取值**

1. 判断指定的位置序号i值是否合理（1<=i<=L.length），若不合理，则返回ERROR
2. 若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的传值

**3. 查找**

1. 从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回改元素的序号i+1。
2. 若查遍整个顺序表都没有找到，则查找失败，返回0

在查找时，为确定元素在顺序表中的位置，需要给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的*平均查找长度（Average Search Length，ASL）*

**4. 插入**

1. 判断插入位置i是否合法（i值的合法范围是1≤i≤n+1），若不合法则返回ERROR。
2. 判断顺序表的存储空间是否已满，若满则返回ERROR。
3. 将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置（i=n+1时无需移动）。
4. 将要插入的新元素e放入第i个位置。
5. 表长加1。

**5. 删除**

1. 判断删除位置i是否合法（合法值为1<=i<=n），若不合法则

### 2.5 线性表的链式表示和实现 ###

#### 2.5.1 单链表的定义和表示 ####

	typedef struct LNode
	{
		ElemType data;
		struct LNode *next;
	}LNode, *LinkList;

1. 单链表每个节点的存储结构
2. 在此对同一结构体指针类型起了两个名称，LinkList与LNode 、\*，两者本质上是等价的。例如，若定义LinkList L，则L为单链表的头指针，若定义LNode *p，则p为指向单链表中某个结点的指针，用*p代表该结点。

#### 2.5.2 单链表基本操作的实现 ####

**1. 初始化**

1. 生成新结点作为头结点，用头指针L指向头结点。
2. 头结点的指针域置空。

**2. 取值**

1. 用指针p指向首元结点，用j做计数器初值赋为1
2. 从首元结点开始依次顺着链域next向下访问，只要指向当前结点的指针p不为空（NULL），并且没有到达序号为i的结点，则循环执行以下操作：
	* p指向下一个结点；
	* 计数器j相应加1.


**3. 查找**

1. 用指针p指向首元结点。
2. 从首元节点开始依次顺着链域next向下查找，只要指向指向当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作：p指向下一个结点。
3. 返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。

**4. 插入**

	s->next = p->next;
	p->next = s;

将值为e的新结点插入到表的第i个结点的位置上，即插入到结点ai-1与ai之间

1. 查找结点a~i-1~并由指针p指向该结点。
2. 生成一个新结点*s
3. 将新结点\*s的数据域置为e。
4. 将新结点\*s的指针域指向结点a~i~。
5. 将新结点\*p的指针域指向结点\*s。

**5. 删除**

1. 查找结点a~i-1~并由指针p指向该结点。
2. 临时保存待删除结点a~i~的地址在q中，以备释放
3. 将结点\*p的指针域指向a~i~的直接后继结点
4. 释放结点a~i~的空间

**6. 创建单链表**

（1）前插法

1. 创建一个只有头结点的空链表。
2. 根据待创建链表包括的元素个数n，循环n次执行以下操作：
	* 生成一个新结点*p；
	* 输入元素值赋给新结点*p的数据域。
	* 将新结点*p插入到头结点之后

前插法的创建过程，因为每次插入在链表的头部，应该逆位输入数据，依次输入e、d、c、b、a

（2）尾插法

1. 创建一个只有头结点的空链表
2. 尾指针r初始化，指向头结点
3. 根据创建链表包括的元素个数n，循环n次执行以下操作：
	* 生成一个新结点\*p
	* 输入元素值赋给新结点*p的数据域；
	* 将新结点*p插入到尾结点*r之后；
	* 尾指针r指向新的尾结点*p

#### 2.5.3 循环链表 ####

循环链表（Circular Linked List）是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。

	p != L;
	p->next != L;

#### 2.5.4 双向链表 ####

双向链表（Double Linked List）

	typedef struct DuLNode
	{
	    ElemType data;
	    struct DuLNode *prior;
	    struct DuLNode *next;
	}DuLNode, *DuLinkList;

	d->next->prior = d->prior->next = d;

* 双向链表的插入
* 双向链表的删除

###  2.6 线性表的类型定义  ###

#### 2.6.1 空间性能的比较  ####

**（1）存储空间的分配**

* 顺序表：预先分配，元素个数扩充受一定限制
* 链表：不需要为其预先分配空间，只要内存允许，链表中的元素个数就没有限制

**（2）存储密度的大小**

#### 2.6.2 时间性能的比较 ####

**（1）存取元素的效率**

* 顺序表：O(1)，一种随机存取结构，指定任意一个位置序号i，都可以在O(1)时间内直接存取该位置上的元素
* 链表：O(n)，只能从表头开始依次向后遍历链表，直到找到第i个位置上的元素。

**（2）插入和删除操作的效率**

* 顺序表
* 链表

### 2.7 线性表的应用 ###

#### 2.7.1 线性表的合并 ####

1. 分别获取LA表长m和LB表长n。
2. 从LB从第1个数据元素开始，循环n次执行以下操作：
	* 从LB中查找第i（1<=i<=n）个数据元素赋给e；
	* 从LA中查找元素e，如果不存在，则将e插在表LA的最后。 

#### 2.7.2 有序表的合并 ####

**1. 顺序有序表的合并**

1. 创建一个表长为m+n的空表LC。
2. 指针pc初始化，指向LC的第一个元素。
3. 指针pa和pb初始化，分别指向LA和LB的第一个元素。
4. 当指针pa和pb均未到达相应表尾时，则依次选择比较pa和pb所指向的元素值，从LA或LB中“摘取”元素值较小的结点插入到LC的最后。
5. 如果pb已到达LB的表尾，依次将LA的剩余元素插入LC的最后。
6. 如果pa已到达LA的表尾，依次将LB的剩余元素插入LC的最后。

**2. 链式有序表的合并**

1. 指针pa和pb初始化，分别指向LA和LB的第一个结点。
2. LC的结点取值为LA的头结点。
3. 指针pc初始化，指向LC的头结点。
4. 当指针pa和pb均未到达相应表尾时，则依次比较pa和pb所指向的元素值，从LA或LB中“摘取”元素值较小的结点插入到LC的最后。
5. 将非空表的剩余段插入到pc所指结点之后。
6. 释放LB的头结点

若线性表中的数据元素相互之间可以比较，并且数据元素在线性表中依值非递减或非递增有序排列，则称该线性表为*有序表（Ordered List）*。

有序集合是指集合中的元素有序排列。已知两个有序集合A和B，数据元素按值非递减有序排列，现要求一个新的集合C=AUB，使集合C中的数据元素仍按值非递减有序排列。

### 2.8 案例分析与实现 ###

### 2.9 ###

1. 线性表的逻辑结构特性是指数据元素之间存在着线性关系
	*  顺序存储结构（顺序表）
	*  链式存储结构（链表）
2. 顺序表可借数组表示（随机存取），链表依靠指针来反映其线性逻辑关系（顺序存取）。
3. 循环链表和双向链表

## 第3章 栈和队列 ##

### 3.1 栈和队列的定义和特点 ###

#### 3.1.1 栈的定义和特点 ####

* 栈（stack）：限定仅在表尾进行插入或删除操作的线性表。
* 栈顶（top）：对栈来说，表尾端有其特殊含义
* 栈底（bottom）：表头端
* 空栈：不含元素的空表
* 特点：后进先出

#### 3.1.2 队列的定义和特点 ####

队列（queue）
* 特点：先进先出

### 3.2 案例引入 ###

* 数制的转换
* 括号匹配的校验
* 表达式求职
* 舞伴问题

### 3.3 栈的表示和操作的实现 ###

#### 3.3.1 栈的类型定义 ####

栈的基本操作除了入栈和出栈外，还有栈的初始化、栈空的判定，以及取栈顶元素等。

#### 3.3.2 顺序栈的表示和实现 ####

顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。

* base为栈底指针
* top为栈顶指针，其初值指向栈底。
	* 每当插入新的栈顶元素时，指针top增1。
	* 删除栈顶元素时，指针top减1。 
	* 栈空时，top和base的值相等，都指向栈底。

#### 1. 初始化 ####

顺序栈的初始化操作就是为顺序栈动态分配一个预定义大小的数组空间。

1. 为顺序栈动态分配一个最大容量为MAXSIZE的数组空间，使base指向这段空间的基地址，即栈底。
2. 栈顶指针top初始为base，表示栈为空。
3. stacksize置为栈的最大容量MAXSIZE。

#### 2. 入栈 ####

入栈操作是指在栈顶插入一个新的元素。

1. 判断栈是否满，若满则返回ERROR。
2. 将新元素压入栈顶，栈顶指针加1.

#### 3. 出栈 ####

出栈操作是将栈顶元素删除。

1.  判断栈是否空，若空则返回ERROR。
2.  栈顶指针减1，栈顶元素出栈。

#### 4. 取栈顶元素 ####

当栈非空时，此操作返回当前栈顶元素的值，栈顶指针保持不变。

由于顺序栈和顺序表一样，受到最大空间容量的限制，虽然可以在“满员”时重新分配空间扩大容量，但工作量较大，应该尽量避免。因此在应用程序无法预先估计栈可能达到的最大容量时，还是应该使用下面介绍的链栈。

1. 工作量大
2. 程序无法预估栈的大小

### 3.3.3 链栈的表示和实现 ###

链栈是指采用链式存储结构实现的栈。

于栈的主要操作是在栈顶插入和删除，显然以链表的头部作为栈顶是最方便的，而且没必要像单链表那样为了操作方便附加一个头结点。

#### 1. 初始化 ####

链栈的初始化操作就是构造一个空栈，因为没必要设头结点，所以直接将栈顶指针置空即可。

#### 2. 入栈 ####

和顺序栈的入栈操作不同的是，链栈在入栈前不需要判断栈是否满，只需要为入栈元素动态分配一个结点空间

1. 为入栈元素e分配空间，用指针p指向
2. 将新结点数据域置为e。
3. 将新结点插入栈顶。
4. 修改栈顶指针为p。

#### 3. 出栈 ####

和顺序栈一样，链栈在出栈前也需要判断栈是否为空，不同的是，链栈在出栈后需要释放出栈元素的栈顶空间

1. 判断栈是否为空，
2. 将栈顶元素赋给e。
3. 临时保存栈顶元素的空间，以备释放。
4. 修改栈顶指针，指向新的栈顶元素。
5. 释放原栈顶元素的空间。

#### 4. 取栈顶元素 ####

与顺序栈一样，当栈非空时，此操作返回当前栈顶元素的值，栈顶指针S保持不变。

### 3.4 栈与递归 ###

栈有一个重要应用是在程序设计语言中实现递归。

#### 3.4.1 采用递归算法解决的问题 ####

**1. 定义是递归的**

采用“分治法”进行递归求解的问题需要满足以下三个条件：

1. 能将一个问题转变成一个新的问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律。
2. 可以通过上述转化而使问题简化
3. 必须有一个明确的递归出口，或称递归的边界。

	void p(参数表)
	{
		if (递归结束条件成立) 可直接求解;
	归终止的条件
		else p(较小的参数);
	步骤
	}

**2. 数据结构是递归的**

遍历输出链表中各个结点的递归算法

1. 如果p为NULL，递归结束返回。
2. 否则输出p->data，p指向后继结点继续递归

**3. 问题的解法是递归的**

1. n阶Hanoi塔问题
2. 八皇后问题
3. 迷宫问题

#### 3.4.2 递归工程与递归工作栈 ####

与汇编语言程序设计中主程序和子程序之间的链接及信息交换相类似，在高级语言编制的程序中，调用函数和被调用函数之间的链接及信息交换需通过栈来进行。

当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成3件事：

1. 将所有的实参、返回地址等信息传递给被调用函数保存；
2. 为被调用函数的局部变量分配存储区；
3. 将控制转移到被调函数的入口。

而从被调用函数返回调用函数之前，系统也应完成3件工作：

1. 保存被调函数的计算结果；
2. 释放被调函数的数据区；
3. 依照被调函数保存的返回地址将控制转移到调用函数。

当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶。

### 3.4.3 递归算法的效率分析 ###

#### 1. 时间复杂度的分析 ####

采用这种方法计算Fibonacci数列和Hanoi塔问题递归算法的时间复杂度均为O(2^n)。

#### 2. 时间复杂度的分析 ####

其中，f(n)为“递归工作栈”中工作记录的个数与问题规模n的函数关系。根据这种分析方法不难得到，前面讨论的阶乘问题、Fibonacci数列问题、Hanoi塔问题的递归算法的空间复杂度均为O(n)。

### 3.4.4 利用栈将递归转换为非递归的方法 ###

### 3.5 队列的表示和

#### 3.5.1 队列的类型定义 ####

#### 3.5.2 循环队列——队列的顺序表示和实现 ####

队列也有两种存储表示，顺序表示和链式表示。

* 队空：front = rear
* 每当插入新的队列尾元素时，尾指针rear增1；
* 每当删除队列头元素时，头指针front增1。

#### 循环队列 ####

*事实上，此时队列的实际可用空间并未占满，所以这种现象称为“假溢出”。这是由“队尾入队，队头出队”这种受限制的操作造成的。*

解决这个问题，所以出现了*循环队列*。

通常有以下两种处理方法：

1. 少用一个元素空间，即队列空间大小为m时，有m-1个元素就认为是队满。这样判断队空的条件不变，即当头、尾指针的值相同时，则认为队空；而当尾指针在循环意义上加1后是等于头指针，则认为队满。因此，在循环队列中队空和队满的条件是：
	* 队空的条件：Q.front==Q.rear
	* 队满的条件：(Q.rear+1)%MAXQSIZE==Q.front
2. 另设一个标志位以区别队列是“空”还是“满”。

#### 1. 初始化 ####

循环队列的初始化操作就是动态分配一个预定义大小为MAXQSIZE的数组空间。

1. 为队列分配一个最大容量为MAXQSIZE的数组空间，base指向数组空间的首地址。
2. 头指针和尾指针置为零，表示队列为空。

### 3.5.3 链队——队列的链式表示和实现 ###

一个链队显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定。

#### 1. 初始化 ####

链队的初始化操作就是构造一个只有一个头节点的空队。

1. 生成新结点作为头结点，队头和队尾指针指向此结点。
2. 头结点的指针域置空。

#### 2. 入队 ####

和循环队列的入队操作不同的是，链队在入队前不需要判断队是否满，需要为入队元素动态分配一个结点空间

1. 为入队元素分配结点空间，用指针p指向。
2. 将新结点数据域置为e。
3. 将新结点插入到队尾。
4. 修改队尾指针为p。

### 3.6 案例分析与实现 ###

* 数制转换
* 括号匹配的校验
* 表达式求值
* 舞伴问题

### 3.7 小结 ###

特殊的线性表：栈和队列：

1. 栈是限定仅在表尾进行插入或删除的线性表，又称为后进先出的线性表。两种存储表示：顺序表示（顺序栈）和链式表示（链栈）
2. 队列是一种先进先出的线性表。它只允许在表的一端进行插入，而在另一端删除元素。队列有
3. 栈和队列的比较
4. 栈有一个重要应用是在程序设计语言中实现递归。递归是程序设计中最为重要的方法之一，递归程序结构清晰，形式简洁。但递归程序在执行时需要系统提供隐式的工作栈来保存调用过程中的参数、局部变量和返回地址，因此递归程序占用内存空间较多，运行效率较低。

## 第4章 串、数组和广义表 ##

### 4.1 串的定义 ###

* 串（string）（或字符串）：是由零个或多个字符组成的有限序列s=“a1a2 … an”(n≥0)，其中，s是串的名，用双引号括起来的字符序列是串的值；ai(1≤i≤n)可以是字母、数字或其他字符；串中字符的数目n称为串的**长度**。
* 空串：零个字符的串称（null string），其长度为零。
* 字串：串中任意个连续的字符组成的子序列称为*字串*。
* 主串：包含字串的串相应地称为*主串*。
* 位置：通常称字符在序列中的序号为该字符在串中的*位置*。
* 空格串：一个或多个空格组成的串" "。

### 4.2 案例引入 ###

字符串在实际中有极为广泛的应用，在文字编辑、信息检索、语言编译等软件系统中，字符串均是重要的操作对象；在网络入侵检测、计算机病毒特征码匹配以及DNA序列匹配等应用中，都需要进行串匹配，也称模式匹配。

1. 病毒感染检测

### 4.3 串的类型定义、存储结构及其运算 ###

#### 4.3.1 串的抽象类型定义 ####

#### 4.3.2 串的存储结构 ####

**1. 串的顺序存储**

类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。

在C语言中，存在一个称之为“堆”（Heap）的自由存储区，可以为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时为了以后处理方便，约定串长也作为存储结构的一部分。

**2. 串的链式存储**

#### 4.3.3 串的模式匹配算法 ####

子串的定位运算通常称为*串的模式匹配或串匹配*。搜索引擎、拼写检查、语言翻译、数据压缩等应用中，都需要进行串匹配。

串的模式匹配设有两个字符串S和T，设S为主串，也称正文串；设T为子串，也称为模式。

**1. BF算法**

最简单只管的模式匹配算法式BF（Brute-Force）算法。

**2. KMP算法**

**计算next函数值**

### 4.4 数组 ###

#### 4.4.2 数组的顺序存储 ####

#### 4.4.3 特殊矩阵的压缩存储 ####

**1. 对称矩阵**

**2. 三角矩阵**

**3. 对焦矩阵**

### 4.5 广义表 ###

### 4.6 案例分析与实现 ###

### 4.7 小结 ###

三种数据结构：串、数组和广义表

1. 串是内容受限的线性表，它限定了表中的元素为字符。串有两种基本存储结构：顺序存储和链式存储，但多采用顺序存储结构。串的常用算法是模式匹配算法，主要有BF算法和KMP算法。BF算法实现简单，但存在回溯，效率低，时间复杂度为O(m×n)。KMP算法对BF算法进行改进，消除回溯，提高了效率，时间复杂度为O(m+n)。
2. 多维数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。一个n维数组实质上是n个线性表的组合，其每一维都是一个线性表。数组一般采用顺序存储结构，故存储多维数组时，应先将其确定转换为一维结构，有按“行”转换和按“列”转换两种。科学与工程计算中的矩阵通常用二维数组来表示，为了节省存储空间，对于几种常见形式的特殊矩阵，比如对称矩阵、三角矩阵和对角矩阵，在存储时可进行压缩存储，即为多个值相同的元只分配一个存储空间，对零元不分配空间。
3. 广义表是另外一种线性表的推广形式，表中的元素可以是称为原子的单个元素，也可以是一个子表，所以线性表可以看成广义表的特例。

要求掌握串的存储方法，理解串的两种模式匹配算法——BF算法和KMP算法。明确数组和广义表这两种数据结构的特点，掌握数组存储时地址计算方法，掌握几种特殊矩阵的压缩存储方法，了解广义表的两种链式存储结构。

## 第5章 树和二叉树 ##



## 第6章 图 ##

## 第7章 查找 ##

## 第8章 排序 ##

### 8.1 基本概念和排序方法概述 ###

#### 8.1.1 排序的基本概念 ####

**1. 排序**

**2．排序的稳定性**

假设Ki=Kj（1≤i≤n，1≤j≤n，i≠j），且在排序前的序列中Ri领先于Rj（即i<j）。若在排序后的序列中Ri仍领先于Rj，则称所用的排序方法是*稳定*的；反之，若可能使排序后的序列中Rj领先于Ri，则称所用的排序方法是*不稳定*的。

**3. 内部排序和外部排序**

根据在排序过程中记录所占用的存储设备，可将排序方法分为两大类：

1. 一类是**内部排序**，指的是待排序记录全部存放在计算机内存中进行排序的过程；
2. 另一类是**外部排序**，指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程

#### 8.1.2 内部排序方法的分类 ####

在排序的过程中，可以将排序记录区分为两个区域：有序序列区和无序序列区。

1. 插入类：将无序子序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序子序列的长度。主要包括直接插入排序、折半插入排序和希尔排序。
2. 交换类：通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。主要包括冒泡排序和快速排序。
3. 选择类：从记录的无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。主要包括简单选择排序、树形选择排序和堆排序。
4. 归并类：通过“归并”两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度。2-路归并排序是最为常见的归并排序方法。
5. 分配类：是唯一一类不需要进行关键字之间比较的排序方法，排序时主要利用分配和收集两种基本操作来完成。基数排序是主要的分配类排序方法。

#### 8.1.3 待排序记录的存储方式 ####

1. 顺序表：记录之间的次序关系由其存储位置决定，实现排序需要移动记录。
2. 链表：记录之间的次序关系由指针指示，实现排序不需要移动记录，仅需修改指针即可。这种排序方式称为链表排序。
3. 待排序记录本身存储在一组地址连续的存储单元内，同时另设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向量中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置。这种排序方式称为地址排序。

#### 8.1.4 排序算法效率的评价指标 ####

1. 执行时间

2. 辅助空间

### 8.2 插入排序 ###

插入排序的基本思想是：每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。直接插入排序、折半插入排序和希尔排序。

#### 8.2.1 直接插入排序 ####

*直接插入排序*（Straight Insertion Sort）是一种最简单的排序方法，其基本操作是将一条记录插入到已排好序的有序表中，从而得到一个新的、记录数量增1的有序表。

**算法步骤**

1. 设待排序的记录存放在数组r[1..n]中，r[1]是一个有序序列。
2. 循环n−1次，每次使用顺序查找法，查找r[i]（i=2,…,n）在已排好序的序列r[1…i−1]中的插入位置，然后将r[i]插入表长为i−1的有序序列r[1…i−1]，直到将r[n]插入表长为n−1的有序序列r[1…n-1]，最后得到一个表长为n的有序序列。

在具体实现r[i]向前面的有序序列插入时，有两种方法：

1. 一种是将r[i]与r[1],r[2], …, r[i-1]从前向后顺序比较；
2. 另一种是将r[i]与r[i−1], r[i−2], …, r[1]从后向前顺序比较。