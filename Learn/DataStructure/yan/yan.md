# 数据结构（C语言版）（第2版） #

## 第1章 绪论 ##

### 1.1 什么是数据结构 ###

### 1.2 基本概念和术语 ###

#### 1.2.1 数据、数据元素、数据项和数据对象 ####

* 数据
* 数据元素
* 数据项
* 数据对象

#### 1.2.2 数据结构 ####

1. 逻辑结构
2. 存储结构

#### 1.2.3 数据类型和抽象数据类型 ####

1. 数据类型
2. 抽象数据类型

ADT

### 1.3 抽象数据类型的表示和实现 ###

（1） 预定义常量和类型：

	//函数结果状态代码
	#define TRUE 1
	#define FALSE 0
	#define OK 1
	#define ERROR 0
	#define INFEASIBLE -1
	#define OVERFLOW -2
	// Status是函数的类型，其值是函数结果状态代码
	typedef int Status;

（2） 数据结构的表示（存储结构）用类型定义（typedef）描述；数据元素类型约定为ElemType，由用户在使用该数据类型时自行定义。

（3）基本操作的算法都用如下格式的函数来描述
（4）内存的动态分配与释放

使用new和delete动态分配和释放内存空间：

	分配空间 指针变量=new数据类型；
	释放空间 delete指针变量；

（5）赋值语句：
（6）原则语句：
（7）循环语句
（8）结束语句

	函数结束语句 return 表达式;
			    return;
	case 结束语句 break;
	异常结束语句 exit(异常代码);

（9）输入输出语句

	输入语句 cin>>变量1>>...>>变量n;
	输出语句 cout<<表达式1<<...<<表达式n;
	输入语句 scanf([格式串]，变量1，...，变量n);
	输出语句 printf([格式串]，变量1，...，变量n);

（10）基础函数

	求最大值
	求最小值										

	求最大值 max(表达式，...，表达式n)
	求最小值 min(表达式，...，表达式n)
	求绝对值 abs(表达式)
	求不足整数值 floor表达式)
	求进位整数值 ceil(表达式)
	判定文件结束 eof(文件变量)或eof
	判定行结束 eoln(文件变量)或eoln

(11) 逻辑运算约定

与运算&&: 对于A&&B，当A的值为0时，不再对B求值。
与运算||: 对于A||B，当A的值为非0时，不再对B求值。

> elemtype必须是具体的数值类型，比如int,double......书上的一般是伪码，不能直接当程序运行的
> elemtype在VC中没有这种类型，所以在使用它之前对其定义如 
> typedef int ElemType将ElemType定义为整型的数据类型
> typedef int Status
> 数据结构里讲的Status都是它。
> overflow
>       一般用于exit的参数中，比如创建指针时，一般判断一下内存是否分配成功，不成功一般调 
>      用exit(overflow);
>  
> infeasible 其意思是不可行的，一般在某个判断中，如果什么什么不可行，就会return infeasible
> 例如：求后继元素时，如果是最后一个元素，则求其后继是不可行的，此时就会return infeasible
> 数据结构中error，overflow旳返回值这个没有特别的规定，可以根据程序的意图，或自己的习惯来定义。比如经常将error=0，overflow=-1

### 1.4 算法和算法分析 ###

#### 1.4.1 算法 ####

1. 有穷性 
2. 确定性 
3. 可行性 
4. 输入 
5. 输出

#### 1.4.2 算法设计的要求 #### 

1. 正确性
2. 可读性
3. 健壮性
4. 高效性：效率与低存储量需求，时间复杂度和空间复杂度

#### 1.4.3 算法的时间复杂度 ####

衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。

1. 问题规模和语句频度
2. 算法的时间复杂度定义
3. 算法的时间复杂度分析举例

#### 1.4.4 算法的存储空间需求 ####

空间复杂度（space complexity）作为算法所需存储空间的量度，记作S(n)=O(f(n))  

### 1.5 小结 ###

1. 数据结构的定义
2. 数据结构包括两个方面的内容：数据的逻辑结构和存储结构。同一逻辑结构采用不同的存储方法，可以得到不同的存储结构。
	* 逻辑结构是从具体问题抽象出来的数学模型，从逻辑关系上描述数据，它与数据的存储无关。
	* 存储结构是逻辑结构在计算机中的存储表示，有两类存储结构：顺序存储结构和链式存储结构。
3. 抽象数据类型
4. 算法是为了解决某类问题而规定的一个有限长的操作序列。
5. 算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，以考察算法的时间和空间效率。  

## 第2章 线性表 ##

### 2.1 线性表的类型定义和特点 ###

**线性表**是最常用且最简单的一种数据结构。

	ADT List {
		InitList(&L)，
		操作结果：构造一个空的线性表L
		DestoryList(&L)，
		初始条件：线性表L已存在
		操作结果：销毁线性表L
		ClearList(&L)
		初始条件：线性表L已存在
		操作结果：将L重置为空表
		ListEmpty(L)
		初始条件：线性表L已存在
		操作结果：若L为空表，则返回true，否则返回false
		ListDelete(&L, i)
		初始条件：线性表L已存在且非空，且l<=i<=ListLength(L)
		操作结果：删除L的第i个数据元素，L的长度减1。
		TraverseList(L)
		初始条件：线性表L已存在
		操作结果：对线性表L进行遍历，在遍历过程中对L的每个结点访问一次
	}

算法2.2
GetElem和ListInsert这两个操作的执行时间和表长无关，LocateElem的执行时间和表长成正比。·

### 2.2 案例引入 ###

线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。

### 2.3 线性表的类型定义 ###

	ADT LIST {
		InitList(&L)
		DestoryList(&L)
		ClearList(&L)
		ListEmpty(&L)
		ListLength(L)
		GetElem(L, i, &e)
		LocateElem(L, e)
		PriorElem(L, cur_e, &pre_e)
		NextElem(L, cur_e, &next_e)
		ListInsert(&L, i, e)
		ListDelete(&L, i)
		TraverseList(L)
	}

### 2.4 线性表的顺序表示和实现 ###

#### 2.4.1 线性表的顺序存储表示 ####

线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性的表的数据元素，这种表示也称作线性表的顺序存储结构。

	#define MAXSIZE 100
	typedef struct
	{
		ElemType *elem;
		int length;
	} SqList;

#### 2.4.2 顺序表中基本操作的实现 ####

**1. 初始化**

顺序表的初始化操作就是构造一个空的顺序表

1. 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址
2. 将表的当前长度设为0

**2.取值**

1. 判断指定的位置序号i值是否合理（1<=i<=L.length），若不合理，则返回ERROR
2. 若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的传值

**3. 查找**

1. 从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回改元素的序号i+1。
2. 若查遍整个顺序表都没有找到，则查找失败，返回0

在查找时，为确定元素在顺序表中的位置，需要给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的*平均查找长度（Average Search Length，ASL）*

**4. 插入**

1. 判断插入位置i是否合法（i值的合法范围是1≤i≤n+1），若不合法则返回ERROR。
2. 判断顺序表的存储空间是否已满，若满则返回ERROR。
3. 将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置（i=n+1时无需移动）。
4. 将要插入的新元素e放入第i个位置。
5. 表长加1。

**5. 删除**

1. 判断删除位置i是否合法（合法值为1<=i<=n），若不合法则

### 2.5 线性表的链式表示和实现 ###

#### 2.5.1 单链表的定义和表示 ####

	typedef struct LNode
	{
		ElemType data;
		struct LNode *next;
	}LNode, *LinkList;

1. 单链表每个节点的存储结构
2. 在此对同一结构体指针类型起了两个名称，LinkList与LNode 、\*，两者本质上是等价的。例如，若定义LinkList L，则L为单链表的头指针，若定义LNode *p，则p为指向单链表中某个结点的指针，用*p代表该结点。

#### 2.5.2 单链表基本操作的实现 ####

**1. 初始化**

1. 生成新结点作为头结点，用头指针L指向头结点。
2. 头结点的指针域置空。

**2. 取值**

1. 用指针p指向首元结点，用j做计数器初值赋为1
2. 从首元结点开始依次顺着链域next向下访问，只要指向当前结点的指针p不为空（NULL），并且没有到达序号为i的结点，则循环执行以下操作：
	* p指向下一个结点；
	* 计数器j相应加1.


**3. 查找**

1. 用指针p指向首元结点。
2. 从首元节点开始依次顺着链域next向下查找，只要指向指向当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作：p指向下一个结点。
3. 返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。

**4. 插入**

	s->next = p->next;
	p->next = s;

将值为e的新结点插入到表的第i个结点的位置上，即插入到结点ai-1与ai之间

1. 查找结点a~i-1~并由指针p指向该结点。
2. 生成一个新结点*s
3. 将新结点\*s的数据域置为e。
4. 将新结点\*s的指针域指向结点a~i~。
5. 将新结点\*p的指针域指向结点\*s。

**5. 删除**

1. 查找结点a~i-1~并由指针p指向该结点。
2. 临时保存待删除结点a~i~的地址在q中，以备释放
3. 将结点\*p的指针域指向a~i~的直接后继结点
4. 释放结点a~i~的空间

**6. 创建单链表**

（1）前插法

1. 创建一个只有头结点的空链表。
2. 根据待创建链表包括的元素个数n，循环n次执行以下操作：
	* 生成一个新结点*p；
	* 输入元素值赋给新结点*p的数据域。
	* 将新结点*p插入到头结点之后

前插法的创建过程，因为每次插入在链表的头部，应该逆位输入数据，依次输入e、d、c、b、a

（2）尾插法

1. 创建一个只有头结点的空链表
2. 尾指针r初始化，指向头结点
3. 根据创建链表包括的元素个数n，循环n次执行以下操作：
	* 生成一个新结点\*p
	* 输入元素值赋给新结点*p的数据域；
	* 将新结点*p插入到尾结点*r之后；
	* 尾指针r指向新的尾结点*p

#### 2.5.3 循环链表 ####

循环链表（Circular Linked List）是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。

	p != L;
	p->next != L;

#### 2.5.4 双向链表 ####

双向链表（Double Linked List）

	typedef struct DuLNode
	{
	    ElemType data;
	    struct DuLNode *prior;
	    struct DuLNode *next;
	}DuLNode, *DuLinkList;

	d->next->prior = d->prior->next = d;

* 双向链表的插入
* 双向链表的删除

###  2.6 线性表的类型定义  ###

#### 2.6.1 空间性能的比较  ####

**（1）存储空间的分配**

* 顺序表：预先分配，元素个数扩充受一定限制
* 链表：不需要为其预先分配空间，只要内存允许，链表中的元素个数就没有限制

**（2）存储密度的大小**

#### 2.6.2 时间性能的比较 ####

**（1）存取元素的效率**

* 顺序表：O(1)，一种随机存取结构，指定任意一个位置序号i，都可以在O(1)时间内直接存取该位置上的元素
* 链表：O(n)，只能从表头开始依次向后遍历链表，直到找到第i个位置上的元素。

**（2）插入和删除操作的效率**

* 顺序表
* 链表

### 2.7 线性表的应用 ###

#### 2.7.1 线性表的合并 ####

1. 分别获取LA表长m和LB表长n。
2. 从LB从第1个数据元素开始，循环n次执行以下操作：
	* 从LB中查找第i（1<=i<=n）个数据元素赋给e；
	* 从LA中查找元素e，如果不存在，则将e插在表LA的最后。 

#### 2.7.2 有序表的合并 ####

**1. 线性表**

1. 创建一个表长为m+n的空表LC。
2. 指针pc初始化，指向LC的第一个元素。
3. 指针pa和pb初始化，分别指向LA和LB的第一个元素。
4. 当指针pa和pb均未到达相应表尾时

**2. 链式表**

### 2.8 案例分析与实现 ###

### 2.9 ###

1. 线性表的逻辑结构特性是指数据元素之间存在着线性关系
	*  顺序存储结构（顺序表）
	*  链式存储结构（链表）
2. 顺序表可借数组表示（随机存取），链表依靠指针来反映其线性逻辑关系（顺序存取）。
3. 循环链表和双向链表

## 第3章 栈和队列 ##

第4章 串

第5章 数组和广义表

第6章 树和二叉树

第7章 图

第8章 动态存储管理

第9章 查找

第10章 查找

第11章 外部排序

第12章 文件