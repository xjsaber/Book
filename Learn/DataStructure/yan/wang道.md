# 数据结构考研复习指导

## 第1章 绪论 ##

### 考纲内容

### 知识框架

### 复习提示

### 1.1 操作系统的基本概念 ###

#### 1.1.1 基本概念和术语 ####

**1. 数据**

**2. 数据元素**

**3. 数据对象**

**4. 数据类型**

	1. 原子类型
 	2. 结构类型
 	3. 抽象数据类型

**5. 数据结构**

#### 1.1.2 操作系统的特征 ####

**1. 数据的逻辑结构**

数据的逻辑结构分为线性结构和非线性结构。

**2. 数据的存储结构**

1. 顺序存储
2. 链式存储
3. 索引存储
4. 散列存储：根据元素的关键字直接计算出该元素的存储地址，又称“哈希（Hash）”存储。

**3. 数据运算**


### 1.2 算法和算法评价 ###

#### 1.2.1 算法的基本概念

#### 1.2.2 算法效率的度量

## 第2章 线性表 ##

### 2.1 线性表的定义和基本操作 ###

#### 2.1.1 线性表的定义 ####

线性表是具有相同数据的n（n>=0）个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表。

* 表中元素的个数有限
* 表中元素具有逻辑上的顺序性，其中元素有其先后次序。
* 表中元素都是数据元素，每个元素都是单个元素。
* 其中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。

#### 2.1.2 线性表的基本操作 ####

一个数据结构的基本操作是指其最核心、最基本的操作。

	InitList(&L):初始化表。构造一个空的线性表。
	Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。
	LocateElem（L，e）：求值查找操作。在表L中查找具有给定关键字值的元素。
	GetElem(L,i)：按位查找操作。
	ListInsert(&L, i, e):插入操作。在表L中的第i
	ListDelete(&L, i, e):删除操作。
	PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值。
	Empty(L):判空操作。若L为空表，则返回true，否则返回false。
	DestoryList(&L):销毁操作。销毁线性表，并释放线性表L所占用的内存空间。

### 2.2 线性表的顺序表示 ###

```
#define MaxSize 50	// 定义线性表的最大长度
typedef struct {
	ElemType data[MaxSize]; //顺序表的元素
	int length;	//顺序表的当前长度
}SqList;	// 顺序表的类型定义
```

一维数组可以是静态分配的，也可以是动态分配的。

	* 在静态分配时，由于数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序崩溃
	* 在动态分配时，存储数组的空间是在程序执行过程中通过存储分配语句分配的，一旦数据空间占满，再加上新的数据将会产生溢出，进而

#define InitSize 100 //表长度的初始定义
typedef struct { 
	ElemType *data; //指示动态分配数组的指针
	int MaxSize, length; //数组的最大容量和当前个数
}SqList; //动态分配数组顺序表的类型定义

#### 2.2.1 顺序表的定义 ####

	L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
	
	L.data = new ElemType[InitSize];

#### 2.2.2 顺序表上基本操作的实现 ####

### 2.3 线性表的链式表示 ###

#### 2.3.1 单链表的定义 ####

#### 2.3.2 单链表上基本操作的实现 ####

**1. 采用头插法建立单链表**

**2. 采用尾插法建立单链表**

**3. 按序号查找结点值**

4. 按值查找表节点

5. 插入节点操作

6. 删除结点操作

7. 求表长操作

2.3.3 双链表

## 第3章 栈和队列 ##

### 考纲内容 ###

### 知识框架 ###

### 复习提示 ###

### 3.1栈 ###

#### 3.1.1 栈的基本概念

**1.栈的定义**

栈（Stack）是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在一端进行插入和删除操作。

* 栈顶（Top）。线性表允许进行插入删除的那一端。
* 栈底（Bottom）。固定的，不允许进行插入和删除的另一端。
* 空栈。不含任何元素的空表。

**2.栈的基本操作**

* InitStack(&S)：初始化一个空栈S。
* StackEmpty(S)：判断一个栈是否为空，若栈S为空则返回true，否则返回false。
* Push(&S, x)：出栈，若栈S未满，则将x加入使之成为新栈顶。
* Pop(&S, &x)：读栈顶元素，若栈S非空，则弹出栈顶元素，并用x返回。
* GetTop(S, &x)：读栈顶元素，若栈S非空，则用x返回栈顶元素。
* DestoryStack(&S)：销毁栈，并释放栈S占用的存储空间（“&”表示引用调用）

#### 3.1.2 栈的顺序存储结构

**1.顺序栈的实现**

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）	指示当前栈顶元素的位置。

* 栈的顺序存储类型：

* 栈顶指针
* 进栈操作
* 出栈操作
* 栈空条件

**2.顺序栈的基本运算**

1. 初始化
2. 判栈空
3. 进栈
4. 出栈
5. 读栈顶元素

**3.共享栈**

利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。

两个栈的栈顶指针都指向栈顶元素，`top0=-1`时0号栈为空，`top1=MAXSIZE`时1号栈为空；仅当两个栈顶指针相邻（top1-top0=1）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时刚好相反。

#### 3.1.3 栈的链式存储结构

采用链式存储的栈称为链栈。

typedef struct Linknode {

​	ElemType data;	//数据域

​	struct Linknode *next; //指针域

}	*LinkedStack //栈类型定义

### 3.2 队列

#### 3.2.1 队列的基本概念

1.**队列的定义**

队列（Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为*入队*和*进队*；删除元素称为*出队*和*离队*。

先进先出

* 队头（Front）。允许删除的一端，又称队首。
* 队尾（Rear）。允许插入的一端。
* 空队列。不含任何元素的空表。

2. **队列的常见操作**

* InitQueue(&Q)：初始化队列，构造一个空队列Q。
* QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。
* EnQueue(&Q, x)：入队，若队列Q非满，将x加入，使之成为新的队尾。
* DeQueue(&Q, &x)：出队，若队列Q非空，删除队头元素，并用x返回。
* GetHead(Q, &x)：读队头元素，若队列Q非空，则将队头元素赋值给x。

#### 3.2.2 队列的顺序存储结构

1. **队列的顺序存储**

队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置。

```
typedef struct {
    ElemType data[MAXSIZE]; //数据域
    int front, rear;    //队头和队尾指针
};
```

* 初始状态（队空条件）：`Q.front == Q.rear == 0`

* 进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。

* 出队操作：队不空时，先取队头元素值，再将队头指针加1。

  ```
  Q.rear == MAXSIZE
  ```

  不能作为队列满的条件。

**2.循环队列**

将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针`Q.front=MAXSIZE-1`后，再前进一个位置就自动到0，利用除法运算(%)来实现。

* 初始时：Q.front=Q.rear=0

* 队首指针进1：Q.front=(Q.front+1)%MAXSIZE

* 队尾指针进1：Q.rear=(Q.rear+1)%MAXSIZE

* 队列长度：(Q.rear+MAXSIZE-Q.front)%MAXSIZE

* 出队入队时，指针都按顺时针方向进1。

  为了区分队空还是队满的情况，有三种处理方式：

  1. 牺牲一个单元来区分队空和队满
     1. 队满条件：`(Q.rear+1)%MAXSIZE==Q.front`
     2. 队空条件：`Q.front==Q.rear`。
     3. 队列中元素的个数：`(Q.rear-Q.front+MAXSIZE)%MAXSIZE`。
  2. 类型中增设元素个数的数据成员
  3. 类型中增设tag数据成员

**3.循环队列的操作**

1. 初始化

#### 3.2.3 队列的链式存储结构



#### 3.2.4 双端队列



### 3.3 栈和队列的应用



## 第4章 串

### 考纲内容

### 知识框架

### 复习提示

### 4.1 串的定义和实现

字符串简称串，计算机上非数值处理的对象基本都是字符串数据。

#### 4.1.1 串的定义

#### 4.1.2 串的存储j结构



## 第5章 树与二叉树

### 考纲内容

1. 树的基本概念
2. 二叉树
3. 树、森林
4. 树与二叉树的应用

### 知识框架

### 5.1 树的基本概念

#### 5.1.1 树的定义

#### 树是n（n>=0）个节点的有限集。当n=时，称为空树。

#### 5.1.2 基本术语

#### 5.1.3 树的性质

### 5.3 二叉树的遍历和线索二叉树

#### 5.3.1 二叉树的遍历

1. **先序遍历**
2. **中序遍历**
3. 



## 第6章 图 ##

### 考试内容 ###

### 知识框架 ###

### 6.1 图的基本概念 ###

#### 6.1.1 图的定义 ####

1. 图：由结点的有穷集合V和边的集合E组成。
2. 有向图：每条边都有方向
3. 弧：在有向图中，通常边称为弧，含箭头的一端称为弧头，另一端称为弧尾，记作<vi,vj>
4. 度：在无向图中，边记为(V<sub>i</sub>,)
5. 有向完全图和无向完全图：若有向图中有n个顶点，最多有n(n-1)条边（图中任意两个顶点都有两条边相连），将具有n(n-1)条边的有向图称为有向完全图。若无向图中有n个顶点，则最多有n(n-1)/2条边(任意两个顶点之间都有一条边)，将具有n(n-1)/2条边的无向图称为无向完全图。
6. 路径和路径长度：在一个图中，路径为相邻顶点序偶所构成的序列。
7. 简单路径：序列中顶点不重复出现的路径称为简单路径。
8. 回路：若一条路径中第一个顶点和最后一个顶点相同，则这条路径是一条回路。
9. 连通、连通图和连通份量：如果图中任意两个顶点之间都连通，则称该图为连通图；否则，图中的极大连通子图称为连通分量。
10. 强连通图和强连通分量
11. 权和网
12. 路径、路径长度和回路
13. 简单路径、简单回路
14. 距离
15. 有向图

### 6.2 图的存储及基本操作 ###

#### 6.2.1 邻接矩阵法 ####

所谓邻接矩阵存储，是指用一个一维数组存储图顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。

#### 6.2.2 邻接表法 ####

#### 6.2.3 十字链表 ####

#### 6.2.4邻接多重表 ####

#### 6.2.5 图的基本操作

* Adjacent(G, x, y)：判断图G是否存在边<x, y>或(x, y)。
* Neighbors(G, x)：列出图G与结点x邻接的边。
* InsertVertex(G, x)：在图G中插入顶点x。
* DeleteVertex(G, x)：在图G中删除顶点x。
* AddEdge(G, x, y)：若无向边(x, y)或有向边<x, y>不存在，则向图G中添加该边。
* RemoveEdge(G, x, y)：若无向边(x, y)或有向边<x, y>存在，则从图G中删除该边。
* FirstNeighbor(G, x)：求图G中顶点的x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
* NextNeighbor(G, x)：假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。
* Get_edge_value(G, x, y)：获取图G中边（x, y）或<x, y>中对应的权值。
* Set_edge_value(G, x, y, v)：设置图G中边（x, y）或<x, y>中对应的权值。

### 6.3 图的遍历

为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组visited[]来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。

#### 6.3.1 广度优先搜索 ####


