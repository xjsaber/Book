# 数据结构考研复习指导 #

## 第1章 绪论 ##

### 1.1 针对考研数据结构的代码书写规范以及C与C++语言基础 ###

#### 1.1.1 考研综合应用题中算法设计部分的代码书写规范 ####

#### 1.1.2 考研中的C与C++语言基础 ####

#### 1. 数据结构 ####

**（1）结构型**

**（2）指针型**

```
int *a;
char *b;
float *c;
TypeA *d;
```

**（3）结点的构造**

要构造一种结点，必须先定义结点的结构类型。

1. 链表结点的定义

   链表的结点有两个域

2. 

### 1.2 算法的时间复杂度与空间复杂度分析基础 ###

#### 1.2.1 考研中的算法时间复杂度分析 ####



#### 1.2.2 例题选讲 ####

#### 1.2.3 考研中的算法空间复杂度分析 ####

### 1.3 数据结构和算法的基本概念 ###

#### 1.3.1 数据结构的基本概念 ####

#### 1.3.2 算法的基本概念 ####

## 第2章 线性表 ##

### 大纲要求

* 线性表的定义和基本操作
* 线性表的实现
  * 顺序存储结构
  * 链式存储结构
  * 线性表的应用

### 考点要点分析

#### 核心考点

1. 线性表的定义和基本操作
2. 线性表的存储结构
3. 线性表的应用

#### 基础考点

### 2.1 线性表的基本概念与实现 ###

**1. 线性表的定义**

* 定义：线性表是具有相同特性数据元素的一个**有序**序列。
* 个数：该序列中所含元素的**个数**叫做线性表的长度，用n表示。

**2. 线性表的逻辑特性**

线性表只有一个表头元素，只有一个表尾元素，表头元素没有前驱，表尾元素没有后继，除表头和表尾元素之外，其他元素只有一个直接前驱，也只有一个直接后继。

**3. 线性表的存储结构**

1. 顺序表

2. 链表

3. 两种存储结构的比较
   * 顺序表
     * 随机访问特性
     * 占用连续的存储空间
     * 顺序表做插入操作的时候要移动多个元素
   * 链表
     * 不支持随机访问特性
     * 结点的存储空间利用率较顺序表稍低一些
     * 支持存储空间的**动态分配**
     * 链表中进行插入操作无须移动元素

链表的五种形式：在每个结点中除了包含数据域外，

1. 单链表

   1. 带头结点的单链表，头指针head指向头结点，头结点的值域。
   2. 不带头结点的单链表的头指针head直接指向开始结点。	

   头指针和头结点的区别。

2. 双链表

   双链表也分为带头结点的双链表和不带头结点的双链表。

   * 带头结点的双链表，当head->next为NULL时链表为空。
   * 不带头结点的双链表，当head为NULL时链表为空。

3. 循环单链表

4. 循环双链表

5. 静态链表

### 2.2 线性表的结构体定义和基本操作 ###

#### 2.2.1 线性表的结构体定义 ####

	#define maxSize 100

1. 顺序表的结构体定义

	typedef struct
	{	
		int data[maxSize];
		int length;
	}SqlList;

2. 单链表结点定义

	typedef struct LNode
	{	
		int data;
		struct LNode *next;
	}LNode;

3. 双链表结点定义

#### 2.2.2 顺序表的操作 ####

## 第3章 栈和队列 ##

### 3.1 栈和队列的基本概念 ###

#### 3.1.1 栈的基本概念 ####

**1. 栈的定义**




## 第4章 串 ##

### 4.1 串数据类型的定义 ###

#### 4.1.1 串的定义 ####

* 串：串是由零个或者多个字符组成的有限序列。
* 串的长度：串中字符的个数称为串的长度。
* 空串：含有零个元素的串叫做空串。
* 字串：串中任意连续的字符组成的子序列称为该串的字串。
* 主串：包含字串的串称为主串。
* 空格串：由一个或多个空格组成的串称为空格串，空格也是串字符集合的一个元素（注意，空格串不是空串）

	char str[] = "abcdef";

#### 4.1.2 串的存储结构 ####

**1. 定长顺序存储表示**

额外定义一个专门变量来存储串的长度（时间复杂度为O（1））.

	typedef struct
	{
		char str[maxSize+1];
		int length;
	}

**2. 变长分配存储表示**
*
变长分配存储表示（又叫动态分配存储表示）方法的特点是，在程序执行过程中根据需要动态分配。

	typedef struct
	{
		char *ch; //指向动态分配存储区首地址的字符指针
		int length; //串长度
	}

需要用malloc()来分配一个长度为length、类型为char型的连续存储空间，分配的空间可以用函数free()释放掉。用函数malloc()分配存储空间如果成功，则返回一个指向起始地址的指针，作为串的基地址，这个指针由ch指针来指向；如果分配失败，则返回NULL。

#### 4.1.3 串的基本操作 ####

**1. 赋值操作**

## 第5章 数组、矩阵与广义表

### 知识点讲解

### 5.1 数组

1. 两种数组的逻辑表示
   1. 一维数组
   2. 二维数组
2. 二维数组的行优先和列优先存储

### 5.2 矩阵的压缩存储

#### 5.2.1 矩阵

```
int A[m][n]
#define m 4
#define n 5
int A[m][n];
```

1. **矩阵的转置**

   ```
   void trsmat(int A[][maxSize], int B[][maxSize], int m, int n)
   {
   	for (int i=0; i<m; ++i)
   		for (int j=0; j<n; ++j)
   			B[j][i] = A[i][j];
   }
   ```

2. **矩阵相加**



3. **矩阵相乘**



#### 5.2.2 特殊矩阵和稀疏矩阵

相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为**特殊矩阵**，反之称为**稀疏矩阵**。

1. **特殊矩阵**
2. **稀疏矩阵**

### 5.3 广义表

表元素可以是原子或者广义表的一种线性表的扩展结构。



## 第6章 树与二叉树

### 大纲要求

* 树的基本概念
* 二叉树
* 树和森林
* 树与二叉树的应用

### 考点与要点分析

### 6.1 树的基本概念

#### 6.1.1 树的定义



#### 6.1.2 树的基本术语

* 结点
* 结点的度
* 树的度
* 叶子结点
* 非终端结点
* 孩子
* 双亲
* 兄弟
* 祖先
* 子孙
* 层次
* 树的高度（或者深度）

#### 6.1.3 树的存储结构

1. **顺序存储结构**

   树的顺序存储结构中最简单直观的是双亲存储结构。

2. **链式存储结构**

   1. 孩子存储结构
   2. 孩子兄弟存储结构

### 6.2 二叉树

#### 6.2.1 二叉树的定义



#### 6.2.2 二叉树的主要性质



#### 6.2.3 二叉树的存储结构

1. **顺序存储结构**

   顺序存储结构即用一个数组来存储一颗二叉树，**这种存储方式最适合完全二叉树，用于存储一般二叉树会浪费大量的存储空间**。将完全二叉树中的结点值按编号依次存入一个一维数组中，即完成了一颗二叉树的顺序存储。

2. **链式存储结构**

```
typedef struct TreeNode{
    ElemType data;
    TreeNode *left;
    TreeNode *right;
}TreeNode;
```

#### 6.2.4 二叉树的遍历算法

1. **先序遍历**

   1. 访问根节点
   2. 先序遍历左子树
   3. 先序遍历右子树

   ```
   void preOrder(BiTree T)
   {
       if (T != nullptr) {
           std::cout << T->data << std::endl;
           preOrder(T->left);
           preOrder(T->right);
       }
   }
   ```

2. **中序遍历**

   1. 中序遍历左子树
   2. 访问根节点
   3. 中序遍历右子树

   ```
   void inOrder(BiTree T)
   {
       if (T != nullptr) {
           inOrder(T->left);
           std::cout << T->data << std::endl;
           inOrder(T->right);
       }
   }
   ```

3. **后序遍历**

   1. 后序遍历左子树
   2. 后序遍历右子树
   3. 访问根节点

   ```
   void postOrder(BiTree T)
   {
       if (T != nullptr) {
           postOrder(T->left);
           postOrder(T->right);
           std::cout << T->data << std::endl;
       }
   }
   ```

4. 递归算法和非递归算法的转换
5. 层次遍历
6. 由遍历序列构造二叉树

## 第7章 图 ##

### 大纲要求 ###

### 考点与要求分析 ###

### 核心考点 ###

### 基础要点 ###

### 知识点讲解 ###

7.1 图的基本概念

1. 图：由结点的有穷集合V和边的集合E组成。
2. 有向图：每条边都有方向
3. 弧：在有向图中，通常边称为弧，含箭头的一端称为弧头，另一端称为弧尾，记作<vi,vj>
4. 度：在无向图中，边记为(V<sub>i</sub>,)
5. 有向完全图和无向完全图：若有向图中有n个顶点，最多有n(n-1)条边（图中任意两个顶点都有两条边相连），将具有n(n-1)条边的有向图称为有向完全图。若无向图中有n个顶点，则最多有n(n-1)/2条边(任意两个顶点之间都有一条边)，将具有n(n-1)/2条边的无向图称为无向完全图。
6. 路径和路径长度：在一个图中，路径为相邻顶点序偶所构成的序列。
7. 简单路径：序列中顶点不重复出现的路径称为简单路径。
8. 回路：若一条路径中第一个顶点和最后一个顶点相同，则这条路径是一条回路。
9. 连通、连通图和连通份量：如果图中任意两个顶点之间都连通，则称该图为连通图；否则，图中的极大连通子图称为连通分量。
10. 强连通图和强连通分量
11. 权和网

### 7.2 图的存储结构 ###

#### 7.2.1 邻接矩阵 ####

邻接矩阵是表示顶点之间相邻关系的矩阵。设G=(V, E)是具有n个顶点的图，顶点序号依次为0，1，...，n-1，则G的邻接矩阵是具有如下定义的n阶方阵A：

	A[i][j] = 1表示顶点i与顶点j邻接，即i与j之间存在边或者弧。
	A[i][j] = 0表示顶点i与顶点j不邻接（0<=i, j<=n-1）

邻接矩阵是图的**顺序存储结构**。

邻接矩阵定义：

	typedef struct
	{
		int no;	//顶点编号
		char info;	//顶点其他信息
	}VertexType;	//顶点类型
	
	typedef struct
	{
		int edges[maxSize][maxSize];	//邻接矩阵定义，如果有权图，则在此句中将int改为float
		int n, e;	// 存放结点信息
		VertexType vex[maxSize];  // 存放结点信息
	}MGraph	// 图的邻接矩阵类型

#### 7.2.2 邻接表 ####

邻接表是图的一种**链式存储结构**。所谓邻接表就是对图中的每个顶点i建立一个单链表，每个单链表的第一个结点存放有关顶点的信息，把这一结点看作链表的表头，其余结点存放有关边的信息。

	typedef struct ArcNode
	{
		int adjvex;
		strcut ArcNode *nextarc;
		int info;
	} ArcNode;
	typedef struct
	{
		char data;
		ArcNode *firstarc;
	} VNode;
	typedef struct
	{
		VNode adjlist[MAXSIZE];
		int n, e; 
	} AGraph;
#### 7.2.3 邻接多重表 ####

邻接多重表和十字链表类似，也是由顶点表和边表组成的，每一条边用一个结点表示，其顶点表结点结构和边表结点结构。

### 7.3 图的遍历算法操作 ###

#### 7.3.1 深度优先搜索算法 ####

图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。它的基本思想是：首先访问出发点v，并将其标记为已访问过；然后选取与v邻接的未被访问的任意一个顶点w，并访问它；再选取与w邻接的未被访问的任一顶点并访问，以此重复进行。当一个顶点所有的邻接顶点都被访问过时，则以此退回到最近被访问过的顶点，若该顶点还有其他邻接顶点未被访问，则从这些未被访问的顶点中取一个并重复上述访问过程，直至图中所有顶点都被访问过为止。

一条路走到黑



#### 7.3.2 广度优先搜索遍历

### 7.6 拓扑排序

#### 7.6.1 AOV网

AOV网是一种以顶点表示活动、以边表示活动的先后次序且没有回路的有向图即可。因为AOV网有实际意义，所以出现回路就代表一项以自己为前提。

#### 7.6.2 拓扑排序核心算法

对一个有向无环图G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v

#### 7.6.3 例题选讲

### 7.7 关键路径

#### 7.7.1 AOE网

AOE和AOV网的相同点：

1. 都是有向无环图

不同点：

1. AOE网的边表示活动，边有权值，边代表活动持续时间；顶点表示事件，事件是图中新活动开始或者旧活动结束的标志。
2. AOV网的顶点表示活动，边无权值，边代表活动之间的先后关系。
3. 对于一个表示工程的AOE网，只存在一个入度为0的顶点，称为源点，表示整个工程的开始；也只存在一个出度为0的顶点，称为汇点，表示整个工程的结束。

#### 7.7.2 关键路径核心算法





## 第8章 排序







