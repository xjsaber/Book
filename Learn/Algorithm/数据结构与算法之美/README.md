# 数据结构与算法之美 #

## 《数据结构与算法之美》学习指导手册 ##

### 1. 复杂度分析 ###

简单代码能很快分析出时间、空间复杂度；对于复杂点的代码，比如递归代码，你也要掌握专栏中讲到的两种分析方法：递推公式和递归树。

* 是否重点：10分
* 掌握程度：能自行分析专栏中大部分数据结构和算法的时间、空间复杂度

### 2. 数组、栈、队列 ###

* 是否重点：8 分
* 掌握程度：能自己实现动态数组、栈、队列

### 3. 链表 ###

* 是否重点：9 分
* 掌握程度：能轻松写出经典链表题目代码

### 4. 链表 ###

* 是否重点：10 分
* 掌握程度：轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码

### 5. 排序、二分查找 ###

* 是否重点：7 分
* 掌握程度：能自己把各种排序算法、二分查找及其变体代码写一遍就可以了

### 6. 跳表 ###

* 是否重点：6 分
* 掌握程度：初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现7. 散列表

### 7. 散列表 ###

* 是否重点：8 分
* 掌握程度：对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可

### 8. 哈希算法 ###

* 是否重点：3 分
* 掌握程度：可以暂时不看

### 9. 二叉树 ###

* 是否重点：9 分
* 掌握程度：能代码实现二叉树的三种遍历算法、按层遍历、求高度等经典二叉树题目

### 10.红黑树 ###

* 是否重点：3 分
* 掌握程度：初学者不用把时间浪费在上面

### 11.B+ 树 ###

* 是否重点：5 分
* 掌握程度：可看可不看

### 12. 堆与堆排序 ###

* 是否重点：8 分
* 掌握程度：能代码实现堆、堆排序，并且掌握堆的三种应用（优先级队列、Top k、中位数）

## 开篇词 | 从今天起，跨过“数据结构与算法”这道坎 ##

## 01 | 为什么要学习数据结构和算法？ ##

## 02 | 如何抓住重点，系统高效地学习数据结构与算法？ ##

数据结构为算法服务的，算法要作用在特定的数据结构之上。

### 学习这个专栏需要什么基础？ ###

### 学习的重点在什么地方？ ###

1. 掌握一个数据结构与算法中最重要的概念——复杂度分析。
2. 20 个最常用的、最基础数据结构与算法
	* 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
	* 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

1. 边学边练，适度刷题
	* 可以“适度”刷题
2. 多问，多思考、多互动
3. 打怪升级学习法
	* 学习的过程中，我们碰到最大的问题就是，坚持不下来
	* 在枯燥的学习过程中，也可以给自己设立一个切实可行的目标
4. 知识需要沉淀，不要试图一下子掌握所有
	* 学习知识的过程是反复迭代、不断沉淀的过程。

### 内容小结 ###

* 数据结构和算法分析
* 复杂度分析
* 10个数据结构和10个算法

### 课后思考 ###

## 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？ ##

复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

### 为什么需要复杂度分析？ ###

事后统计法：

1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大


### 大 O 复杂度表示法 ###

所有代码的执行时间T(n)与每行代码的执行次数成正比。所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。
T(n) = O(f(n))，表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

### 时间复杂度分析 ###

#### 1. 只关注循环执行次数最多的一段代码 ####

分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码。

#### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度 ####

总的时间复杂度就等于量级最大的那段代码的时间复杂度

#### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 ####

把乘法法则看成是嵌套循环

### 几种常见时间复杂度实例分析 ###

* 多项式量级
	* 常量阶：O(1)
	* 对数阶：O(logn)
	* 线性阶：O(n)
	* 线性对数阶：O(logn)
	* 平方阶：O(n^2)、立方阶：O(n^3)...k次方阶O(n^k)
* 非多项式量级
	* 指数阶O(2^n)
	* 阶乘阶O(n!)  

时间复杂度为非多项式量级的算法问题叫做NP（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。

#### 多项式时间复杂度 ####

**1. O(1)**

O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。只要代码的执行时间不随n的增长而增长，复杂度记作O(1)。

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

**2. O(logn)、O(nlogn)**

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。

	i=1;
	while(i <= n) {
		i = i * 2;
	}
第三行代码是循环执行次数最多的，只能计算出这行代码被执行了多少次，就知道整段代码的时间复杂度。

如果一段代码的时间复杂度是O(logn)，循环执行n遍，时间复杂度就是O(nlogn)了。O(nlogn) 也是一种非常常见的算法时间复杂度。归并排序、快速排序的时间复杂度都是 O(nlogn)。

**3. O(m+n)、O(m*n)**

代码复杂度由*两个数据的规模*来决定的。

#### 空间复杂度分析 ####

* 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与时间规模之间的增长关系。
* 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

### 内容小结 ###

复杂度叫做渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。

从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)

### 课后思考 ###

Q:
有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？

A：

## 04 | 复杂度分析（下）：复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度 ##

O(1)、O(logn)、O(n)、O(nlogn)

最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）

### 最好、最坏情况时间复杂度 ###

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

### 平均情况时间复杂度 ###

加权平均值，期望值。平均复杂度的全称叫做加权平均时间复杂度或者期望时间复杂度。

### 均摊时间复杂度 ###


	 // array表示一个长度为n的数组
	 // 代码中的array.length就等于n
	 int[] array = new int[n];
	 int count = 0;
	 
	 void insert(int val) {
	    if (count == array.length) {
	       int sum = 0;
	       for (int i = 0; i < array.length; ++i) {
	          sum = sum + array[i];
	       }
	       array[0] = sum;
	       count = 1;
	    }
	
	    array[count] = val;
	    ++count;
	 }

最理想的情况下，数组中有空闲空间，需要将数据插入到数组下标为count的位置就可以了，最好情况时间复杂度为O(1)。最坏的情况下，数组中没有空闲空间了，需要先做一次数组的遍历求和，然后再将数据插入，最坏情况时间复杂度为O(n)。

均摊时间复杂度就是一种特殊的平均时间复杂度。

### 内容小结 ###

最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。——同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。

### 课后思考 ###

## 05 | 数组：为什么很多编程语言中数组都从0开始编号？ ##

### 如何实现随机访问？ ###

数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

1. 线性表（Linear List）。
	* 线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。
	* 非线性表，比如二叉树、堆、图等。是因为，在非线性表中，数据之间并不是简单的前后关系。
2. 连续的内存空间和相同类型的数据。

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，会首先通过下面的寻址公式，计算出该元素的内存地址：

	a[i]_address = base_address + i * data_type_size

其中data_type_size表示数组中每个元素的大小。

数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

### 低效的“插入”和“删除” ###

#### 插入操作 ####

#### 删除操作 ####

数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。依次删除a,b,c三个元素。为了避免 d，e，f，g，h 这几个数据会被搬移三次，先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。

### 警惕数组的访问越界问题 ###

### 容器能否完全替代数组？ ###

ArrayList 最大的优势就是*可以将很多数组操作的细节封装起来*。支持动态扩容。

数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。

在创建 ArrayList 的时候事先指定数据大小。

#### 数组的优点 ####

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
3. 当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList<ArrayList<object> > array。

---
 
* 业务开发，直接使用容器就足够了
* 底层开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

### 内容小结 ###

数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。

### 课后思考 ###

## 06 | 链表（上）：如何实现LRU缓存淘汰算法？ ##

缓存市一种提高数据读取性能的技术，在硬件设计、软件开发中都有非常广泛的应用。比如常见的CPU缓存、数据库缓存、浏览器缓存等等。

### 五花八门的链表结构 ###

相比数组，链表市一种稍微复杂一点的数据结构。而链表恰恰相反，不需要一块连续的内存空间，通过“指针”将一组*零散的内存块*串联起来使用。

* 单链表
* 双向链表
* 循环链表

链表通过指针将一组零散的内存块串联在一起。其中，把内存块称为链表的“结点”。为了将所有的节点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。记录下个结点地址的指针叫作后继指针next。

## 链表VS数组性能大比拼 ##



## 内容小结 ##