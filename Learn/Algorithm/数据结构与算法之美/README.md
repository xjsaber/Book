# 数据结构与算法之美 #

## 《数据结构与算法之美》学习指导手册 ##

### 1. 复杂度分析 ###

简单代码能很快分析出时间、空间复杂度；对于复杂点的代码，比如递归代码，你也要掌握专栏中讲到的两种分析方法：递推公式和递归树。

* 是否重点：10分
* 掌握程度：能自行分析专栏中大部分数据结构和算法的时间、空间复杂度

### 2. 数组、栈、队列 ###

* 是否重点：8 分
* 掌握程度：能自己实现动态数组、栈、队列

### 3. 链表 ###

* 是否重点：9 分
* 掌握程度：能轻松写出经典链表题目代码

### 4. 链表 ###

* 是否重点：10 分
* 掌握程度：轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码

### 5. 排序、二分查找 ###

* 是否重点：7 分
* 掌握程度：能自己把各种排序算法、二分查找及其变体代码写一遍就可以了

### 6. 跳表 ###

* 是否重点：6 分
* 掌握程度：初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现7. 散列表

### 7. 散列表 ###

* 是否重点：8 分
* 掌握程度：对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可

### 8. 哈希算法 ###

* 是否重点：3 分
* 掌握程度：可以暂时不看

### 9. 二叉树 ###

* 是否重点：9 分
* 掌握程度：能代码实现二叉树的三种遍历算法、按层遍历、求高度等经典二叉树题目

### 10.红黑树 ###

* 是否重点：3 分
* 掌握程度：初学者不用把时间浪费在上面

### 11.B+ 树 ###

* 是否重点：5 分
* 掌握程度：可看可不看

### 12. 堆与堆排序 ###

* 是否重点：8 分
* 掌握程度：能代码实现堆、堆排序，并且掌握堆的三种应用（优先级队列、Top k、中位数）

## 开篇词 | 从今天起，跨过“数据结构与算法”这道坎 ##

## 01 | 为什么要学习数据结构和算法？ ##

## 02 | 如何抓住重点，系统高效地学习数据结构与算法？ ##

数据结构为算法服务的，算法要作用在特定的数据结构之上。

### 学习这个专栏需要什么基础？ ###

### 学习的重点在什么地方？ ###

1. 掌握一个数据结构与算法中最重要的概念——复杂度分析。
2. 20 个最常用的、最基础数据结构与算法
	* 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
	* 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

1. 边学边练，适度刷题
	* 可以“适度”刷题
2. 多问，多思考、多互动
3. 打怪升级学习法
	* 学习的过程中，我们碰到最大的问题就是，坚持不下来
	* 在枯燥的学习过程中，也可以给自己设立一个切实可行的目标
4. 知识需要沉淀，不要试图一下子掌握所有
	* 学习知识的过程是反复迭代、不断沉淀的过程。

### 内容小结 ###

* 数据结构和算法分析
* 复杂度分析
* 10个数据结构和10个算法

### 课后思考 ###

## 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？ ##

复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

### 为什么需要复杂度分析？ ###

事后统计法：

1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大


### 大 O 复杂度表示法 ###

所有代码的执行时间T(n)与每行代码的执行次数成正比。所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。
T(n) = O(f(n))，表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

### 时间复杂度分析 ###

#### 1. 只关注循环执行次数最多的一段代码 ####

分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码。

#### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度 ####

总的时间复杂度就等于量级最大的那段代码的时间复杂度

#### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 ####

把乘法法则看成是嵌套循环

### 几种常见时间复杂度实例分析 ###

* 多项式量级
	* 常量阶：O(1)
	* 对数阶：O(logn)
	* 线性阶：O(n)
	* 线性对数阶：O(logn)
	* 平方阶：O(n^2)、立方阶：O(n^3)...k次方阶O(n^k)
* 非多项式量级
	* 指数阶O(2^n)
	* 阶乘阶O(n!)  

时间复杂度为非多项式量级的算法问题叫做NP（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。

#### 多项式时间复杂度 ####

**1. O(1)**

O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。只要代码的执行时间不随n的增长而增长，复杂度记作O(1)。

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

**2. O(logn)、O(nlogn)**

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。

	i=1;
	while(i <= n) {
		i = i * 2;
	}
第三行代码是循环执行次数最多的，只能计算出这行代码被执行了多少次，就知道整段代码的时间复杂度。

如果一段代码的时间复杂度是O(logn)，循环执行n遍，时间复杂度就是O(nlogn)了。O(nlogn) 也是一种非常常见的算法时间复杂度。归并排序、快速排序的时间复杂度都是 O(nlogn)。

**3. O(m+n)、O(m*n)**

代码复杂度由*两个数据的规模*来决定的。

#### 空间复杂度分析 ####

* 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与时间规模之间的增长关系。
* 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

### 内容小结 ###

复杂度叫做渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。

从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)

### 课后思考 ###

Q:
有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？

A：

## 04 | 复杂度分析（下）：复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度 ##

O(1)、O(logn)、O(n)、O(nlogn)

最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）

### 最好、最坏情况时间复杂度 ###


