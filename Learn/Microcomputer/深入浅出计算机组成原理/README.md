# 深入浅出计算机组成原理 #

入门篇

## 开篇词 | 为什么你需要学习计算机组成原理 ##

如果越早去弄清楚计算机的底层原理，在你的知识体系中“储蓄”起这些知识，也就意味着你有越长的时间来收获学习知识的“利息”。虽然一开始可能不起眼，但是随着时间带来的复利效应，你的长线投资项目，就能让你在成长的过程中越走越快。

### 计算机底层知识的“第一课” ###

学习这门“第一课”的过程，会为你在整个软件开发领域中打开一扇扇窗和门，让你看到更加广阔的天地。比如说，明白了高级语言是如何对应着 CPU 能够处理的一条条指令，能为你打开编译原理这扇门；搞清楚程序是如何加载运行的，能够让你对操作系统有更深入的理解。

### 理论和实践相结合 ###

我要把这些知识点和日常工作、生活以及整个计算机行业的发展史联系起来，教你真正看懂、学会、记住组成原理的核心内容，教你更多地从“为什么”这个角度，去理解这些知识点，而不是只是去记忆“是什么”。

## 01 | 冯·诺依曼体系结构：计算机组成的金字塔 ##

### 计算机的基本硬件组成 ###

1. CPU，叫中央处理器（Central Processing Unit）
2. 内存（Memory）
3. 主板（Motherboard）。主板的芯片组（Chipset）和总线（Bus）解决了 CPU 和内存之间如何通信的问题。芯片组控制了数据传输的流转，也就是数据从哪里到哪里的问题。总线则是实际数据传输的高速公路。因此，总线速度（Bus Speed）决定了数据能传输得多快。

鼠标、键盘以及硬盘，这些都是插在主板上的。作为外部 I/O 设备，它们是通过主板上的南桥（SouthBridge）芯片组，来控制和 CPU 之间的通信的。“南桥”芯片的名字很直观，一方面，它在主板上的位置，通常在主板的“南面”。另一方面，它的作用就是作为“桥”，来连接鼠标、键盘以及硬盘这些外部设备和 CPU 之间的通信。

### 冯·诺依曼体系结构 ###

SoC，System on a Chip（系统芯片）

### 总结延伸 ###

学习组成原理，其实就是学习控制器、运算器的工作原理，也就是 CPU 是怎么工作的，以及为何这样设计；学习内存的工作原理，从最基本的电路，到上层抽象给到 CPU 乃至应用程序的接口是怎样的；学习 CPU 是怎么和输入设备、输出设备打交道的。

学习组成原理，就是在理解从控制器、运算器、存储器、输入设备以及输出设备，从电路这样的硬件，到最终开放给软件的接口，是怎么运作的，为什么要设计成这样，以及在软件开发层面怎么尽可能用好它。

### 推荐阅读 ###

[First Draft of a Report on the EDVAC](https://en.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC)

### 课后思考 ###

## 02 | 给你一张知识地图，计算机组成原理应该怎么学 ##

*整个计算机组成原理，就是围绕着计算机是如何组织运作展开的*

### 计算机组成原理知识地图 ###

![12bc980053ea355a201e2b529048e2ff.jpg](img/12bc980053ea355a201e2b529048e2ff.jpg)

计算机的基本组成、计算机的指令和计算、处理器设计、以及存储器和I/O设备

1. 计算机的基本组成
	* 运算器、控制器、存储器、输入设备和输出设备这五大基本组件
	* 计算机的两个核心指标，性能和功耗
2. 计算机的指令和计算
	* 一条条指令执行的控制过程，就是由计算机五大组件之一的控制器来控制的
	* 

## 03 | 通过你的CPU主频，我们来谈谈“性能”究竟是什么？ ##



## 04 | 穿越功耗墙，我们该从哪些方面提升“性能”？ ##

# 原理篇：指令和运算 #

## 05 | 计算机指令：让我们试试用纸带编程 ##

### 在软硬件接口中，CPU 帮我们做了什么事？ ###

### 从编译到汇编，代码怎么变成机器码？ ###

	// test.c
	int main()
	{
	  int a = 1; 
	  int b = 2;
	  a = a + b;
	}

C语言 => （Compile）汇编语言 => 汇编器（Assembler）机器码

	$ gcc -g -c test.c
	$ objdump -d -M intel -S test.o

汇编代码是“给程序员看的机器码”。机器码和汇编代码是一一对应的。

### 解析指令和机器码 ###

常见的指令可以分成五大类：

1. 算术类指令：加减乘除，变成一条条算术类指令。
2. 数据传输类指令：变量赋值、在内存里读写数据，用的都是数据传输类指令。
3. 逻辑类指令：逻辑上的与或非。
4. 条件分支类指令：if/else，其实都是条件分支类指令。
5. 无条件跳转指令：函数或者方法，在调用函数的时候，其实就是发起了一个无条件跳转指令。

![ebfd3bfe5dba764cdcf871e23b29f197.jpeg](img/ebfd3bfe5dba764cdcf871e23b29f197.jpeg)

MIPS 的指令是一个 32 位的整数，高 6 位叫操作码（Opcode），剩下的 26 位有三种格式，分别是 R、I 和 J。

* *R指令*是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。
* *I指令*通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。
* *J指令*一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。

### 总结延伸 ###

### 推荐阅读 ###

《计算机组成与设计：软 / 硬件接口》第 5 版的 2.17 小节

### 课后思考 ###

## 06 | 指令跳转：原来if...else就是goto ##

### CPU 是如何执行指令的？ ###

写好的代码变成了指令之后，是一条一条*顺序*执行的就可以了。

CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。

一个CPU里面会有很多种不同功能的寄存器：

1. PC寄存器（Program Counter Register），指令地址寄存器（Instruction Address Register）。用来存放下一条需要执行的计算机指令的内存地址。
2. 指令寄存器（Instruction Register），用来存放当前正在执行的指令。
3. 条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。

通常根据存放的数据内容来给它们取名字，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。

![ad91b005e97959d571bbd2a0fa30b48a.jpeg](img/ad91b005e97959d571bbd2a0fa30b48a.jpeg)

特殊指令：

* 跳转指令

### 从 if…else 来看程序的执行和跳转 ###


	// test.c
	#include <time.h>
	#include <stdlib.h>
	
	int main()
	{
	  srand(time(NULL));
	  int r = rand() % 2;
	  int a = 10;
	  if (r == 0)
	  {
	    a = 1;
	  } else {
	    a = 2;
	  } 
	}

	$ gcc -g -c test.c
	$ objdump -d -M intel -S test.o 


	    if (r == 0)
	  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0
	  3f:   75 09                   jne    4a <main+0x4a>
	    {
	        a = 1;
	  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
	  48:   eb 07                   jmp    51 <main+0x51>
	    }
	    else
	    {
	        a = 2;
	  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
	  51:   b8 00 00 00 00          mov    eax,0x0
	    } 

对于 `r ==  0` 的条件判断，被编译成了 cmp 和 jne 这两条指令。cmp 指令比较了前后两个操作数的值，这里的 DWORD PTR 代表操作的数据类型是 32 位的整数，而[rbp-0x4]则是一个寄存器的地址。

1. 第一个操作数就是从寄存器里拿到的变量 r 的值。
2. 第二个操作数 0x0 就是我们设定的常量 0 的 16 进制表示。
3. cmp 指令的比较结果，会存入到*条件码寄存器*当中去。

跟着的 jne 指令，是 jump if not equal 的意思，它会查看对应的零标志位。

1. 如果为 0，会跳转到后面跟着的操作数 4a 的位置。这个 4a，对应这里汇编代码的行号，也就是上面设置的 else 条件里的第一条指令。
2. 当跳转发生的时候，PC 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 4a 这个地址。
3. 这个时候，CPU 再把 4a 地址里的指令加载到指令寄存器中来执行。
4. 跳转到执行地址为 4a 的指令，实际是一条 mov 指令，第一个操作数和前面的 cmp 指令一样，是另一个 32 位整型的寄存器地址，以及对应的 2 的 16 进制值 0x2。mov 指令把 2 设置到对应的寄存器里去，相当于一个赋值操作。然后，PC 寄存器里的值继续自增，执行下一条 mov 指令。
5. 这条 mov 指令的第一个操作数 eax，代表累加寄存器，第二个操作数 0x0 则是 16 进制的 0 的表示。这条指令其实没有实际的作用，它的作用是一个占位符。
6. 我们回过头去看前面的 if 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp 的无条件跳转指令。跳转的地址就是这一行的地址 51。我们的 main 函数没有设定返回值，而 mov eax, 0x0 其实就是给 main 函数生成了一个默认的为 0 的返回值到累加器里面。if 条件里面的内容执行完成之后也会跳转到这里，和 else 里的内容结束之后的位置是一样的。

### 如何通过 if…else 和 goto 来实现循环？ ###

	int a = 0;
    for (int i = 0; i < 3; i++){
        a += i;
    }


	int a = 0;
	   4:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
	    for (int i = 0; i < 3; i++){
	   b:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [rbp-0x8],0x0
	  12:	eb 0a                	jmp    1e <main+0x1e>
	        a += i;
	  14:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
	  17:	01 45 fc             	add    DWORD PTR [rbp-0x4],eax
	    for (int i = 0; i < 3; i++){
	  1a:	83 45 f8 01          	add    DWORD PTR [rbp-0x8],0x1
	  1e:	83 7d f8 02          	cmp    DWORD PTR [rbp-0x8],0x2
	  22:	7e f0                	jle    14 <main+0x14>
	  24:	b8 00 00 00 00       	mov    eax,0x0
	    }

1. 对应的循环也是用 1e 这个地址上的 cmp 比较指令，和紧接着的 jle 条件跳转指令来实现的。
2. 主要的差别在于，这里的 jle 跳转的地址，在这条指令之前的地址 14，而非 if…else 编译出来的跳转指令之后。
3. 往前跳转使得条件满足的时候，PC 寄存器会把指令地址设置到之前执行过的指令位置，重新执行之前执行过的指令，直到条件不满足，顺序往下执行 jle 之后的指令，整个循环才结束。

### 总结延伸 ###

单条指令的基础上，学习了程序里的多条指令，除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。

回归到计算机可以识别的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于 goto 的语句。

要在硬件层面实现这个 goto 语句，除了本身需要用来保存下一条指令地址，以及当前正要执行指令的 PC 寄存器、指令寄存器外，我们只需要再增加一个条件码寄存器，来保留条件判断的状态。这样简简单单的三个寄存器，就可以实现条件判断和循环重复执行代码的功能。

### 推荐阅读 ###

《深入理解计算机系统》的第 3 章，详细讲解了 C 语言和 Intel CPU 的汇编语言以及指令的对应关系，以及 Intel CPU 的各种寄存器和指令集。

Intel 指令集相对于之前的 MIPS 指令集要复杂一些：

1. 所有的指令是变长的，从 1 个字节到 15 个字节不等
2. 针对操作数据的长度不同有不同的后缀

### 课后思考 ###

除了 if…else 的条件语句和 for/while 的循环之外，大部分编程语言还有 switch…case 这样的条件跳转语句。switch…case 编译出来的汇编代码也是这样使用 jne 指令进行跳转吗？对应的汇编代码的性能和写很多 if…else 有什么区别呢？你可以试着写一个简单的 C 语言程序，编译成汇编代码看一看。

## 07 | 函数调用：为什么会发生stack overflow？ ##

栈溢出（stack overflow）

### 为什么我们需要程序栈？ ###

### 如何构造一个 stack  overflow？ ###



### 如何利用函数内联进行性能优化？ ###

### 总结延伸 ###

一个程序的函数间调用，在 CPU 指令层面是怎么执行的。程序栈的概念。通过压栈和出栈操作，使得程序在不同的函数调用过程中进行转移。而函数内联和栈溢出，一个是我们常常可以选择的优化方案，另一个则是我们会常遇到的程序 Bug。

通过加入了程序栈，在指令跳转中加入了记忆的功能（跳转去新的指令之后，再回到跳出去的位置）。为我们在程序开发的过程中，提供了“函数”这样一个抽象。

### 推荐阅读 ###

《深入理解计算机系统（第三版）》的 3.7 小节《过程》

通过搜索引擎搞清楚 function_example.c 每一行汇编代码的含义，这个能够帮你进一步深入了解程序栈、栈帧、寄存器以及 Intel CPU 的指令集。

### 课后思考 ###

## 08 | ELF和静态链接：为什么程序无法同时在Linux和Windows下运行？ ##

### 编译、链接和装载：拆解程序执行 ###

写好的 C 语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成 CPU 可以理解的机器码，于是 CPU 就可以执行这些机器码了

“C 语言代码 - 汇编代码 - 机器码"

第一部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，生成了一个可执行文件。
第二部分，通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU从内存中读取指令和数据，来开始真正执行程序。

![997341ed0fa9018561c7120c19cfa2a7.jpg](img/997341ed0fa9018561c7120c19cfa2a7.jpg)

### ELF 格式和链接：理解链接过程 ###

1. 首先是.text Section，也叫作代码段或者指令段（Code Section），用来保存程序的代码和指令；
2. 接着是.data Section，也叫作数据段（Data Section），用来保存程序里面设置好的初始化数据信息；
3. 然后就是.rel.text Secion，叫作重定位表（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；
4. 最后是.symtab Section，叫作符号表（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。

### 总结延伸 ###

Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作 PE（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。

### 推荐阅读 ###

程序员的自我修养——链接、装载和库，ch1-ch4

### 课后思考 ###

可以通过 readelf 读取出今天演示程序的符号表，看看符号表里都有哪些信息；然后通过 objdump 读取出今天演示程序的重定位表，看看里面又有哪些信息。

## 09 | 程序装载：“640K内存”真的不够用么？ ##

### 程序装载面临的挑战 ###

如何通过链接器，把多个文件合并成一个最终可执行文件。在运行这些可执行文件的时候，我们其实是通过一个装载器，解析ELF或者PE格式的可执行文件。装载器会把对应的指令和数据加载到内存里面来，让CPU置执行。

1. **可执行程序加载后占用的内存空间应该是连续的**。
2. **我们需要同时加载很多哥程序，并且不能让程序自己规定在内存中加载的位置**。

要满足两个基本的要求，可以在内存里面，找到一段连续的内存空间，然后分配给装载的程序，然后把这段连续的内存空间地址，和整个程序指令里规定的内存地址做一个映射。

指令里用到的内存地址叫做虚拟内存地址（Virtual Memory Address），实际内存硬件里面的空间地址，叫物理内存地址（Physical Memory Address）

### 内存分段 ###

找出一段连续的物理内存和虚拟内存地址进行映射的方法，**分段**（Segmentation）。这里的段，就是指系统分配出来的那个连续的内存空间。

分段办法的不足：

1. 内存碎片


### 内存分页 ###

内存碎片

### 总结延伸 ###

程序员的自我修养——链接、装载和库，ch1和ch6 代码装载


## 10 | 动态链接：程序内部的“共享单车” ##

## 13 | 加法器：如何像搭乐高一样搭电路（上） ##

在计算机硬件层面设计最基本的单元，门电路。门电路非常简单，只能做简单的 “与（AND）”“或（OR）”“NOT（非）”和“异或（XOR）”，这样最基本的单比特逻辑运算。

### 异或门和半加器 ###

基础门电路，输入都是两个单独的 bit，输出是一个单独的 bit。

### 全加器 ###

半加器（Half Adder），全加器（Full Adder）

*我们用两个半加器和一个或门，就能组合成一个全加器。*

### 总结延伸 ###

## 15 | 浮点数和定点数（上）：怎么用有限的Bit表示尽可能多的信息？ ##

### 浮点数的不确定性 ###

用二进制来表示十进制的编码方式，叫作**BCD 编码（Binary-Coded Decimal）**。

1. 这样的表示方式有点“浪费”
2. 这样的表示方式没办法同时表示很大的数字和很小的数字

### 浮点数的表示 ###

浮点数（Floating Point），也就是float类型。

### 定点数的表示 ###

### 总结延伸 ###



### 推荐阅读 ###

计算机组成与设计：硬件 / 软件接口的 3.5.1 节，了解浮点数

### 课后思考 ###

对于 BCD 编码的定点数，如果我们用 7 个比特来表示连续两位十进制数，也就是 00～99，是不是可以让 32 比特表示更大一点的数据范围？如果我们还需要表示负数，那么一个 32 比特的 BCD 编码，可以表示的数据范围是多大？

原理篇：处理器

## 17 | 建立数据通路（上）：指令+运算=CPU ##



## 18 | 建立数据通路（中）：指令+运算=CPU ##

## 19 | 建立数据通路（下）：指令+运算=CPU ##

通过一个时钟信号，我们可以实现计数器，这个会成为我们的 PC 寄存器。然后，我们还需要一个能够帮我们在内存里面寻找指定数据地址的译码器，以及解析读取到的机器指令的译码器。这样，我们就能把所有学习到的硬件组件串联起来，变成一个 CPU，实现我们在计算机指令的执行部分的运行步骤。

### PC寄存器所需要的计数 ###

PC寄存器（程序计数器），有了时钟信号，我们可以提供定时的输入；有了 D 型触发器，我们可以在时钟信号控制的时间点写入数据。我们把这两个功能组合起来，就可以实现一个自动的计数器了。

# 答疑与加餐 #

特别加餐 | 

## FAQ第一期 | 学与不学，知识就在那里，不如就先学好了 ##

## 特别加餐 | 我的一天怎么过？ ##

### 精选留言 ###

**Q**

👍 真实&典型的一天
有人的时间安排是以自我为中心，比较严格地去控制每件事占用的时间。老师的时间安排也是这样的吗？您怎么看这种做法？

**A**

工作中的事情，我大致会分成三类：

1. 一类是重要的需要大块时间的事情，比如产品的RoadMap，大的系统设计。
2. 一类是即时响应性的工作。比如来自各种内外部的邮件，或者随时有同事来问或者讨论的各类问题。
3. 一类是长期必须完成的工作，包括和同事1对1沟通，日常的周会，招聘。

工作安排时间希望尽量通过做第3点来减少第2点的时间。并且尽量能多花时间在1上。

每天都会列一些To-Do，然后尽量保障能够清掉2-3个。如果连续一段时间觉得自己在1上花得少，就需要反思手上有哪些工作是可以交给其他同事得。以及是否有些事情从整个公司团队层面就不该做。

**Q**

老师，几本操作系统推荐书

**A**

操作系统的推荐可以去看看刘超老师的Linux操作系统课。

当然，最经典的教材也还是《现代操作系统》

**Q**

不太理解 访存 为什么在 执行 后面

**A**

你好，这个5阶段通常是指MIPS这样的RISC的一个简化的模型。开始执行指令之后，才会知道要从内存的什么地址读取数据，这个时候才会进入访存阶段。其实访问读取完成之后会继续进行执行过程。

而很多EX计算的指令都直接从寄存器读取数据，所以不需要访存。






