# 第四章 存储器管理 #
## 4.1 存储器的层次结构 ##

### 4.1.1 多级存储器结构 ###

## 4.1.2 主存储器与寄存器 ##

1.主存储器

2.寄存器

### 4.1.3 告诉缓存和磁盘缓存 ###
1.高速缓存

2.磁盘缓存

## 4.2 程序的装入和链接 ##
编译，由编译程序（Compiler）将用户源代码编译成若干个目标模块（Object Module)；其次是链接，由链接程序（Linker）将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块（Locad Module），最后是装入，由装入程序（Loader）将装入模块装入内存。

### 4.2.1 程序的装入 ###
在将一个装入模块装入内存时，可以有绝对装入方式、可重定位装入方式和动态运行时装入方式。
1.绝对装入方式（Absolute Loading Mode）

2.可重定位装入方式（Relocation Loading Mode）

3.动态运行时装入方式（Dynamic Run-time Loading）

### 4.2.2 程序的链接 ###
源程序经过编译后，可得到一组目标模块，再利用链接程序将这组目标模块链接，形成装入模块。根据链接时间的不同，可把链接分成如下三种：

(1) 静态链接。

(2) 装入时动态链接。

(3) 运行时动态链接。

#### 1.静态链接方式（Static Linking） ####

#### 2．装入时动态链接(Load-time Dynamic Linking) ####


## 4.3 连续分配方式 ##

### 4.3.1 单一连续分配 ###
这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给 OS 使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间，提供给用户使用。

### 4.3.2 固定分区分配 ###
固定分区式分配式最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行。当有一空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。
#### 1.划分分区的方法 ####
（1）分区大小相等，即使所有的内存分区大小相等。

（2）分区大小不等。

#### 2.内存分配 ####
为了便于内存分配，通常将分区按大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配）。

### 4.3.3 动态分区分配 ###

#### 1.分区分配中的数据结构 ####

（1）空闲分区表

（2）空闲分区链

#### 2.分区分配算法 ####
1）首次适应算法（first fit）

2）循环首次适应算法(next fit)

3) 最佳适应算法(best fit)

4) 最坏适应算法(worst fit)
最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用，其优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业有利，同时最坏适应分配算法查找效率很高。