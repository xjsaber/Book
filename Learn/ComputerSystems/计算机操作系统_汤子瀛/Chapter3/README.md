# 第三章 处理机调度与死锁 #

## 3.1 处理机调度的层次 ##

### 3.1.1 高级调度 ###

1.作业和作业步
（1）作业（Job）。
（2）作业步（Job Step）。编译，连结装配，运行
（3）作业流
2.作业控制块JCB（Job Control Block）
3.作业调度
1）决定接纳多少个作业

2）决定接纳哪些作业

### 3.1.2 低级调度 ###
低级调度（Low Level Scheduling）称为进程调度或短程调度（ShortTerm Scheduling），它所调度的对象是进程（或内核级线程）。
#### 1.低级调度的功能 ####

#### 2.进程调度中的三个基本机制 ####


#### 3.进程调度方式 ####

1）非抢占方式（Nonpreemptive Mode）
(1) 正在执行的进程执行完毕，或因发生某事件而不能再继续执行；
(2) 执行中的进程因提出 I/O 请求而暂停执行；
(3) 在进程通信或同步过程中执行了某种原语操作，如 P 操作(wait 操作)、Block 原语、Wakeup 原语等。
2）抢占方式（Preemptive Mode）
（1）优先权原则。
（2）短作业（进程）优先原则。
（3）时间片原则。

### 3.1.3 中级调度 ###
中级调度（Intermediate Level Scheduling）又称中程调度（Medium-Term Scheduling）。引入中级调度的主要目的是为了提高内存利用率和系统吞吐量。

## 3.2 调度队列模型和调度准则 ##
### 3.2.1 调度队列模型 ###
高级调度、低级调度以及中级调度
#### 1.仅有进程调度的调度队列模型 ####

#### 2.具有高级和低级调度的调度队列模型 ####

（1）就绪队列的形式。

（2）设置多个阻塞队列

#### 3.同时具有三级调度的调度队列模型 ####

### 3.2.2 选择调度方式和调度算法的若干准则 ###
在一个操作系统的设计中，应如何选择调度方式和算法，在很大程度上取决于操作系统的类型及其目标。
#### 1.面向用户的准则 ####
（1）周期时间短
所谓周转时间，是指从作业被提交给系统开始
（2）响应时间快
（3）截止时间的保证
（4）优先权准则
#### 2.面向系统的准则 ####
（1）系统吞吐量高
（2）处理机利用率好
（3）各类资源的平衡利用

## 3.3 调度算法 ##
### 3.2.1 先来先服务和短作业（进程）优先调度算法 ###
#### 1.先来先服务调度算法 ####
先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。
FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。

#### 2.短作业（进程）优先调度算法 ####
短作业(进程)优先调度算法 SJ(P)F，是指对短作业或短进程优先调度的算法。短作业优先（SJF）的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。

在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。
### 3.3.2 高优先权优先调度算法 ###
#### 1.优先权调度算法的类型 ####

1）非抢占式优先权算法
在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。

这种调度算法主要用于批处理系统中；也可用于某些对**实时性要求不严**的实时系统中。
2）抢占式优先权调度算法
在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。

这种抢占式的优先权调度算法能更好地满足**紧迫作业的要求**，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

#### 2.优先权的类型 ####
静态优先权，动态优先权
1）静态优先权
静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。
2）动态优先权
#### 3.高响应比优先调度算法 ####
优先权 = （等待时间 + 要求服务时间）/ 要求服务时间

### 3.3.3 基于时间片的轮转调度算法 ###
#### 1.时间片轮转法 ####
1）基本原理
在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。
2）时间片大小的确定

#### 2.多级反馈队列调度算法 ####
(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。
(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。
(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。

3.多级反馈队列
（1）终端型作业用户
（2）短批处理作业用户
（3）长批处理作业用户
## 3.4 实时调度 ##

### 3.4.1 实现实时调度的基本条件 ###
1.提供必要的信息
（1）就绪时间，该任务成为就绪状态的起始时间。
（2）开始截止时间和完成截止时间
（3）处理时间，指一个任务从开始执行直到完成所需的时间。
（4）资源要求。
（5）优先级。
2.系统处理能力强
在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有可能因处理机忙不过来而使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。

解决的方法是提高系统的处理能力，其途径有二：其一仍是采用单处理机系统，但须增强其处理能力，以显著地减少对每一个任务的处理时间；其二是采用多处理机系统。

3.采用抢占式调度机制

4.具有快速切换机制
（1）对外部中断的快速响应能力
（2）快速的任务分派能力
### 3.4.2 实时调度算法的分类 ###
#### 1.非抢占式调度算法 ####

1）非抢占式轮转调度算法

2）非抢占式优先调度算法

#### 2.抢占式调度算法 ####
在要求较严格的(响应时间为数十毫秒以下)的实时系统中，应采用抢占式优先权调度算法。
1) 基于时钟中断的抢占式优先权调度算法
在某实时任务到达后，如果该任务的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断到来时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先权任务。
2) 立即抢占(Immediate Preemption)的优先权调度算法
在这种调度策略中，要求操作系统具有快速响应外部事件中断的能力。一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。


### 3.4.3 常用的几种实时调度算法 ###

1.最早截止时间优先即EDF（Earliest Deadline First）算法
该算法是根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。

1）非抢占式调度方式用于非周期实时任务

2）抢占式调度方式用于周期实时任务

2．最低松弛度优先即 LLF(Least Laxity First)算法
该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高，以使之优先执行。

## 3.5 产生死锁的原因和必要条件 ##
所谓死锁(Deadlock)，是指多个进程在运行过程中因争夺资源而造成的一种僵局(DeadlyEmbrace)，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
### 3.5.1 产生死锁的原因 ###
(1) 竞争资源。

(2) 进程间推进顺序非法。
#### 1.竞争资源引起进程死锁 ####
1）可剥夺和非剥夺性资源

一类是可剥夺性资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。

另一类资源是不可剥夺性资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放。

2）竞争非剥夺性资源

3）竞争临时性资源

还有一种是所谓的临时性资源，这是指由一个进程产生，被另一进程使用一短暂时间后便无用的资源，故也称之为消耗性资源，它也可能引起死锁。

#### 2.进程推进顺序不当引起死锁 ####

### 3.5.2 产生死锁的必要条件 ###
（1）互斥条件

（2）请求和保持条件

（3）不剥夺条件

（4）环路等待条件

### 3.5.3 处理死锁的基本方法 ###
（1）预防死锁
事先预防

（2）避免死锁
事先预防

（3）检测死锁

（4）解除死锁
撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。

## 3.6 预防死锁的方法 ##
预防死锁和避免死锁这两种方法实质上都是通过施加某些限制条件，来预
防发生死锁。

### 3.6.1 预防死锁 ###

#### 1. 摒弃“请求和保持”条件 ####
优点：简单、易于实现且很安全
缺点：首先表现为资源被严重浪费，因为一个进程是一次性地获得其整个运行过程所需的全部资源的，且独占资源，其中可能有些资源很少使用，甚至在整个运行期间都未使用，这就严重地恶化了系统资源的利用率；其次是使进程延迟运行，仅当进程在获得了其所需的全部资源后，才能开始运行，但可能因有些资源已长期被其它进程占用而致使等待该资源的进程迟迟不能运行。
#### 2.摒弃“不剥夺”条件 ####
进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。
#### 3．摒弃“环路等待”条件 ####
系统将所有资源按类型进行线性排队，并赋予不同的序号。

### 3.6.2 系统安全状态 ###

1.安全状态

2.安全状态之例

3.由安全状态向不安全状态的转换

### 3.6.3 利用银行家算法避免死锁 ###
最有代表性的避免死锁的算法，是 Dijkstra 的银行家算法。

1.银行家算法中的数据结构

（1）可利用资源向量Avaiable。

（2）最大需求矩阵Max。

（3）分配矩阵Allocation。

（4）需求矩阵Need。

#### 2.银行家算法 ####
(1). 如果 Request<sub>i</sub>[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。

(2) 如果 Request i [j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，P<sub>i</sub> 须等待。

(3) 系统试探着把资源分配给进程 P<sub>i</sub> ，并修改下面数据结构中的数值：
Available[j]:= Available[j]-Request<sub>i</sub>[j]；
Allocation[i,j]:= Allocation[i,j]+Request<sub>i</sub>[j]；
Need[i,j]:= Need[i,j]-Request<sub>i</sub>[j]；

(4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程 P<sub>i</sub>，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程 P<sub>i</sub>等待。
#### 3.安全性算法 ####
（1）设置两个向量：
工作向量Work，它表示系统可提供给进程运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work:=Available。
Finish，它表示系统是否有足够的资源分配给进程。

4.银行家算法之例

## 3.7 死锁的检测与解除 ##

### 3.7.1 死锁的检测 ###

#### 1.资源分配图(Resource Allocation Graph) ####



